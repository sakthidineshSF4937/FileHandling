// <copyright file="DocumentManipulatorService.cs" company="Syncfusion Inc">
// Copyright (c) Syncfusion Inc. All rights reserved.
// </copyright>

namespace DocumentManipulator
{
  extern alias PortableBouncyCastle;

  using System;
  using System.Collections.Concurrent;
  using System.Collections.Generic;
  using System.Collections.Immutable;
  using System.ComponentModel;
  using System.Drawing;
  using System.Drawing.Imaging;
  using System.Drawing.Text;
  using System.Globalization;
  using System.IO;
  using System.Linq;
  using System.Net;
  using System.Net.Http;
  using System.Reflection;
  using System.Runtime.InteropServices;
  using System.Security.Cryptography;
  using System.Security.Cryptography.X509Certificates;
  using System.Text;
  using System.Text.RegularExpressions;
  using System.Threading;
  using System.Threading.Tasks;
  using Azure.Security.KeyVault;
  using Azure.Security.KeyVault.Secrets;
  using Azure.Storage.Blobs;
  using Azure.Storage.Blobs.Models;
  using BoldSign.ApiManagement.Models.DigitalSignQueue;
  using BoldSign.ApiManagement.Models.Interfaces;
  using BoldSign.ApiManagement.Models.Models.ApiEvent;
  using BoldSign.ApiManagement.Models.TextTags.Models;
  using BoldSign.ApiManagement.Resource;
  using BoldSign.AuditLog;
  using BoldSign.AuditLog.Implementation;
  using BoldSign.Base;
  using BoldSign.Base.Database;
  using BoldSign.Base.DataClasses;
  using BoldSign.Base.EmailHandlerProcess;
  using BoldSign.Base.Extensions;
  using BoldSign.Base.Interface;
  using BoldSign.Base.Interface.BulkSend;
  using BoldSign.Base.Models;
  using BoldSign.Base.Models.BulkSend;
  using BoldSign.Base.Models.EmailHandler;
  using BoldSign.Base.Models.EvroTrust;
  using BoldSign.Base.Models.ImportDocumentDetails;
  using BoldSign.Base.Models.SMSQueue;
  using BoldSign.Base.Policy.BulkSend;
  using BoldSign.Base.Policy.Documents;
  using BoldSign.Base.Policy.LinkForms;
  using BoldSign.Base.Policy.Template;
  using BoldSign.Base.Serializer;
  using BoldSign.Base.Service;
  using BoldSign.Base.Utility;
  using BoldSign.DocumentManipulator.DigitalSignature;
  using BoldSign.DocumentManipulator.GlobalSign;
  using BoldSign.DocumentManipulator.Helper;
  using BoldSign.DocumentManipulator.Interface;
  using BoldSign.DocumentManipulator.Interfaces;
  using BoldSign.DocumentManipulator.Models;
  using BoldSign.DocumentManipulator.PdfAudit;
  using BoldSign.DocumentManipulator.Resources;
  using BoldSign.DocumentManipulator.Service;
  using BoldSign.DocumentManipulator.TextTags;
  using BoldSign.DocumentManipulator.TextTags.TextExtractor;
  using BoldSign.DocumentManipulator.TextTags.Validator;
  using BoldSign.DocumentManipulator.Utilities;
  using BoldSign.WebHooks.Interfaces;
  using BoldSign.WebHooks.Models;
  using CsvHelper;
  using CsvHelper.Configuration.Attributes;
  using Dasync.Collections;
  using DocumentManipulator.Extensions;
  using DocumentManipulator.Helper;
  using DocumentManipulator.Interfaces;
  using DocumentManipulator.Models;
  using Microsoft.AspNetCore.Authorization;
  using Microsoft.AspNetCore.Hosting;
  using Microsoft.AspNetCore.Http;
  using Microsoft.AspNetCore.Mvc;
  using Microsoft.AspNetCore.SignalR;
  using Microsoft.EntityFrameworkCore;
  using Microsoft.Extensions.DependencyInjection;
  using Microsoft.Extensions.Hosting;
  using Microsoft.Extensions.Logging;

  using Nest;
  using NuGet.Protocol;
  using PhoneNumbers;
  using PortableBouncyCastle::Org.BouncyCastle.Security;

  using Serilog;

  using SignalRNotify;
  using SkiaSharp;
  using Svg;
  using Svg.Skia;
  using Syncfusion.DocIO;
  using Syncfusion.DocIO.DLS;
  using Syncfusion.DocIORenderer;
  using Syncfusion.EJ2.Linq;
  using Syncfusion.EJ2.PdfViewer;
  using Syncfusion.OfficeChart;
  using Syncfusion.Pdf;
  using Syncfusion.Pdf.Graphics;
  using Syncfusion.Pdf.Grid;
  using Syncfusion.Pdf.Interactive;
  using Syncfusion.Pdf.Parsing;
  using Syncfusion.Pdf.Security;
  using Syncfusion.Pdf.Tables;
  using Syncfusion.XlsIO.Interfaces;
  using Syncfusion.XlsIORenderer;
  using TimeZoneConverter;
  using SignerDetails = BoldSign.Base.Models.SignerDetails;
  using Zip = Syncfusion.Compression.Zip;

  /// <summary>
  /// The service to manipulate the document.
  /// </summary>
  public class DocumentManipulatorService : IDocumentManipulatorService
  {
    /// <summary>
    /// The upload progress key.
    /// </summary>
    public const string UploadProgressOptionsKey = "UploadProgressOptions";

    private const string Format = "X2";
    private const string SignerIdData = "SIGNERID";
    private const string RadioField = "RADIOBUTTON";
    private const string TextBoxField = "TEXTBOX";
    private const string LabelField = "LABEL";
    private const string DropDownField = "DROPDOWN";
    private const string SignatureField = "SIGNATURE";
    private const string ImageField = "IMAGE";
    private const string DatePickerField = "DATEPICKER";
    private const string CheckBoxField = "CHECKBOX";
    private const string InitialField = "INITIAL";
    private const string EmailField = "EMAIL";
    private const string CompanyField = "COMPANY";
    private const string TitleField = "TITLE";
    private const string NameField = "NAME";
    private const string AttachmentField = "ATTACHMENT";
    private const string FormulaField = "FORMULA";
    private const string AttachmentFieldValue = " - Attachment";
    private const string EditableDateField = "EDITABLEDATE";
    private const string HelveticaFont = "HELVETICA";
    private const string CourierFont = "COURIER";
    private const string TimesNewRomanFont = "TIMES NEW ROMAN";
    private const string NotoSansFont = "NOTO SANS";
    private const string HyperLinkField = "HYPERLINK";
    private const int BlobRequestCount = 20;
    private const float DocIdFontSize = 7.5F;
    private const float DocIdPositionX = 12.75F;
    private const float DocIdPositionY = 5.25F;
    private const float TitleHeight = 28.5F;
    private const int ContentHeight = 16;
    private const int DisclaimerLineGap = 25;
    private const char BasicLatinMinRange = '\u0000';
    private const char BasicLatinMaxRange = '\u007F';
    private const int DefaultWidth = 400;
    private const int ChildGridColumn1Width = 310;
    private const float RequiredWidth = 800F;
    private const float RequiredHeight = 400F;
    private const int BulkDocumentSizeLimit = 25000000;
    private const string TaggedText = "taggedtext";
    private const string AuditTrail = "_AuditTrail";
    private const int BulkExportLimit = 100;
    private const int ExportBatchSize = 20;
    private const string AuditLog = "AuditTrail";
    private const int MaxRetryCount = 3;
    private const int BlankPageSizeOffset = 2;
    private const float Version1ZoomFactor = 1;
    private const float Version2ZoomFactor = 1.5F;
    private const string InheritFromBusinessProfile = "Inherit from business profile";
    private const string TimestampPattern = @"\{timestamp\}";
    private const string EvrotrustDocument = "document_evrotrust";
    private readonly object emptySignLockObj = new object(); // Synchronization lock object

    private static readonly List<AuditAction> AllowedAuditActions = new List<AuditAction>()
    {
        AuditAction.AccessCodeChanged, AuditAction.AuthenticationFailed, AuditAction.AuthenticationRemoved, AuditAction.CancelPrintSign, AuditAction.Completed,
        AuditAction.CompletePrintSign, AuditAction.Created, AuditAction.Downloaded, AuditAction.DownloadedForPrintSign, AuditAction.EmailOTP,
        AuditAction.FormCreated, AuditAction.InitiatePrintSign, AuditAction.Reassigned, AuditAction.Reminder, AuditAction.Resend, AuditAction.Attachment,
        AuditAction.Reviewed, AuditAction.Sent, AuditAction.Signed, AuditAction.Viewed, AuditAction.EmbeddedSigned, AuditAction.EmbeddedReviewed, AuditAction.EditRecipient, AuditAction.AuthenticationAdded,
        AuditAction.SMSOTP, AuditAction.SmsOtpVerify, AuditAction.PhoneNumberChanged, AuditAction.SmsAuthenticationAdded, AuditAction.SmsAuthenticationRemoved,
        AuditAction.EmailAuthenticationAdded, AuditAction.EmailAuthenticationRemoved, AuditAction.EmailOtpVerify,
        AuditAction.EmailOTPAuthenticationAdded, AuditAction.EmailOTPAuthenticationRemoved, AuditAction.EmailOTPVerified,
        AuditAction.IdentityVerificationCompleted, AuditAction.EditingCompleted, AuditAction.GenerateSignLink,
    };

    private static readonly PhoneNumberUtil PhoneNumberUtil = PhoneNumberUtil.GetInstance();

    private readonly bool turnOffEmail = BoldSignBase.EnvironmentVariables.TurnOffEmail;

    private readonly Lazy<PdfBrush> blackBrush = new Lazy<PdfBrush>(() => new PdfSolidBrush(new PdfColor(51, 56, 66)), true);
    private readonly Lazy<PdfBrush> headerBlackBrush = new Lazy<PdfBrush>(() => new PdfSolidBrush(new PdfColor(51, 51, 51)), true);

    private readonly Lazy<PdfPen> grayPen =
      new Lazy<PdfPen>(() => new PdfPen(new PdfColor(Syncfusion.Drawing.Color.FromArgb(1, 204, 204, 204)), 1f), true);

    private readonly Lazy<PdfPen> auditTablePen =
      new Lazy<PdfPen>(() => new PdfPen(new PdfColor(226, 232, 240), 1f), true);

    private readonly Lazy<PdfSolidBrush> patternGrayBrush = new Lazy<PdfSolidBrush>(() => new PdfSolidBrush(new PdfColor(255, 245, 245, 245)));

    private readonly Lazy<PdfSolidBrush> auditGrayBrush = new Lazy<PdfSolidBrush>(() => new PdfSolidBrush(new PdfColor(102, 110, 128)));

    private readonly IDocumentAccessRightsService accessRightsService;
    private readonly IAuthorizationDetailsService authorizationDetailsService;

    private readonly IWebHostEnvironment hostingEnvironment;

    private readonly IDocumentRepositoryService documentRepositoryService;
    private readonly IElasticClient elasticClient;
    private readonly IHttpContextAccessor httpContextAccessor;
    private readonly HttpContext httpContext;
    private readonly IImageUtilityService imageUtilityService;
    private readonly IHubContext<NotificationHub> hubContext;
    private readonly DocumentAuditLog documentAuditLog;
    private readonly ILogger<DocumentManipulatorService> logger;
    private readonly EmailHandler emailHandler;
    private readonly ISignalRNotificationService signalRNotificationService;
    private readonly UserDataService userDataService;
    private readonly RequestDetailsService requestDetailsService;
    private readonly GlobalSignService globalSignService;
    private readonly IDocumentContentService documentContentService;
    private readonly IWebHookService webHookService;
    private readonly IHttpClientFactory clientFactory;
    private readonly EntrustCertificateService entrustCertificateService;
    private readonly ICacheService cacheService;
    private readonly IAccessRightsDetailsService accessRightsDetailsService;
    private readonly IDocumentUploadStatusService documentUploadStatusService;
    private readonly IExtendedDocumentDetailsService extendedDocumentDetailsService;
    private readonly IDocumentAttachmentService documentAttachmentService;
    private readonly ITimeZoneConversionService timeZoneConversionService;
    private readonly DataBaseContext dataBaseContext;
    private readonly IServiceScopeFactory serviceScopeFactory;
    private readonly IPostHogEventService postHogEventService;
    private readonly ITwilioSmsService twilioSmsService;
    private readonly IOrgActivityService orgActivityService;
    private readonly IBusinessProfileService businessProfileService;
    private readonly ICloudUploadService cloudUploadService;
    private readonly IDownloadAuditTrailService downloadAuditTrailService;
    private readonly int blankPageDefaultSize = BoldSignBase.EnvironmentVariables.BlankPageDefaultSize;
    private readonly IOrganizationService organizationService;
    private readonly IImportDocumentsQueryService importDocumentsQueryService;
    private readonly IEvroTrustApiService evroTrustApiService;
    private readonly IScheduledService scheduledService;
    private PdfUnitConverter converter = new PdfUnitConverter();

    /// <summary>
    /// Initializes a new instance of the <see cref="DocumentManipulatorService"/> class.
    /// </summary>
    /// <param name="emailHandler">emailHandler.</param>
    /// <param name="accessRightsService">accessRightsService.</param>
    /// <param name="authorizationDetailsService">authorizationDetailsService.</param>
    /// <param name="hostingEnvironment">hostingEnvironment.</param>
    /// <param name="documentRepositoryService">The document repository.</param>
    /// <param name="elasticClient">elasticClient.</param>
    /// <param name="hubContext">hubContext.</param>
    /// <param name="cloudStorage">cloudStorage.</param>
    /// <param name="documentAuditLog">documentAuditLog.</param>
    /// <param name="logger">logger.</param>
    /// <param name="signalRNotificationService">signalRNotificationService.</param>
    /// <param name="httpContextAccessor">HttpContext Accessor.</param>
    /// <param name="imageUtilityService">Image UtilityService.</param>
    /// <param name="userDataService">The user data service.</param>
    /// <param name="requestDetailsService">The request details service.</param>
    /// <param name="globalSign"> The globalsign request.</param>
    /// <param name="extendedDocumentDetailsService"> The document details service.</param>
    /// <param name="documentContentService"> The document content service.</param>
    /// <param name="webHookService"> The webHook service.</param>
    /// <param name="clientFactory"> clientFactory.</param>
    /// <param name="entrustCertificateService"> entrustCertificateService.</param>
    /// <param name="cacheService">cache service.</param>
    /// <param name="accessRightsDetailsService">The Access rights service.</param>
    /// <param name="documentUploadStatusService">Document upload status service.</param>
    /// <param name="documentAttachmentService">Document attachment service.</param>
    /// <param name="dataBaseContext">The database context.</param>
    /// <param name="timeZoneConversionService">timeZoneConversionService.</param>
    /// <param name="serviceScopeFactory">The service scope.</param>
    /// <param name="postHogEventService">The posthog event service.</param>
    /// <param name="twilioSmsService">The twilio sms service.</param>
    /// <param name="orgActivityService">The org Activity Service.</param>
    /// <param name="businessProfileService">The business profile Service.</param>
    /// <param name="cloudUploadService">The cloud upload service.</param>
    /// <param name="organizationService">The organization service.</param>
    /// <param name="downloadAuditTrailService">The downloadAuditTrailService.</param>
    /// <param name="importDocumentsQueryService">The importDocumentsQueryService.</param>
    /// <param name="evroTrustApiService">The evroTrustApiService.</param>
    /// <param name="scheduledService">The schedule actions.</param>
    public DocumentManipulatorService(
      EmailHandler emailHandler,
      IDocumentAccessRightsService accessRightsService,
      IAuthorizationDetailsService authorizationDetailsService,
      IWebHostEnvironment hostingEnvironment,
      IDocumentRepositoryService documentRepositoryService,
      IElasticClient elasticClient,
      IHubContext<NotificationHub> hubContext,
      CloudStorage cloudStorage,
      DocumentAuditLog documentAuditLog,
      ILogger<DocumentManipulatorService> logger,
      ISignalRNotificationService signalRNotificationService,
      IHttpContextAccessor httpContextAccessor,
      IImageUtilityService imageUtilityService,
      UserDataService userDataService,
      RequestDetailsService requestDetailsService,
      GlobalSignService globalSign,
      IExtendedDocumentDetailsService extendedDocumentDetailsService,
      IDocumentContentService documentContentService,
      IWebHookService webHookService,
      IHttpClientFactory clientFactory,
      EntrustCertificateService entrustCertificateService,
      ICacheService cacheService,
      IAccessRightsDetailsService accessRightsDetailsService,
      IDocumentUploadStatusService documentUploadStatusService,
      IDocumentAttachmentService documentAttachmentService,
      DataBaseContext dataBaseContext,
      ITimeZoneConversionService timeZoneConversionService,
      IServiceScopeFactory serviceScopeFactory,
      IPostHogEventService postHogEventService,
      ITwilioSmsService twilioSmsService,
      IOrgActivityService orgActivityService,
      IBusinessProfileService businessProfileService,
      ICloudUploadService cloudUploadService,
      IOrganizationService organizationService,
      IDownloadAuditTrailService downloadAuditTrailService,
      IEvroTrustApiService evroTrustApiService,
      IImportDocumentsQueryService importDocumentsQueryService,
      IScheduledService scheduledService)
    {
      this.accessRightsService = accessRightsService;
      this.authorizationDetailsService = authorizationDetailsService;
      this.hostingEnvironment = hostingEnvironment;
      this.documentRepositoryService = documentRepositoryService;
      this.hubContext = hubContext;
      this.CloudStorage = cloudStorage;
      this.documentAuditLog = documentAuditLog;
      this.logger = logger;
      this.emailHandler = emailHandler;
      this.signalRNotificationService = signalRNotificationService;
      this.elasticClient = elasticClient;
      this.httpContextAccessor = httpContextAccessor;
      this.httpContext = httpContextAccessor?.HttpContext;
      this.imageUtilityService = imageUtilityService;
      this.userDataService = userDataService;
      this.requestDetailsService = requestDetailsService;
      this.globalSignService = globalSign;
      this.documentContentService = documentContentService;
      this.webHookService = webHookService;
      this.clientFactory = clientFactory;
      this.entrustCertificateService = entrustCertificateService;
      this.cacheService = cacheService;
      this.accessRightsDetailsService = accessRightsDetailsService;
      this.documentUploadStatusService = documentUploadStatusService;
      this.extendedDocumentDetailsService = extendedDocumentDetailsService;
      this.documentAttachmentService = documentAttachmentService;
      this.dataBaseContext = dataBaseContext;
      this.timeZoneConversionService = timeZoneConversionService;
      this.serviceScopeFactory = serviceScopeFactory;
      this.postHogEventService = postHogEventService;
      this.twilioSmsService = twilioSmsService;
      this.orgActivityService = orgActivityService;
      this.businessProfileService = businessProfileService;
      this.cloudUploadService = cloudUploadService;
      this.organizationService = organizationService;
      this.downloadAuditTrailService = downloadAuditTrailService;
      this.importDocumentsQueryService = importDocumentsQueryService;
      this.evroTrustApiService = evroTrustApiService;
      this.scheduledService = scheduledService;
    }

    /// <summary>
    /// Gets or sets property to CloudStorage.
    /// </summary>
    public CloudStorage CloudStorage { get; set; }

    /// <summary>
    /// Gets or sets property to DocumentUploadDetails
    /// </summary>
    public IDocumentUploadDetails DocumentUploadDetails { get; set; }

    /// <summary>
    /// Retrieves the DocumentDetails from the HTTP context, if the HTTP context does not have the details then  null value is returned.
    /// </summary>
    /// <param name="context">context.</param>
    /// <returns>DocumentDetails.</returns>
    public static DocumentDetails GetDocumentDetailsCache(HttpContext context)
    {
      if (context != null && context.Items.TryGetValue(DocumentDetailsReader.DocumentDetailsData, out object documentDetail))
      {
        if (documentDetail is DocumentDetails documentDetails)
        {
          return documentDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Retrieves the SignerDetails from the HTTP context, if the HTTP context does not have the details then  null value is returned.
    /// </summary>
    /// <param name="context">context.</param>
    /// <returns>SignerDetails.</returns>
    public static List<LinkSignerDetails> GetCompletedLinkSignerDetailsCache(HttpContext context)
    {
      if (context != null && context.Items.TryGetValue(LinkFormDetailsReader.CompletedLinkSignerDetailslistConst, out object completedLinkSignerDetail))
      {
        if (completedLinkSignerDetail is List<LinkSignerDetails> completedLinkSignerDetails)
        {
          return completedLinkSignerDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Gets the BulkDownload details cache.
    /// </summary>
    /// <param name="context">The context.</param>
    /// <returns>A BulkDownloadDetails.</returns>
    public static BulkDownloadDetails GetBulkDownloadDetailscache(HttpContext context)
    {
      if (context.Items.TryGetValue(LinkFormDetailsReader.BulkDownloadDetailsConst, out object bulkDownloadDetail))
      {
        if (bulkDownloadDetail is BulkDownloadDetails bulkDownloadDetails)
        {
          return bulkDownloadDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Gets the BulkSend download details cache.
    /// </summary>
    /// <param name="context">The context.</param>
    /// <returns>A BulkSend Download Details.</returns>
    public static BulkDownloadDetails GetBulkSendDownloadDetailsCache(HttpContext context)
    {
      if (context.Items.TryGetValue(BulkSendDetailsReader.BulkSendDownloadDetailsConst, out object bulkSendDownloadDetail))
      {
        if (bulkSendDownloadDetail is BulkDownloadDetails bulkDownloadDetails)
        {
          return bulkDownloadDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Gets the BulkSend details cache.
    /// </summary>
    /// <param name="context">The context.</param>
    /// <returns>A BulkSend Document Details.</returns>
    public static BulkSendDetails GetBulkSendDetailsCache(HttpContext context)
    {
      if (context.Items.TryGetValue(BulkSendDetailsReader.BulkSendDetailsConst, out object bulkSendDetail))
      {
        if (bulkSendDetail is BulkSendDetails bulkSendDetails)
        {
          return bulkSendDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Gets the BulkSend document details from the HTTP context.
    /// </summary>
    /// <param name="context">context.</param>
    /// <returns>BulkSendDocumentDetails.</returns>
    public static List<AccessRightsDetailsExtend> GetBulkSendDocumentDetailsCache(HttpContext context)
    {
      if (context != null && context.Items.TryGetValue(BulkSendDetailsReader.BulkSendDocumentDetailsListConst, out object bulkSendDocumentDetails))
      {
        if (bulkSendDocumentDetails is List<AccessRightsDetailsExtend> documentDetails)
        {
          return documentDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Retrieves the access rights details from the HTTP context, if the HTTP context does not have the details then  null value is returned.
    /// </summary>
    /// <param name="context">context.</param>
    /// <returns>AccessRightsDetails.</returns>
    public static AccessRightsDetails GetAccessRightsDetailsCache(HttpContext context)
    {
      if (context != null && context.Items.TryGetValue(TemplateDetailsReader.AccessRightsData, out object accessReightsDetail))
      {
        if (accessReightsDetail is AccessRightsDetails accessReightsDetails)
        {
          return accessReightsDetails;
        }
      }

      return null;
    }

    /// <summary>
    /// Gets the sender detail.
    /// </summary>
    /// <param name="documentDetails">The document details.</param>
    /// <param name="organizationId">The organization id.</param>
    /// <returns>A SenderDetail.</returns>
    public static SenderDetail GetSenderDetail(DocumentDetails documentDetails, string organizationId)
    {
      SenderDetail senderDetail = new SenderDetail();

      if (documentDetails != null)
      {
        senderDetail.Name = documentDetails.SentBy;
        senderDetail.OrganizationId = organizationId;
        senderDetail.UserId = documentDetails.CreatedBy;
        senderDetail.TeamId = documentDetails.TeamId;
        senderDetail.AccessUid = documentDetails.CreatedBy;
        senderDetail.EmailAddress = documentDetails.SenderEmail;
      }

      return senderDetail;
    }

    /// <inheritdoc/>
    public byte[] ConvertWordToPdf(Stream wordDocStream, DocumentProgress documentProgress)
    {
      // Loads file stream into Word document
      using WordDocument wordDocument = new WordDocument(wordDocStream, Syncfusion.DocIO.FormatType.Automatic);

      // SubstituteFont event for font fall back
      wordDocument.FontSettings.SubstituteFont += this.FontSettings_SubstituteFont;

      // Instantiation of DocIORenderer for Word to PDF conversion
      using DocIORenderer render = new DocIORenderer();

      // Sets Chart rendering Options.
      render.Settings.ChartRenderingOptions.ImageFormat = Syncfusion.OfficeChart.ExportImageFormat.Jpeg;

      // Sets true to preserve document structured tags in the converted PDF document
      render.Settings.AutoTag = true;

      // Converts Word document into PDF document
      PdfDocument pdfDocument = render.ConvertToPDF(wordDocument);

      void PdfHandler(object sender, ProgressEventArgs arguments)
      {
        if (documentProgress != null)
        {
          _ = documentProgress.UpdateOverallProgress(arguments.Progress * 100);
        }
      }

      if (documentProgress != null)
      {
        // Since we are adding the progress for word to PDF along with other progress (4 total) each progress needs to be split by 18.86F to attain 75 percent (18.86F * 4) server side percenatge.
        documentProgress.ModifyCompletionRatio(5.3F);
        documentProgress.Reset();
        pdfDocument.SaveProgress += PdfHandler;
      }

      // Saves the PDF file
      using MemoryStream outputStream = new MemoryStream();
      pdfDocument.Save(outputStream);

      if (documentProgress != null)
      {
        pdfDocument.SaveProgress -= PdfHandler;
        documentProgress.Reset();
      }

      // Closes the instance of PDF document object
      pdfDocument.Close(true);
      PdfDocument.ClearFontCache();
      return outputStream.ToArray();
    }

    /// <inheritdoc/>
    public byte[] ConvertExcelToPdf(Stream xlDocStream, DocumentProgress documentProgress)
    {
      using Syncfusion.XlsIO.ExcelEngine excelEngine = new Syncfusion.XlsIO.ExcelEngine();
      Syncfusion.XlsIO.IApplication application = excelEngine.Excel;
      application.DefaultVersion = Syncfusion.XlsIO.ExcelVersion.Xlsx;
      Syncfusion.XlsIO.IWorkbook workbook = application.Workbooks.Open(xlDocStream);
      xlDocStream.Dispose();

      // Initialize XlsIO renderer.
      XlsIORenderer render = new XlsIORenderer();

      // Convert Excel document into PDF document.
      using PdfDocument pdfDocument = render.ConvertToPDF(workbook);
      void PdfHandler(object sender, ProgressEventArgs arguments)
      {
        if (documentProgress != null)
        {
          _ = documentProgress.UpdateOverallProgress(arguments.Progress * 100);
        }
      }

      if (documentProgress != null)
      {
        // Since we are adding the progress for word to PDF along with other progress (4 total) each progress needs to be split by 18.86F to attain 75 percent (18.86F * 4) server side percenatge.
        documentProgress.ModifyCompletionRatio(5.3F);
        documentProgress.Reset();
        pdfDocument.SaveProgress += PdfHandler;
      }

      using MemoryStream outputStream = new MemoryStream();
      pdfDocument.Save(outputStream);

      if (documentProgress != null)
      {
        pdfDocument.SaveProgress -= PdfHandler;
        documentProgress.Reset();
      }

      // Closes the instance of PDF document object
      pdfDocument.Close(true);
      PdfDocument.ClearFontCache();
      return outputStream.ToArray();
    }

    /// <inheritdoc/>
    public async Task UpdateUploadProgress(string message, bool isUploadFailed)
    {
      if (this.httpContext.Items[UploadProgressOptionsKey] is UploadProgressOptions progressOptions)
      {
        if (!string.IsNullOrEmpty(progressOptions.ChannelId))
        {
          var notification = new DocumentUploadProgress()
          {
            IsUploadFailed = isUploadFailed,
            Message = message,
            PayloadType = "documentUpload",
            DocumentId = progressOptions.DocumentId,
            DocumentClientId = progressOptions.DocumentClientId,
            ParentDocumentId = progressOptions.ParentDocumentId,
          };

          await this.signalRNotificationService.UpdateDocumentUploadProgress(progressOptions.ChannelId, notification, progressOptions.IsNormalUpload)
            .ConfigureAwait(false);
        }

        if (progressOptions.ResponseWriter != null)
        {
          await progressOptions.ResponseWriter.WriteAsync(message).ConfigureAwait(false);
        }
      }
    }

    /// <summary>
    /// Validates the Corrupted PDF Document.
    /// </summary>
    /// <param name="documentUploadDetails">The document upload details.</param>
    public static void ValidateCorruptedPDFDocument(IDocumentUploadDetails documentUploadDetails)
    {
      using Stream documentstream = GetPdfDocumentStreamForValdiation(documentUploadDetails);
      var contenttype = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType);

      if (contenttype == ContentType.PDF)
      {
        // Create a new instance for the PDF analyzer
        PdfDocumentAnalyzer analyzer = new PdfDocumentAnalyzer(documentstream);

        // Get the syntax errors
        SyntaxAnalyzerResult result = analyzer.AnalyzeSyntax();
        analyzer.Close();

        // Check whether the document is corrupted or not
        if (result.IsCorrupted)
        {
          string firstErrorMessage = result.Errors.Count > 0 ? result.Errors[0].Message : string.Empty;

          switch (firstErrorMessage)
          {
            case "Can't open an encrypted document. The password is invalid.":
              throw new PdfException(CommonResource.InvalidPassword);

            default:
              throw new PdfException(CommonResource.CorruptedDocument);
          }
        }
      }
    }

    /// <inheritdoc/>
    public async Task<string> UploadAsync(IDocumentUploadDetails documentUploadDetails, bool isPrintSignDocument, IResponseWriter responseWriter = null, string preDefinedDocumentId = null, bool isNormalUpload = true, CancellationToken cancellationToken = default)
    {
      if (documentUploadDetails is null)
      {
        throw new ArgumentNullException(nameof(documentUploadDetails));
      }

      var uniqueId = string.IsNullOrEmpty(preDefinedDocumentId) ? Guid.NewGuid().ToString() : preDefinedDocumentId;
      _ = this.documentUploadStatusService.UpdateDocumentUploadStatusAsync(Guid.Parse(uniqueId), UploadStatus.InProgress);
      string parentId = string.IsNullOrEmpty(documentUploadDetails.ParentDocumentId) ? uniqueId : $"{documentUploadDetails.ParentDocumentId}";
      string childId = string.IsNullOrEmpty(documentUploadDetails.ParentDocumentId) ? string.Empty : $"{uniqueId}/";

      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      var organizationId = documentUploadDetails.OrganizationId;
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = documentUploadDetails.OrganizationId = this.userDataService?.OrganizationId;
      }

      this.httpContextAccessor.HttpContext.Items.Add(UploadProgressOptionsKey, new UploadProgressOptions()
      {
        IsPrintAndSignDocument = isPrintSignDocument,
        ChannelId = isPrintSignDocument ? parentId : documentUploadDetails.UploadChannelId,
        ParentDocumentId = string.IsNullOrEmpty(documentUploadDetails.ParentDocumentId) ? uniqueId : documentUploadDetails.ParentDocumentId,
        DocumentId = uniqueId,
        DocumentClientId = documentUploadDetails.DocumentClientId,
        IsNormalUpload = isNormalUpload,
        ResponseWriter = (responseWriter is ResponseWriter<HttpResponse>) ? null : responseWriter,
      });

      try
      {
        await this.UploadAndManipulateDocument(parentId, uniqueId, childId, isPrintSignDocument, documentUploadDetails, responseWriter, cancellationToken).ConfigureAwait(false);
        _ = this.documentUploadStatusService.UpdateDocumentUploadStatusAsync(Guid.Parse(uniqueId), UploadStatus.Completed);
        return uniqueId;
      }
      catch (PdfDocumentException ex) when (ex.Message == "Can't open an encrypted document. The password is invalid.")
      {
        _ = this.documentUploadStatusService.UpdateDocumentUploadStatusAsync(Guid.Parse(uniqueId), UploadStatus.Failure, CommonResource.InvalidPassword);
        await this.UpdateUploadProgress(CommonResource.InvalidPassword, true).ConfigureAwait(false);
        this.logger.LogError(ex, CommonResource.InvalidPassword);
#pragma warning disable CA2200 // Rethrow for catching in controller and setting 400 resoponse.
        throw ex;
#pragma warning restore CA2200 // Rethrow to preserve stack details.
      }
      catch (OperationCanceledException)
      {
        _ = this.documentUploadStatusService.UpdateDocumentUploadStatusAsync(Guid.Parse(uniqueId), UploadStatus.Failure, CommonResource.OperationCanceled);
        if (isPrintSignDocument)
        {
          var cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, organizationId).ConfigureAwait(false);

          var resultSegment = cloudBlobContainer.GetBlobsByHierarchyAsync(prefix: $"{DbConstants.ScannedDocument}/", delimiter: "/")
           .AsPages(default, BlobRequestCount);

          // Enumerate therough each blob and delete.
          await foreach (Azure.Page<BlobHierarchyItem> blobPage in resultSegment)
          {
            foreach (BlobHierarchyItem blobhierarchyItem in blobPage.Values)
            {
              if (blobhierarchyItem.IsBlob)
              {
                _ = cloudBlobContainer.DeleteBlobAsync(blobhierarchyItem.Blob.Name).ConfigureAwait(false);
              }
            }
          }
        }

        throw;
      }
      catch (Exception exception)
      {
        if (exception is PdfException || exception is InvalidOperationException || exception is InvalidDataException)
        {
          string message = exception switch
          {
            PdfException pdfException => pdfException.Message switch
            {
              Constants.InvalidPassword => CommonResource.InvalidPassword,
              Constants.Portfolio => CommonResource.UnSupportedPortfolio,
              _ => CommonResource.CorruptedDocument
            },
            _ => exception.Message
          };
          _ = this.documentUploadStatusService.UpdateDocumentUploadStatusAsync(Guid.Parse(uniqueId), UploadStatus.Failure, message);
          await this.UpdateUploadProgress(message, true).ConfigureAwait(false);
          this.logger.LogError(exception, message);
        }

        throw;
      }
    }

    /// <inheritdoc/>
    public async Task MultipleUploadAsync(DocumentProperties[] documentUpload, string organizationId, CancellationToken token)
    {
      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = this.userDataService?.OrganizationId;
      }

      var documentOrder = documentUpload.OrderBy(x => x.Order);
      PdfViewerLoadDetails pdfViewerLoadDetails = new PdfViewerLoadDetails();
      var documentId = documentOrder.FirstOrDefault(x => !string.IsNullOrEmpty(x.ParentId))?.ParentId;
      var isTemplate = documentOrder.Any(x => x.UploadRequestType == UploadRequestType.UseTemplate || x.UploadRequestType == UploadRequestType.Template);
      BlobContainerClient cloudBlobContainer =
        await this.CloudStorage.GetContainer(documentId, organizationId).ConfigureAwait(false);
      var cloudThumbnailBlobContainer = await this.CloudStorage
        .GetContainer($"{documentId}-{DbConstants.Thumbnails}", organizationId).ConfigureAwait(false);
      BlobClient blob;
      foreach (var document in documentOrder)
      {
        // The corrupted document will have zero page count and there won't be subcontainer for it so it is skipped.
        if (document.PageCount == 0)
        {
          continue;
        }

        if (document.Order == -1)
        {
          if (string.IsNullOrEmpty(document.ParentId))
          {
            _ = this.DeleteDocumentBlobs(cloudBlobContainer, string.Empty).ConfigureAwait(false);
            _ = this.DeleteThumbnailBlobs(cloudThumbnailBlobContainer, string.Empty).ConfigureAwait(false);
          }
          else
          {
            _ = this.DeleteDocumentBlobs(cloudBlobContainer, $"{document.DocumentId}/").ConfigureAwait(false);
            _ = this.DeletePdfFormFieldMerged(cloudBlobContainer, string.Empty).ConfigureAwait(false);
            _ = this.DeleteThumbnailBlobs(cloudThumbnailBlobContainer, $"{document.DocumentId}/").ConfigureAwait(false);
          }

          continue;
        }

        if (string.IsNullOrEmpty(document.ParentId))
        {
          blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentDetails);
        }
        else
        {
          blob = cloudBlobContainer.GetBlobClient($"{document.DocumentId}/{DbConstants.DocumentDetails}");
        }

        PdfViewerLoadDetails viewerLoadDetails = await this.CloudStorage.DownloadAsync<PdfViewerLoadDetails>(blob, false).ConfigureAwait(false); // Newtonsoft.Json.JsonConvert.DeserializeObject<PdfViewerLoadDetails>(documentDetails);

        if (viewerLoadDetails != null)
        {
          foreach (var pageSizes in viewerLoadDetails.PageSizes)
          {
            pdfViewerLoadDetails.PageSizes.Add(pdfViewerLoadDetails.PageCount + pageSizes.Key, pageSizes.Value);
          }

          pdfViewerLoadDetails.PageCount += viewerLoadDetails.PageCount;
        }
      }

      if (cloudBlobContainer != null)
      {
        blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentMergedDetails);
        byte[] pdfViewerLoadBytes = BinarySerializer.Serialize(pdfViewerLoadDetails);
        await this.CloudStorage.UploadFromByteArrayAsync(blob, pdfViewerLoadBytes, 0, false).ConfigureAwait(false);
      }

      await this.MergeDocuments(documentOrder, cloudBlobContainer, documentId).ConfigureAwait(false);
      await this.MergePdfFieldAsync(documentOrder, cloudBlobContainer).ConfigureAwait(false);
      if (isTemplate)
      {
        await this.MergeDocumentTextAsync(documentOrder, cloudBlobContainer).ConfigureAwait(false);
      }
    }

    /// <summary>
    /// Upload the attachment document to the Azure blob storage.
    /// </summary>
    /// <param name="requestAttachmentDetails">Request attachment details.</param>
    /// <returns>A <see cref="Task{TResult}"/> representing the result of the asynchronous operation.</returns>
    public async Task<string> UploadAttachmentDocument(RequestAttachmentDetails requestAttachmentDetails)
    {
      try
      {
        using (var ms = new MemoryStream())
        {
          await requestAttachmentDetails.File.CopyToAsync(ms).ConfigureAwait(false);
          requestAttachmentDetails.DocumentArray = ms.ToArray();
        }

        byte[] documentArray = null;
        using Stream documentStream = this.GetPdfAttachmentStream(requestAttachmentDetails, ref documentArray);
        PdfDocument.EnableCache = false;
        using var pdfLoadedDocument = new PdfLoadedDocument(documentArray);
        requestAttachmentDetails.Id = this.GetHashValue(Guid.NewGuid().ToString().ToByteArray());
        var documentDetails = await this.documentContentService.GetDocumentDetails(requestAttachmentDetails.DocumentId)
          .ConfigureAwait(false);
        bool isUploadSuccess = await this.documentAttachmentService
          .AddAttachmentDocuments(requestAttachmentDetails, requestAttachmentDetails.DocumentArray, documentDetails.OrganizationId)
          .ConfigureAwait(false);

        if (isUploadSuccess)
        {
          return requestAttachmentDetails.Id;
        }
      }
      catch (PdfInvalidPasswordException exception) when (exception.Message == "Can't open an encrypted document. The password is invalid.")
      {
        this.logger.LogError(exception, CommonResource.InvalidPassword);
        throw;
      }
      catch (Exception exception)
      {
        if (exception is PdfException || exception is InvalidOperationException || exception is InvalidDataException)
        {
          string message = exception is PdfException ? exception.Message == Constants.Portfolio ?
            CommonResource.UnSupportedPortfolio : CommonResource.CorruptedDocument : exception.Message;
          this.logger.LogError(exception, message);
        }

        throw;
      }

      return string.Empty;
    }

    /// <summary>
    /// Delete the attachment document from the Azure blob storage.
    /// </summary>
    /// <param name="attachmentFileDetails">Attachment File Details.</param>
    /// <returns>A <see cref="Task{TResult}"/> representing the result of the asynchronous operation.</returns>
    public async Task<bool> DeleteAttachmentDocument(RequestAttachmentDetails attachmentFileDetails)
    {
      var documentDetails = await this.documentContentService.GetDocumentDetails(attachmentFileDetails.DocumentId)
        .ConfigureAwait(false);
      return await this.documentAttachmentService
        .DeleteAttachment(attachmentFileDetails, documentDetails.OrganizationId).ConfigureAwait(false);
    }

    /// <summary>
    /// Check Whether the pdf has form fields.
    /// </summary>
    /// <param name="documentId">The Document Id.</param>
    /// <param name="organizationId">The organization id.</param>
    /// <returns>A <see cref="Task{TResult}"/> representing the result of the asynchronous operation.</returns>
    public async Task<PdfFields> GetPreDocumentProperties(string documentId, string organizationId)
    {
      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = this.userDataService?.OrganizationId;
      }

      BlobContainerClient cloudBlobContainer =
        await this.CloudStorage.GetContainer(documentId, organizationId).ConfigureAwait(false);
      var blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentPdfFieldsMerged);
      var taggedTextBlob = cloudBlobContainer.GetBlobClient(DbConstants.TaggedPdf);
      PdfFields pdfFormFields = new PdfFields();
      pdfFormFields.HasPdfFormFields = false;
      pdfFormFields.IsTaggedPdf = false;
      if (await blob.ExistsAsync().ConfigureAwait(false))
      {
        pdfFormFields.HasPdfFormFields = true;
      }
      else
      {
        blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentPdfFields);
        if (await blob.ExistsAsync().ConfigureAwait(false))
        {
          pdfFormFields.HasPdfFormFields = true;
        }
      }

      if (await taggedTextBlob.ExistsAsync().ConfigureAwait(false))
      {
        pdfFormFields.IsTaggedPdf = true;
      }

      return pdfFormFields;
    }

    /// <summary>
    /// Download attachment documents from the Azure blob storage.
    /// </summary>
    /// <param name="documentId">document Id.</param>
    /// <returns>A <see cref="Task{TResult}"/> representing the result of the asynchronous operation.</returns>
    public async Task<IActionResult> DownloadAttachmentDocuments(string documentId)
    {
      DocumentDetails documentDetails =
        await this.documentContentService.GetDocumentDetails(documentId).ConfigureAwait(false);
      DocumentElementDetails documentElement = await this.documentContentService
        .GetDocumentElementDetails(documentId, documentDetails.OrganizationId).ConfigureAwait(false);
      PageFormElements[] pageFormElementsList = documentElement.PageFormElements;
      Zip.ZipArchive zipArchive = new Zip.ZipArchive
      {
        DefaultCompressionLevel = Syncfusion.Compression.CompressionLevel.Best,
      };
      var signerInfos = new List<Tuple<string, int, string, string>>();
      foreach (PageFormElements pageFormElements in pageFormElementsList)
      {
        var formElements = pageFormElements.FormElements.Where(a => a.ElementType == "attachment").ToList();
        foreach (var signer in documentDetails.SignerDetails)
        {
          pageFormElements.FormElements.Where(a => a.SignerId == signer.FieldRelationId).ToList().ForEach(x => { x.SignerName = signer.SignerName; });
        }

        foreach (FormElement formElement in formElements)
        {
          if (formElement.AttachmentDetails != null && formElement.AttachmentDetails.Length > 0)
          {
            foreach (AttachmentDetails attachmentDetails in formElement.AttachmentDetails)
            {
              MemoryStream stream = await this.documentAttachmentService
                .DownloadAttachment(documentId, attachmentDetails, documentDetails.OrganizationId)
                .ConfigureAwait(false);
              if (stream != null)
              {
                var name = formElement.SignerName.ToUpperInvariant();
                string folderName = formElement.SignerName;
                if (signerInfos.Any(x => x.Item1 == name))
                {
                  var orderedSignerInfo = signerInfos.OrderByDescending(x => x.Item2);
                  var signerInfo = orderedSignerInfo.FirstOrDefault(x => x.Item1 == name && x.Item3 == formElement.SignerId);
                  if (signerInfo != null)
                  {
                    folderName = signerInfo.Item4;
                  }
                  else
                  {
                    signerInfo = orderedSignerInfo.FirstOrDefault(x => x.Item1 == name);
                    folderName = formElement.SignerName + "[" + signerInfo.Item2 + "]";
                    signerInfos.Add(new Tuple<string, int, string, string>(name, signerInfo.Item2 + 1, formElement.SignerId, folderName));
                  }
                }
                else
                {
                  signerInfos.Add(new Tuple<string, int, string, string>(name, 1, formElement.SignerId, folderName));
                }

                int zipArchiveIndex = zipArchive.Find(folderName);
                if (zipArchiveIndex == -1)
                {
                  zipArchive.AddItem(folderName, null, false, Syncfusion.Compression.FileAttributes.Directory);
                }

                string attachmentDocumentName = SanitizedFileName.GetValidFileName(attachmentDetails.DocumentName);
                string pathAndFileName = folderName + "/" + attachmentDocumentName + "." + attachmentDetails.Extension;
                if (zipArchive.Find(pathAndFileName) != -1)
                {
                  pathAndFileName = folderName + "/" + attachmentDocumentName + " " + HelperMethods.GetUniqueID() + "." + attachmentDetails.Extension;
                }

                zipArchive.AddItem(pathAndFileName, stream, false, Syncfusion.Compression.FileAttributes.Normal);
              }
            }
          }
        }
      }

      if (zipArchive.Count > 0)
      {
        MemoryStream stream = new MemoryStream();
        zipArchive.Save(stream, false);
        stream.Position = 0;
        zipArchive.Close();
        var changeLogs = HelperMethods.AddSingleChangeLog(EventAction.DownloadedAttachment.ToString());
        _ = this.orgActivityService.Add(EventAction.Downloaded, EventCategory.Document, targetSource: documentDetails.MessageTitle, sourceId: documentId, changeLogs: changeLogs);
        var fileName = await this.downloadAuditTrailService.GetFileNameForDownload(documentDetails, documentDetails.MessageTitle).ConfigureAwait(false);

        return new FileStreamResult(stream, "application/zip")
        {
          FileDownloadName = $"{fileName}.zip",
        };
      }
      else
      {
        zipArchive.Close();
        return null;
      }
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadAttachmentApi(string documentId, string attachmentId)
    {
      var attachmentTitle = string.Empty;
      var contentType = string.Empty;
      var extension = string.Empty;
#pragma warning disable CA2000 // Dispose objects before losing scope
      MemoryStream stream = new MemoryStream();
#pragma warning restore CA2000 // Dispose objects before losing scope
      try
      {
        DocumentDetails documentDetails =
          await this.documentContentService.GetDocumentDetails(documentId).ConfigureAwait(false);
        DocumentElementDetails documentElement = await this.documentContentService
          .GetDocumentElementDetails(documentId, documentDetails.OrganizationId).ConfigureAwait(false);
        PageFormElements[] pageFormElementsList = documentElement.PageFormElements;
        foreach (PageFormElements pageFormElements in pageFormElementsList)
        {
          var formElement = pageFormElements.FormElements.FirstOrDefault(a => a.ElementType == "attachment" && (a.Id == attachmentId || (!string.IsNullOrEmpty(a.Name) && a.Name == attachmentId)) && a.AttachmentDetails != null && a.AttachmentDetails.Length > 0);
          if (formElement != null)
          {
            attachmentTitle = formElement.AttachmentDetails[0].DocumentName;
            contentType = formElement.AttachmentDetails[0].ContentType;
            extension = formElement.AttachmentDetails[0].Extension;
            stream = await this.documentAttachmentService
              .DownloadAttachment(documentId, formElement.AttachmentDetails[0], documentDetails.OrganizationId)
              .ConfigureAwait(false);
          }
        }

        return new FileStreamResult(stream, contentType)
        {
          FileDownloadName = GetFileNameForDownloadAttachment(attachmentTitle, extension),
        };
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, ex.Message);
        return null;
      }
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadDocumentByIdAsync(string documentId, bool isWaterMarkEnabled, CancellationToken token, string searchQuery = "", string searchQueryType = "", string countryCode = "", bool isSendRequestEvrotrust = false)
    {
      if (string.IsNullOrEmpty(documentId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      var documentDetails = GetDocumentDetailsCache(this.httpContext);
      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      var lastSignerDetail = documentDetails.SignerDetails.FirstOrDefault(x => x.EnableQualifiedElectronicSignature);
      var isPrintSignDocument = !isWaterMarkEnabled;
      isWaterMarkEnabled = (string.IsNullOrEmpty(searchQuery) || string.IsNullOrEmpty(searchQueryType)) && isWaterMarkEnabled;
      string containerId = documentDetails.IsTemplate && !string.IsNullOrEmpty(documentDetails.Id) ? documentDetails.Id : documentId;
      BlobContainerClient blobContainer = await this.CloudStorage
        .GetContainer(containerId, documentDetails.OrganizationId).ConfigureAwait(false);
      BlobClient documentBlob;

#pragma warning disable CA2000 // Dispose objects before losing scope
      var documentStream = new MemoryStream();
#pragma warning restore CA2000 // Dispose objects before losing scope

      if (documentDetails.SignerDetails.All(x => x.Status == SignerStatus.Completed) && documentDetails.Status == DocumentStatus.Completed)
      {
        if ((documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually) && !documentDetails.IsTemplate && !documentDetails.EnablePrintAndSign)
        {
          return await this.ProcessDocumentsAsZip(documentDetails, blobContainer, token).ConfigureAwait(false);
        }

        documentBlob = blobContainer.GetBlobClient(DbConstants.DocumentSigned);
        var isSignedDocumentExist = await documentBlob.ExistsAsync().ConfigureAwait(false);

        if (isSignedDocumentExist)
        {
          await this.CloudStorage.DownloadToStreamAsync(documentBlob, documentStream, true, token).ConfigureAwait(false);
          documentStream.Position = 0;
          var fileName = await this.downloadAuditTrailService.GetFileNameForDownload(documentDetails, $"{documentDetails.MessageTitle}_{documentDetails.Status}").ConfigureAwait(false);
          return new FileStreamResult(documentStream, Constants.PdfContentType)
          {
            FileDownloadName = $"{fileName}.pdf",
          };
        }
      }

      if (documentDetails.Status == DocumentStatus.InProgress && isWaterMarkEnabled)
      {
        BusinessProfileSettings businessProfileSettings = await this.businessProfileService.GetBusinessProfileDetailsAsync(Guid.Parse(documentDetails.OrganizationId)).ConfigureAwait(false);
        if (businessProfileSettings != null)
        {
          isWaterMarkEnabled = businessProfileSettings.EnableWaterMark;
        }
      }

      if ((documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually) && !documentDetails.IsTemplate && !documentDetails.EnablePrintAndSign)
      {
        // Add an empty signature to the document for individual documents. This is applicable when the signature needs to be inserted before receiving the actual signed data.
        if (lastSignerDetail is { EnableQualifiedElectronicSignature: true } && isSendRequestEvrotrust)
        {
          return await this.DownloadDocumentForEvroTrust(blobContainer, documentDetails, containerId, documentId, isWaterMarkEnabled, searchQueryType, searchQuery, countryCode).ConfigureAwait(false);
        }

        return await this.DownloadInprogressDocumentAsZip(blobContainer, documentDetails, containerId, documentId, isWaterMarkEnabled).ConfigureAwait(false);
      }

      documentBlob = blobContainer.GetBlobClient(DbConstants.DocumentMerged);
      if (!await documentBlob.ExistsAsync().ConfigureAwait(false))
      {
        documentBlob = blobContainer.GetBlobClient(DbConstants.Document);
      }

      List<Task> tasks = new List<Task>();
      tasks.Add(this.CloudStorage.DownloadToStreamAsync(documentBlob, documentStream, true));
      var documentElementDetailsTask =
        this.documentContentService.GetDocumentElementDetails(containerId, documentDetails.OrganizationId);

      tasks.Add(documentElementDetailsTask);
      await Task.WhenAll(tasks).ConfigureAwait(false);

      DocumentElementDetails documentElementDetails = documentElementDetailsTask.Result;
      PdfDocument.EnableCache = false;
      using var loadedDocument = new PdfLoadedDocument(documentStream);
      loadedDocument.EnableMemoryOptimization = true;

      // DrawDocumentFields is skipped since isEmptyDraft will not contain any PageFormElements
      if (documentDetails.Status != DocumentStatus.Draft && documentElementDetails != null && documentElementDetails.PageFormElements != null && !documentDetails.IsTemplate)
      {
        await this.DrawDocumentFields(documentElementDetails, loadedDocument, isPrintSignDocument: isPrintSignDocument).ConfigureAwait(false);
      }

      this.ApplyWatermarksAndDocumentId(loadedDocument, documentDetails, documentId, isWaterMarkEnabled);

      var downloadStream = new MemoryStream();
      loadedDocument.Save(downloadStream);
      downloadStream.Position = 0;

      // Add an empty signature to the document for combined document. This is applicable when the signature needs to be inserted before receiving the actual signed data.
      if (lastSignerDetail is { EnableQualifiedElectronicSignature: true } && isSendRequestEvrotrust)
      {
        return await this.AddEvroTrustSignatureAsync(downloadStream, searchQueryType, searchQuery, countryCode, documentId, documentDetails, false, documentId).ConfigureAwait(false);
      }

      var formattedFileName = await this.downloadAuditTrailService.GetFileNameForDownload(documentDetails, $"{documentDetails.MessageTitle}_{documentDetails.Status}").ConfigureAwait(false);
      return new FileStreamResult(downloadStream, Constants.PdfContentType)
      {
        FileDownloadName = $"{formattedFileName}.pdf",
      };
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadImportedDocumentByIdAsync(string documentId, CancellationToken token)
    {
      var orgId = this.userDataService.OrganizationId;

      if (string.IsNullOrEmpty(documentId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      BlobContainerClient blobContainer = await this.CloudStorage.GetContainer(documentId, orgId).ConfigureAwait(false);

      var importedDocument = await this.importDocumentsQueryService.GetImportDocumentDetailsByIdAsync(documentId, this.userDataService.OrganizationId).ConfigureAwait(false);
      var importedDocumentDetails = importedDocument.DocumentDetails.ToList();
      var documentGroups = importedDocumentDetails
        .GroupBy(x => x.ImportedEnvelopeDocumentType)
        .ToDictionary(g => g.Key, g => g.ToList());

      using var zipArchive = new Zip.ZipArchive();
      zipArchive.DefaultCompressionLevel = Syncfusion.Compression.CompressionLevel.Best;

      var documentNameCount = new Dictionary<string, int>();

      foreach (var group in documentGroups)
      {
        var (blobNames, documentNames) = this.GetImportedDocumentsBlobNames(group.Value);

        for (var i = 0; i < blobNames.Count; i++)
        {
          var blobName = blobNames[i];
          var documentName = documentNames[i];

          if (documentNameCount.ContainsKey(documentName))
          {
            documentNameCount[documentName]++;
            documentName += documentNameCount[documentName].ToString(); // Append alias
          }
          else
          {
            documentNameCount[documentName] = 1;
          }

          var byteArray = await this.DownloadAndProcessStreamAsync(blobContainer, blobName, token).ConfigureAwait(false);
          zipArchive.AddItem($"{documentName}.pdf", new MemoryStream(byteArray), false, Syncfusion.Compression.FileAttributes.Normal);
        }
      }

      return this.CreateZipResultForImportedDocuments(zipArchive, documentId);
    }

    /// <inheritdoc/>
    public async Task UpdateDownloadTypeAsync(string documentId)
    {
      if (string.IsNullOrEmpty(documentId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      var documentDetails = GetDocumentDetailsCache(this.httpContext)
                            ?? await this.extendedDocumentDetailsService.GetDocumentDetailsAsync(documentId)
                              .ConfigureAwait(false);
      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      if (documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually)
      {
        throw new InvalidOperationException("Individual document downloads are already enabled.");
      }

      documentDetails.EnableIndividualDocumentDownloads = true;
      documentDetails.DocumentDownloadOption = DocumentDownloadOption.Individually;
      if (documentDetails.Status == DocumentStatus.Completed)
      {
        this.httpContext?.Items.TryAdd(DocumentDetailsReader.DocumentDetailsData, documentDetails);
        await this.SignAndTimestampPdfAsync(documentId).ConfigureAwait(false);
      }
      else
      {
        await this.UpdateDocumentDetailsAsync(documentDetails).ConfigureAwait(false);
      }
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadBulkSendDocumentsAsync(string bulkSendId, CancellationToken token)
    {
      try
      {
        this.ValidateBulkSendId(bulkSendId);
        var bulkSendDetails = GetBulkSendDetailsCache(this.httpContext) ?? throw new InvalidDataException(CommonResource.BulkSendDetailsMissing);
        var bulkSendDocumentsDetails = GetBulkSendDocumentDetailsCache(this.httpContext) ?? throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
        var completedDocumentsDetails = bulkSendDocumentsDetails.Where(x => x.Status == DocumentStatus.Completed).ToList();
        var fileId = Guid.NewGuid().ToString();

        var defaultDocumentDetails = await this.documentContentService.GetDocumentDetails(completedDocumentsDetails[0].DocumentId).ConfigureAwait(false);

        if (this.IsFileSizeWithinLimit(defaultDocumentDetails, completedDocumentsDetails))
        {
          return await this.GenerateAndReturnZipFileAsync(fileId, bulkSendId, bulkSendDetails.Title, completedDocumentsDetails, defaultDocumentDetails, this.GetBulkSendDownloadedZipPathAsync, token).ConfigureAwait(false);
        }

        var queryable = this.documentRepositoryService.GetQueryable<BulkDownloadDetails>(DbConstants.BulkDownloadDetails);
        var bulkDownloadDetails = await queryable.Where(x => x.BulkSendId == bulkSendId && x.CompletedDocumentIds != null && x.CompletedDocumentIds.Any()).ToListItemsAsync().ConfigureAwait(false);
        var completedDocumentIds = completedDocumentsDetails.Select(x => x.DocumentId).ToList();
        var downloadedBulk = bulkDownloadDetails?.FirstOrDefault(x => Enumerable.SequenceEqual(completedDocumentIds, x.CompletedDocumentIds));
        await this.orgActivityService.Add(EventAction.Downloaded, EventCategory.Document, targetSource: bulkSendDetails.Title, sourceId: bulkSendId).ConfigureAwait(false);
        if (downloadedBulk != null)
        {
          var result = await this.ProcessDownloadedBulkAsync(bulkSendId, downloadedBulk.FileId, bulkSendDetails.Title, downloadedBulk.BulkSendId, defaultDocumentDetails, downloadedBulk, this.SendEmailForBulkSendDownloadAsync).ConfigureAwait(false);
          if (result != null)
          {
            return result;
          }
        }

        _ = this.DownloadLargeSizeBulkSendDocumentsAsync(bulkSendId, fileId, bulkSendDetails, completedDocumentsDetails, defaultDocumentDetails, token).ConfigureAwait(false);
        return new OkObjectResult(new { message = CommonResource.BulkSendDocumentDownload, currentDate = DateTime.Now });
      }
      catch (Exception ex)
      {
        this.LogErrorAndThrow(ex);
        throw;
      }
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadBulkSendDocumentsFromLinkAsync(string bulkSendId, string fileId, AuthorizationResult authorizationResult, string organizationId, CancellationToken token)
    {
      var bulkSendDownloadDetails = GetBulkSendDownloadDetailsCache(this.httpContext);
      if (!authorizationResult.Succeeded)
      {
        return new JsonResult(new { status = CommonResource.BulkDownloadUriStatus, Message = CommonResource.BulkDownloadUriExpired, expirationDate = bulkSendDownloadDetails.ExpiryDate });
      }

      string downloadUrl = await this
        .GetDocumentDownloadUrl(bulkSendId, fileId, bulkSendDownloadDetails.Title, organizationId)
        .ConfigureAwait(false);
      return new RedirectResult(downloadUrl, false);
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadBulkLinkDocumentsAsync(string bulkLinkId, CancellationToken token)
    {
      try
      {
        this.ValidateBulkLinkId(bulkLinkId);
        var documentDetails = GetDocumentDetailsCache(this.httpContext) ?? throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
        var completedLinkSignerDetails = GetCompletedLinkSignerDetailsCache(this.httpContext) ?? throw new InvalidDataException(CommonResource.SignerDetailsMissing);
        var fileId = Guid.NewGuid().ToString();

        if (this.IsFileSizeWithinLimit(documentDetails, completedLinkSignerDetails))
        {
          _ = this.LogDownloadBulkLinkActivity(documentDetails, bulkLinkId).ConfigureAwait(false);
          return await this.GenerateAndReturnZipFileAsync(fileId, bulkLinkId, SanitizedFileName.GetValidFileName(documentDetails.FormTitle), completedLinkSignerDetails, documentDetails, this.GetDownloadedZipPathAsync, token).ConfigureAwait(false);
        }

        var isDuplicateRequest = await this.UpdateBulkDownloadStatusAsync(bulkLinkId, fileId).ConfigureAwait(false);
        if (isDuplicateRequest)
        {
          return new OkObjectResult(new { message = CommonResource.DuplicateBulkDownloadRequest, currentDate = DateTime.Now });
        }

        var queryable = this.documentRepositoryService.GetQueryable<BulkDownloadDetails>(DbConstants.BulkDownloadDetails);
        var downloadedBulkDetails = await queryable.Where(x => x.BulkLinkId == bulkLinkId && x.CompletedDocumentIds != null && x.CompletedDocumentIds.Any()).ToListItemsAsync().ConfigureAwait(false);
        var completedDocumentIds = completedLinkSignerDetails.Select(x => x.DocumentId).ToList();
        var downloadedBulk = downloadedBulkDetails?.FirstOrDefault(x => Enumerable.SequenceEqual(completedDocumentIds, x.CompletedDocumentIds));
        _ = this.LogDownloadBulkLinkActivity(documentDetails, bulkLinkId).ConfigureAwait(false);
        if (downloadedBulk != null)
        {
          var result = await this.ProcessDownloadedBulkAsync(bulkLinkId, downloadedBulk.FileId, SanitizedFileName.GetValidFileName(documentDetails.FormTitle), downloadedBulk.BulkLinkId, documentDetails, downloadedBulk, this.SendEmailForBulkLinkDownloadAsync, isBulkLinkDownload: true).ConfigureAwait(false);
          if (result != null)
          {
            return result;
          }
        }

        _ = this.DownloadLargeSizeBulkDocumentAsync(bulkLinkId, fileId, documentDetails, completedLinkSignerDetails, token).ConfigureAwait(false);
        return new OkObjectResult(new { message = CommonResource.BulkDocumentDownload, currentDate = DateTime.Now });
      }
      catch (Exception ex)
      {
        this.LogErrorAndThrow(ex);
        _ = this.DeleteBulkDownloadStatusAsync(bulkLinkId).ConfigureAwait(false);
        throw;
      }
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadCSVFileAsync(string bulkLinkId, string fileId, AuthorizationResult authorizationResult, CancellationToken token)
    {
      var (isAuthorized, documentDetails) = this.CheckAuthorizationAndGetDetails<DocumentDetails>(authorizationResult, GetDocumentDetailsCache);
      if (!isAuthorized)
      {
        var bulkDocumentDetails = GetBulkDownloadDetailscache(this.httpContext);
        return new JsonResult(new { status = CommonResource.BulkDownloadUriStatus, Message = CommonResource.BulkDownloadUriExpired, expirationDate = bulkDocumentDetails.ExpiryDate });
      }

      string downloadUrl = await this
        .GetDownloadUrl(bulkLinkId, fileId, documentDetails.FormTitle, documentDetails.OrganizationId)
        .ConfigureAwait(false);
      return new RedirectResult(downloadUrl, false);
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadBulkSendCSVFileAsync(string bulksendId, string fileId, AuthorizationResult authorizationResult, string organizationId, CancellationToken token)
    {
      var (isAuthorized, bulkDownloadDetails) = this.CheckAuthorizationAndGetDetails<BulkDownloadDetails>(authorizationResult, GetBulkSendDownloadDetailsCache);
      if (!isAuthorized)
      {
        return new JsonResult(new { status = CommonResource.BulkDownloadUriStatus, Message = CommonResource.BulkDownloadUriExpired, expirationDate = bulkDownloadDetails.ExpiryDate });
      }

      string downloadUrl = await this.GetDownloadUrl(bulksendId, fileId, bulkDownloadDetails.Title, organizationId)
        .ConfigureAwait(false);
      return new RedirectResult(downloadUrl, false);
    }

    /// <inheritdoc/>
    public async Task<IActionResult> DownloadCompletedBulkFiles(string bulkLinkId, string fileId, AuthorizationResult authorizationResult, string organizationId, CancellationToken token)
    {
      if (!authorizationResult.Succeeded)
      {
        var bulkDocumentDetails = GetBulkDownloadDetailscache(this.httpContext);
        return new JsonResult(new { status = CommonResource.BulkDownloadUriStatus, Message = CommonResource.BulkDownloadUriExpired, expirationDate = bulkDocumentDetails.ExpiryDate });
      }

      var documentDetails = GetDocumentDetailsCache(this.httpContext);
      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      string downloadUrl = await this.GetDocumentDownloadUrl(bulkLinkId, fileId, SanitizedFileName.GetValidFileName(documentDetails.FormTitle), organizationId)
        .ConfigureAwait(false);
      return new RedirectResult(downloadUrl, false);
    }

    /// <inheritdoc/>
    public async Task<string> SignAndTimestampPdfAsync(string documentId)
    {
      var documentDetails = GetDocumentDetailsCache(this.httpContext)
        ?? await this.extendedDocumentDetailsService.GetDocumentDetailsAsync(documentId)
          .ConfigureAwait(false);

      this.httpContext.Items[DocumentDetailsReader.DocumentDetailsData] ??= documentDetails;

      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      BlobContainerClient blobContainer = await this.CloudStorage
        .GetContainer(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);
      if (!await blobContainer.ExistsAsync().ConfigureAwait(false))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      var isQualifiedElectronicSign = documentDetails.SignerDetails.Any(x => x.EnableQualifiedElectronicSignature);
      DocumentElementDetails documentFormFields = await this.documentContentService
        .GetDocumentElementDetails(documentId, documentDetails.OrganizationId).ConfigureAwait(false);

      // If all the signers present in the document is reviewers the form element count can be zero.
      if (documentFormFields == null || (documentDetails.SignerDetails.All(x => x.SignerType != SignerType.Reviewer) && !documentFormFields.PageFormElements.Any()))
      {
        throw new InvalidOperationException(CommonResource.NoFieldsToSign);
      }

      byte[] signedPdfBytes = null;
      var individualSignedDocumentHashes = new ConcurrentBag<DocumentHashDetails>();
      var accessRightsDetails = this.accessRightsDetailsService.InitializeAccessRightsDetail(documentDetails, documentDetails.OrganizationId);

      if ((documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually) && !documentDetails.EnablePrintAndSign)
      {
        await this.UploadSignedDocumentSeparately(documentDetails, blobContainer, documentFormFields, individualSignedDocumentHashes, isQualifiedElectronicSign).ConfigureAwait(false);
        isQualifiedElectronicSign = false;
      }

      var blob = blobContainer.GetBlobClient(DbConstants.DocumentMerged);

      if (!await blob.ExistsAsync().ConfigureAwait(false))
      {
        blob = blobContainer.GetBlobClient(DbConstants.Document);
      }

      using var documentStream = new MemoryStream();
      var signedEvroTrustObject = documentDetails.SignerDetails.Where(x => x.EnableQualifiedElectronicSignature).SelectMany(x => x.EvroTrustResponse).FirstOrDefault(x => x.TransactionID != null && x.Status == EvroTrustStatus.Signed);
      if (isQualifiedElectronicSign && signedEvroTrustObject?.TransactionID != null)
      {
        var evroTrustBlob = blobContainer.GetBlobClient(EvrotrustDocument);
        if (await evroTrustBlob.ExistsAsync().ConfigureAwait(false))
        {
          blob = evroTrustBlob;
        }

        await this.CloudStorage.DownloadToStreamAsync(blob, documentStream, true, CancellationToken.None).ConfigureAwait(false);
        documentStream.Position = 0;
        signedPdfBytes = await this.downloadAuditTrailService.SignAndUploadDocument(blobContainer, documentStream, documentId, documentDetails.OrganizationId, isQualifiedElectronicSign: isQualifiedElectronicSign).ConfigureAwait(false);
      }
      else
      {
        await this.CloudStorage.DownloadToStreamAsync(blob, documentStream, true, CancellationToken.None).ConfigureAwait(false);
        using (var loadedDocument = new PdfLoadedDocument(documentStream))
        {
          await this.DrawDocumentFields(documentFormFields, loadedDocument).ConfigureAwait(false);

          using (MemoryStream manipulatedDocumentStream = new MemoryStream())
          {
            this.ApplyWatermarksAndDocumentId(loadedDocument, documentDetails, documentId, false, true);
            loadedDocument.Save(manipulatedDocumentStream);

            // if combine AuditTrail is true merges the completed document and audit log.
            if (documentDetails.CombineAuditTrail && !isQualifiedElectronicSign)
            {
              manipulatedDocumentStream.Position = 0;

              FileContentResult fileContentResult = (FileContentResult)await this.downloadAuditTrailService.DownloadAuditTrail(documentId, CancellationToken.None).ConfigureAwait(false);

              using MemoryStream auditStream = new MemoryStream(fileContentResult.FileContents);
              auditStream.Position = 0;

              using PdfDocument finalDoc = new PdfDocument();
              Stream[] streams = { manipulatedDocumentStream, auditStream };

              // Merges PDFDocument.
              PdfDocumentBase.Merge(finalDoc, streams);

              using MemoryStream stream = new MemoryStream();
              finalDoc.Save(stream);
              stream.Position = 0;

              signedPdfBytes = await this.downloadAuditTrailService.SignAndUploadDocument(blobContainer, stream, documentId, documentDetails.OrganizationId, isQualifiedElectronicSign: isQualifiedElectronicSign).ConfigureAwait(false);
              streams.ToList().ForEach(x => x.DisposeAsync());
            }
            else
            {
              signedPdfBytes = await this.downloadAuditTrailService.SignAndUploadDocument(blobContainer, manipulatedDocumentStream, documentId, documentDetails.OrganizationId, isQualifiedElectronicSign: isQualifiedElectronicSign).ConfigureAwait(false);
            }
          }
        }
      }

      var lastSignedSignerId = this.UpdateOldSignerIdDetails(documentDetails);
      await this.UpdateSignedHash(documentDetails, accessRightsDetails, signedPdfBytes, individualSignedDocumentHashes).ConfigureAwait(false);
      FileStreamResult auditFileContent = null;

      var sanitizedFileName = SanitizedFileName.GetValidFileName(documentDetails.MessageTitle);
      var downloadFileName = sanitizedFileName + "_" + documentDetails.Status.ToString();
      var auditFileName = $"{sanitizedFileName}_AuditTrail.pdf";

      // to preload the audit trail document
      if (!documentDetails.CombineAuditTrail)
      {
        auditFileContent = (FileStreamResult)await this.downloadAuditTrailService.DownloadAuditTrail(documentId, CancellationToken.None).ConfigureAwait(false);
      }

      if ((documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually) && !documentDetails.EnablePrintAndSign)
      {
        auditFileContent = (FileStreamResult)await this.downloadAuditTrailService.DownloadAuditTrail(documentId, CancellationToken.None, true).ConfigureAwait(false);
        auditFileName = "AuditTrail.pdf";
      }

      if (!string.IsNullOrEmpty(documentDetails.DownloadFileName))
      {
        downloadFileName = await this.downloadAuditTrailService.GetFileNameForDownload(documentDetails, documentDetails.MessageTitle).ConfigureAwait(false);
        auditFileName = $"{downloadFileName}_AuditTrail.pdf";
      }

      await this.SignAndSendEmail(documentDetails, this.requestDetailsService.HostedDomain, $"{downloadFileName}.pdf", auditFileName).ConfigureAwait(false);

      await this.webHookService.TriggerWebHook(
        new CompletedWebHookEvent()
        {
          DocumentId = documentId,
          EventType = WebHookEventType.Completed,
        },
        documentDetails).ConfigureAwait(false);

      // Log Document Completed Event to Post Hog.
      await this.postHogEventService.QueuePostHogEventAsync(
        ApiEventConstants.DocumentCompleted,
        documentDetails.SenderAccessUid,
        documentDetails.ApplicationEnvironment,
        documentDetails.SenderEmail).ConfigureAwait(false);

      // Upload the signed document to the cloud storage.
      await this.cloudUploadService.CloudBackupProcess(documentDetails, documentFormFields, signedPdfBytes, individualSignedDocumentHashes, auditFileContent).ConfigureAwait(false);

      return lastSignedSignerId;
    }

    /// <summary>
    /// Sign And Send Email.
    /// </summary>
    /// <param name="docDetails">The docContent.</param>
    /// <param name="hostedDomain">The hostedDomain.</param>
    /// <param name="documentName">The documentName.</param>
    /// <param name="auditDocumentName">The auditDocumentName.</param>
    /// <returns>A <see cref="Task"/> representing the result of the asynchronous operation.</returns>
    public async Task SignAndSendEmail(DocumentDetails docDetails, string hostedDomain, string documentName, string auditDocumentName)
    {
      if (docDetails is null)
      {
        throw new ArgumentNullException(nameof(docDetails));
      }

      if (!this.turnOffEmail)
      {
        List<string> hostEmails = new List<string>();
        List<RecipientDetails> participants = new List<RecipientDetails>();
        BoldSign.Base.Models.SignerDetails currentSigner = null;

        if (docDetails.IsSelfSign)
        {
          var signerDetail = docDetails.SignerDetails[0];
          string url = string.Join(string.Empty, hostedDomain + "/document/view/?documentId=" + docDetails.Id + signerDetail.UnhashedSignerId + ";" + docDetails.OrganizationId);
          if (docDetails.OnBehalfOfDetails == null)
          {
            participants.Add(HelperMethods.AddSenderToRecipientDetails(docDetails, url, RecipientType.Signer, signerDetail.SelectedLanguage));
          }

          foreach (var ccDetail in docDetails.CCDetails)
          {
            url = string.Join(string.Empty, hostedDomain + "/document/view/?documentId=" + docDetails.Id + ccDetail.UnhashedSignerId + ";" + docDetails.OrganizationId);
            participants.Add(HelperMethods.AddCCToRecipientDetails(ccDetail, docDetails, documentLink: url));
          }

          BuildQueueDetails emailSettings = new BuildQueueDetails
          {
            DocumentDetails = docDetails,
            Participants = participants,
            CompletedDocumentName = documentName,
            AuditDocumentName = auditDocumentName,
          };
          MessageDetails messageDetails = HelperMethods.GetMessageDetails(MethodName.CompleteSelfSign, emailSettings);
          _ = this.emailHandler.SendEmail(messageDetails, docDetails.OrganizationId).ConfigureAwait(false);

          if (signerDetail.DeliveryMode == DeliveryMode.EmailAndSMS)
          {
            this.SendSmsForSingleSignerCompletion(docDetails, signerDetail, hostedDomain);
          }
        }
        else
        {
          string url = string.Join(string.Empty, hostedDomain + "/document/view/?documentId=" + docDetails.Id);
          var signerDetails = docDetails.SignerDetails.ToList();

          participants = HelperMethods.GetParticipantsList(docDetails, signerDetails, docLink: url, isInPersonAllowed: true, isSenderAllowed: string.IsNullOrEmpty(docDetails.BulkSendDocumentId));

          // Current Signer Detail
          if (docDetails.SignerDetails.Length == 1)
          {
            BoldSign.Base.Models.SignerDetails signerDetail = docDetails.SignerDetails[0];

            if (signerDetail.SignType == SigningType.Group)
            {
              currentSigner = signerDetail.GroupSignerDetails.FirstOrDefault(a => a.Status == SignerStatus.Completed);
            }
            else
            {
              currentSigner = signerDetail;
            }

            this.SendSmsForSingleSignerCompletion(docDetails, signerDetail, hostedDomain);
            this.SendWhatsAppForSingleSignerCompletion(docDetails, signerDetail, hostedDomain);
          }

          BuildQueueDetails emailSettings = new BuildQueueDetails
          {
            DocumentDetails = docDetails,
            Participants = participants,
            CurrentSignerDetail = currentSigner,
            CompletedDocumentName = documentName,
            AuditDocumentName = auditDocumentName,
          };
          MethodName methodname = MethodName.CompleteSingleSign;
          string groupName = string.Empty;

          if (docDetails.SignerDetails.Length > 1)
          {
            methodname = MethodName.CompleteAllSign;
          }
          else if (docDetails.SignerDetails.Length == 1 && docDetails.SignerDetails.Any(x => x.SignType == SigningType.Group))
          {
            var group = docDetails.SignerDetails.FirstOrDefault(x => x.Status == SignerStatus.Completed);
            groupName = group.SignerName;
            emailSettings.CurrentSignerDetail = group.GroupSignerDetails?.FirstOrDefault(x => x.Status == SignerStatus.Completed);
          }

          MessageDetails messageDetails = HelperMethods.GetMessageDetails(methodname, emailSettings, groupName);
          if (!docDetails.EnableEmbeddedSigning)
          {
            await this.emailHandler.SendEmail(messageDetails, docDetails.OrganizationId).ConfigureAwait(false);
          }

          this.SendSMSForAllSignerCompleted(docDetails, signerDetails, hostedDomain);
          this.SendWhatsAppForAllSignerCompleted(docDetails, signerDetails, hostedDomain);
        }
      }
    }

    /// <inheritdoc/>
    public async Task<string> CloneDocumentAsync<T>(string documentId, ResponseWriter<T> responseWriter, bool includeFieldData)
    {
      if (string.IsNullOrEmpty(documentId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      if (responseWriter is null)
      {
        throw new ArgumentNullException(nameof(responseWriter));
      }

      DocumentDetails documentDetails = GetDocumentDetailsCache(this.httpContext);
      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      var documentElementDetails = await this.documentContentService
        .GetDocumentElementDetails(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);
      await responseWriter.WriteAsync("Copying fields;").ConfigureAwait(false);

      var clonedId = Guid.NewGuid().ToString();

      // Get the document blob storage for the provided document id.
      BlobContainerClient sourceBlobContainer =
        await this.CloudStorage.GetContainer(documentId, documentDetails.OrganizationId).ConfigureAwait(false);

      // Get the thumbnails blob storage for the provided document id.
      BlobContainerClient sourceThumbNailContainer = await this.CloudStorage
        .GetContainer($"{documentId}-{DbConstants.Thumbnails}", documentDetails.OrganizationId).ConfigureAwait(false);

      BlobContainerClient cloneBlobContainer = await this.CloudStorage
        .CreateContainer(clonedId, documentDetails.OrganizationId).ConfigureAwait(false);
      BlobContainerClient thumbnailCloudBlobContainer = await this.CloudStorage
        .CreateContainer($"{clonedId}-{DbConstants.Thumbnails}", documentDetails.OrganizationId).ConfigureAwait(false);

      AuthorizationDetails authorizationDetails = null;

      // Resetting the document details
      documentDetails.Id = clonedId;
      documentElementDetails.Id = clonedId;
      documentDetails.CreatedDate = DateTime.Now;
      documentDetails.RevokeMessage = string.Empty;
      documentDetails.Status = DocumentStatus.Draft;
      documentDetails.HasAttachment = false;
      documentDetails.ApplicationEnvironment = null;
      documentDetails.BulkSendDocumentId = documentDetails.BulkSendDocumentId;
      documentDetails.IsBulkSend = documentDetails.IsBulkSend;
      documentDetails.BulkSendTitle = string.Empty;
      documentDetails.DownloadFileName = string.Empty;

      async Task UpdateSignerDetails(BoldSign.Base.Models.SignerDetails signer)
      {
        if (signer.IsAuthenticationFailed != null)
        {
          if (authorizationDetails == null)
          {
            authorizationDetails = await this.GetAuthorizationDetails(documentId).ConfigureAwait(false);
          }

          signer.IsAuthenticationFailed = false;
        }

        signer.CompletedDate = null;
        signer.Status = SignerStatus.NotCompleted;
        signer.DeclineMessage = string.Empty;
        signer.ReassignReason = string.Empty;
        signer.LinkId = string.Empty;
        if (signer.SignerEmail != null && signer.IsAuthenticationFailed != null && authorizationDetails != null && authorizationDetails.AuthorizedSigners.Any())
        {
          var authorizedSigner = authorizationDetails.AuthorizedSigners.FirstOrDefault(x => x.SignerEmail.IsEqual(signer.SignerEmail) && x.ZOrder == signer.ZOrder);

          // We should not set AuthenticationCode for the email OTP document, since it is generated on demand while signing.
          if (authorizedSigner != null && !authorizedSigner.EnableEmailOTP && !authorizedSigner.EnableSMSOTP)
          {
            signer.AuthenticationCode = authorizedSigner.AuthenticationCode;
          }
        }

        signer.SignerId = signer.FieldRelationId;
      }

      if (documentDetails.SignerDetails.Any())
      {
        var combinedSigner = this.GetAllSignersToClone(documentDetails.SignerDetails);

        await combinedSigner.ParallelForEachAsync(
          async signer =>
          {
            await UpdateSignerDetails(signer).ConfigureAwait(false);
          }, maxDegreeOfParallelism: 10).ConfigureAwait(false);
      }

      if (documentDetails.DocumentProperties.Any())
      {
        foreach (var property in documentDetails.DocumentProperties)
        {
          if (string.IsNullOrEmpty(property.ParentId))
          {
            property.DocumentId = clonedId;
          }
          else
          {
            property.ParentId = clonedId;
          }
        }
      }

      await responseWriter.WriteAsync("Copying documents;").ConfigureAwait(false);

      await Task.WhenAll(new List<Task>()
      {
        this.CloneAccessRightDetails(documentId, clonedId, documentDetails.IsTemplate),
        this.CloneDocumentsContainerAsync(sourceBlobContainer, cloneBlobContainer, documentDetails, documentElementDetails, includeFieldData),
        this.CloneThumbnailContainerAsync(sourceThumbNailContainer, thumbnailCloudBlobContainer, 0, string.Empty, null),
      }).ConfigureAwait(false);

      var documentOrder = documentDetails.DocumentProperties?.OrderBy(x => x.Order);
      bool canDrawDocId = documentDetails.EnableDocumentID;
      await this.ManipulateAndCloneDocuments(documentOrder, cloneBlobContainer, canDrawDocId, documentDetails.OrganizationId).ConfigureAwait(false);

      if (!string.IsNullOrEmpty(clonedId))
      {
        await this.AddDocumentCloneActivity(documentId, includeFieldData).ConfigureAwait(false);
      }

      return clonedId;
    }

    /// <inheritdoc/>
    public async Task<string> CloneTemplateAsync<T>(string documentId, ResponseWriter<T> responseWriter, bool includeFieldData)
    {
      if (string.IsNullOrEmpty(documentId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      if (responseWriter is null)
      {
        throw new ArgumentNullException(nameof(responseWriter));
      }

      DocumentDetails documentDetails = GetDocumentDetailsCache(this.httpContext);

      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      if (!string.IsNullOrEmpty(documentDetails.ModifiedTemplateId))
      {
        documentDetails = await this.documentContentService.GetDocumentDetails(documentDetails.ModifiedTemplateId).ConfigureAwait(false);
      }

      var documentElementDetails = await this.documentContentService
        .GetDocumentElementDetails(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);
      await responseWriter.WriteAsync("Copying fields;").ConfigureAwait(false);

      var clonedId = Guid.NewGuid().ToString();

      // Get the document blob storage for the provided document id.
      BlobContainerClient sourceBlobContainer = await this.CloudStorage
        .GetContainer(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);

      // Get the thumbnails blob storage for the provided document id.
      BlobContainerClient sourceThumbNailContainer = await this.CloudStorage
        .GetContainer($"{documentDetails.Id}-{DbConstants.Thumbnails}", documentDetails.OrganizationId)
        .ConfigureAwait(false);

      BlobContainerClient cloneBlobContainer = await this.CloudStorage
        .CreateContainer(clonedId, documentDetails.OrganizationId).ConfigureAwait(false);
      BlobContainerClient thumbnailCloudBlobContainer = await this.CloudStorage
        .CreateContainer($"{clonedId}-{DbConstants.Thumbnails}", documentDetails.OrganizationId).ConfigureAwait(false);

      AuthorizationDetails authorizationDetails = null;

      // Resetting the document details
      documentDetails.Id = clonedId;
      documentElementDetails.Id = clonedId;
      documentDetails.CreatedDate = DateTime.Now;
      documentDetails.RevokeMessage = string.Empty;
      documentDetails.Status = DocumentStatus.Draft;
      documentDetails.ActivityDate = DateTime.Now;
      documentDetails.CreatedBy = this.userDataService.Id;
      documentDetails.SenderEmail = this.userDataService.Email;
      documentDetails.SentBy = this.userDataService.Name;

      async Task UpdateSignerDetails(BoldSign.Base.Models.SignerDetails signer)
      {
        if (signer.IsAuthenticationFailed != null)
        {
          if (authorizationDetails == null)
          {
            authorizationDetails = await this.GetAuthorizationDetails(documentId).ConfigureAwait(false);
          }

          signer.IsAuthenticationFailed = false;
        }

        signer.CompletedDate = null;
        signer.Status = SignerStatus.NotCompleted;
        signer.DeclineMessage = string.Empty;
        signer.ReassignReason = string.Empty;
        if (signer.SignerEmail != null && signer.IsAuthenticationFailed != null && authorizationDetails != null && authorizationDetails.AuthorizedSigners.Any())
        {
          var authorizedSigner = authorizationDetails.AuthorizedSigners.FirstOrDefault(x => x.SignerEmail.IsEqual(signer.SignerEmail) && x.ZOrder == signer.ZOrder);

          // We should not set AuthenticationCode for the email OTP document, since it is generated on demand while signing.
          if (authorizedSigner != null && !authorizedSigner.EnableEmailOTP && !authorizedSigner.EnableSMSOTP)
          {
            signer.AuthenticationCode = authorizedSigner.AuthenticationCode;
          }
        }

        signer.SignerId = signer.SignerId;
      }

      if (documentDetails.SignerDetails.Any())
      {
        var combinedSigner = this.GetAllSignersToClone(documentDetails.SignerDetails);

        await combinedSigner.ParallelForEachAsync(
          async signer =>
          {
            await UpdateSignerDetails(signer).ConfigureAwait(false);
          }, maxDegreeOfParallelism: 10).ConfigureAwait(false);
      }

      if (documentDetails.DocumentProperties.Any())
      {
        foreach (var property in documentDetails.DocumentProperties)
        {
          if (string.IsNullOrEmpty(property.ParentId))
          {
            property.DocumentId = clonedId;
          }
          else
          {
            property.ParentId = clonedId;
          }
        }
      }

      await responseWriter.WriteAsync("Copying documents;").ConfigureAwait(false);

      await Task.WhenAll(new List<Task>()
      {
        this.CloneAccessRightDetails(documentId, clonedId, documentDetails.IsTemplate),
        this.CloneDocumentsContainerAsync(sourceBlobContainer, cloneBlobContainer, documentDetails, documentElementDetails, includeFieldData),
        this.CloneThumbnailContainerAsync(sourceThumbNailContainer, thumbnailCloudBlobContainer, 0, string.Empty, null),
      }).ConfigureAwait(false);

      var documentOrder = documentDetails.DocumentProperties?.OrderBy(x => x.Order);
      bool canDrawDocId = documentDetails.EnableDocumentID;
      await this.ManipulateAndCloneDocuments(documentOrder, cloneBlobContainer, canDrawDocId, documentDetails.OrganizationId).ConfigureAwait(false);

      return clonedId;
    }

    /// <inheritdoc/>
    public async Task<string> CloneBulkLinkAsync<T>(string documentId, ResponseWriter<T> responseWriter)
    {
      if (string.IsNullOrEmpty(documentId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      if (responseWriter is null)
      {
        throw new ArgumentNullException(nameof(responseWriter));
      }

      DocumentDetails documentDetails = GetDocumentDetailsCache(this.httpContext);

      if (documentDetails == null)
      {
        documentDetails = await this.documentContentService.GetDocumentDetails(documentId).ConfigureAwait(false);

        if (!string.IsNullOrEmpty(documentDetails?.ModifiedFormId))
        {
          documentDetails = await this.documentContentService.GetDocumentDetails(documentDetails.ModifiedFormId).ConfigureAwait(false);
        }
      }

      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      var documentElementDetails = await this.documentContentService
        .GetDocumentElementDetails(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);
      await responseWriter.WriteAsync("Copying fields;").ConfigureAwait(false);

      var clonedId = Guid.NewGuid().ToString();

      // Get the document blob storage for the provided document id.
      BlobContainerClient sourceBlobContainer = await this.CloudStorage
        .GetContainer(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);

      // Get the thumbnails blob storage for the provided document id.
      BlobContainerClient sourceThumbNailContainer = await this.CloudStorage
        .GetContainer($"{documentDetails.Id}-{DbConstants.Thumbnails}", documentDetails.OrganizationId)
        .ConfigureAwait(false);

      BlobContainerClient cloneBlobContainer = await this.CloudStorage
        .CreateContainer(clonedId, documentDetails.OrganizationId).ConfigureAwait(false);
      BlobContainerClient thumbnailCloudBlobContainer = await this.CloudStorage
        .CreateContainer($"{clonedId}-{DbConstants.Thumbnails}", documentDetails.OrganizationId).ConfigureAwait(false);

      documentDetails.Id = clonedId;
      documentElementDetails.Id = clonedId;
      documentDetails.CreatedDate = DateTime.Now;
      documentDetails.Status = DocumentStatus.Draft;
      documentDetails.DownloadFileName = string.Empty;

      foreach (var signer in documentDetails.SignerDetails)
      {
        var signerId = signer.SignerId;
        signer.SignerId = "s_" + HelperMethods.GetUniqueID();
        foreach (var pageFormElements in documentElementDetails.PageFormElements)
        {
          foreach (var formElements in pageFormElements.FormElements)
          {
            if (signerId == formElements.SignerId)
            {
              formElements.SignerId = signer.SignerId;
            }
          }
        }
      }

      if (documentDetails.DocumentProperties.Any())
      {
        foreach (var property in documentDetails.DocumentProperties)
        {
          if (string.IsNullOrEmpty(property.ParentId))
          {
            property.DocumentId = clonedId;
          }
          else
          {
            property.ParentId = clonedId;
          }
        }
      }

      await responseWriter.WriteAsync("Copying documents;").ConfigureAwait(false);

      LinkDetails linkDetails = (LinkDetails)this.httpContext.Items[LinkFormDetailsReader.LinkDetailsConst];
      if (linkDetails == null)
      {
        linkDetails = await this.documentRepositoryService.ReadDocumentAsync<LinkDetails>(
          DbConstants.LinkDetailsCollectionId, documentId + documentDetails.CreatedBy, documentDetails.OrganizationId).ConfigureAwait(false);
      }

      linkDetails.Id = clonedId + this.userDataService.Id;
      linkDetails.DocumentId = clonedId;
      linkDetails.Status = DocumentStatus.Draft;
      linkDetails.CreatedDate = DateTime.Now;
      linkDetails.ModifiedDate = DateTime.Now;
      linkDetails.IsDeleted = linkDetails.IsArchive = linkDetails.IsPinned = false;
      linkDetails.IsActive = true;
      linkDetails.SignersCount = 0;
      linkDetails.ModifiedFormId = null;

      await this.documentRepositoryService.CreateDocumentAsync(linkDetails, DbConstants.LinkDetailsCollectionId).ConfigureAwait(false);

      await Task.WhenAll(new List<Task>()
      {
        this.CloneDocumentContainerAsync(sourceBlobContainer, cloneBlobContainer, documentDetails, documentElementDetails),
        this.CloneThumbnailContainerAsync(sourceThumbNailContainer, thumbnailCloudBlobContainer, 0, string.Empty, null),
      }).ConfigureAwait(false);

      var documentOrder = documentDetails.DocumentProperties?.OrderBy(x => x.Order);
      bool canDrawDocId = documentDetails.EnableDocumentID;
      await this.ManipulateAndCloneDocuments(documentOrder, cloneBlobContainer, canDrawDocId, documentDetails.OrganizationId).ConfigureAwait(false);

      return clonedId;
    }

    /// <inheritdoc/>
    public async Task<string> MergeTemplateAsync<T>(MergeTemplateList mergeTemplateList, Dictionary<string, string> tempIdPairs, ResponseWriter<T> responseWriter)
    {
      if (mergeTemplateList.TemplateIds == null && !mergeTemplateList.TemplateIds.Any())
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      if (responseWriter is null)
      {
        throw new ArgumentNullException(nameof(responseWriter));
      }

      bool isContainerExist = false;
      BlobContainerClient mergeBlobContainer = await this.CloudStorage
        .GetContainer(mergeTemplateList.MergedTemplateId, mergeTemplateList.OrganizationId).ConfigureAwait(false);
      BlobContainerClient thumbnailCloudBlobContainer = await this.CloudStorage
        .GetContainer($"{mergeTemplateList.MergedTemplateId}-{DbConstants.Thumbnails}", mergeTemplateList.OrganizationId)
        .ConfigureAwait(false);
      if (!mergeTemplateList.HasFilesViaApi)
      {
        isContainerExist = await thumbnailCloudBlobContainer.ExistsAsync().ConfigureAwait(false);
        if (!isContainerExist)
        {
          BlobContainerClient blobContainer = await this.CloudStorage
            .CreateContainer($"{mergeTemplateList.MergedTemplateId}-{DbConstants.Thumbnails}", mergeTemplateList.OrganizationId)
            .ConfigureAwait(false);
          using PdfDocument pdfDocument = new PdfDocument();
          pdfDocument.DocumentInformation.AddCustomMetaDataInfo(CommonResource.DocumentIdMetaData, mergeTemplateList.MergedTemplateId);
          thumbnailCloudBlobContainer = blobContainer;
        }
      }

      string firstTemplateId = mergeTemplateList.TemplateIds.FirstOrDefault();
      if (tempIdPairs != null && tempIdPairs.ContainsKey(firstTemplateId))
      {
        firstTemplateId = tempIdPairs.GetValueOrDefault(firstTemplateId);
      }

      bool hasDuplicateTemplateIds = mergeTemplateList.TemplateIds.GroupBy(id => id).Any(group => group.Count() > 1);
      if (!hasDuplicateTemplateIds)
      {
        await mergeTemplateList.TemplateIds.ParallelForEachAsync(
          async tempId =>
          {
            var index = isContainerExist ? 1 : mergeTemplateList.TemplateIds.ToList().IndexOf(tempId);
            await this.CloneDocumentBlobContainers(mergeTemplateList, tempIdPairs, mergeBlobContainer, thumbnailCloudBlobContainer, index, tempId).ConfigureAwait(false);
          }, maxDegreeOfParallelism: 5).ConfigureAwait(false);
      }
      else
      {
        await this.CloneBlobForDuplicatTemplateId(mergeTemplateList, tempIdPairs, mergeBlobContainer, thumbnailCloudBlobContainer,
          isContainerExist).ConfigureAwait(false);
      }

      if (mergeTemplateList.TargetDocumentProperties.Count() == 1 && !string.IsNullOrEmpty(mergeTemplateList.TargetDocumentProperties.FirstOrDefault().ParentId))
      {
        // List of blob names to be copied
        var blobNames = new[]
        {
        DbConstants.DocumentMerged,
        DbConstants.DocumentMergedDetails,
        DbConstants.DocumentMergedText,
      };

        var sourceBlobContainer = await this.CloudStorage.GetContainer(firstTemplateId, mergeTemplateList.OrganizationId)
          .ConfigureAwait(false);
        var targetBlobContainer = await this.CloudStorage
          .GetContainer(mergeTemplateList.MergedTemplateId, mergeTemplateList.OrganizationId).ConfigureAwait(false);

        var copyTasks = blobNames.Select(blobName => this.CopyBlobAsync(sourceBlobContainer, targetBlobContainer, blobName)).ToList();
        await Task.WhenAll(copyTasks).ConfigureAwait(false);
      }

      return mergeTemplateList.MergedTemplateId;
    }

    /// <inheritdoc/>
    public async Task ReplaceScannedDocuemnt(string documentId, bool isReplaceDocument, string organizationId)
    {
      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = this.userDataService?.OrganizationId;
      }

      // Get the document blob storage for the provided document id.
      BlobContainerClient sourceBlobContainer =
        await this.CloudStorage.GetContainer(documentId, organizationId).ConfigureAwait(false);

      // Get the thumbnails blob storage for the provided document id.
      BlobContainerClient sourceThumbNailContainer = await this.CloudStorage
        .GetContainer($"{documentId}-{DbConstants.Thumbnails}", organizationId).ConfigureAwait(false);

      if (isReplaceDocument)
      {
        List<Task> blobTasks = new List<Task>
        {
          this.PerformBlobReplaceOperation(sourceBlobContainer),
          this.PerformBlobReplaceOperation(sourceThumbNailContainer),
        };

        await Task.WhenAll(blobTasks).ConfigureAwait(false);
        var documentDetails = await this.extendedDocumentDetailsService.GetDocumentDetailsAsync(documentId).ConfigureAwait(false);
        bool canDrawDocId = documentDetails.EnableDocumentID;
        float zoomFactor = GetZoomFactor(documentDetails?.DocumentVersion);
        await this.ReplaceDeskewedImagesInDocument(sourceBlobContainer, documentId, canDrawDocId, zoomFactor).ConfigureAwait(false);

        if (documentDetails.DocumentProperties != null && documentDetails.DocumentProperties.Any())
        {
          DocumentProperties documentProperties = new DocumentProperties
          {
            DocumentId = documentDetails.Id,
            PageCount = documentDetails.DocumentProperties.Select(x => x.PageCount).Sum(),
            UploadType = UploadType.Local,
            DocumentName = documentDetails.PrintSignDocumentName,
            DocumentClientId = documentDetails.DocumentProperties.Select(x => x.DocumentClientId).FirstOrDefault(),
          };
          documentDetails.DocumentProperties = new DocumentProperties[] { documentProperties };
        }

        _ = this.UpdateDocumentDetailsAsync(documentDetails);
      }

      // Delete the scanned blob directory in document and thumbnail.
      string scannedBlobName = $"{DbConstants.ScannedDocument}/";
      _ = DeleteBlobs(sourceBlobContainer, scannedBlobName).ConfigureAwait(false);
      _ = DeleteBlobs(sourceThumbNailContainer, scannedBlobName).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async Task AddDownloadActivity(string documentId, string signerId)
    {
      DocumentDetails documentDetails = GetDocumentDetailsCache(this.httpContext);
      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      var auditData = GetAuditNameAndEmail(this.userDataService, documentDetails);
      string name = auditData.Item1;
      string email = auditData.Item2;
      string userId = this.userDataService.Id;
      string organizationId = this.userDataService.OrganizationId;

      // Setting the name from signer details for uniformity since it varies from the name in userDataService.
      var signerDetails = DocumentDetailsReader.GetCombinedSignerDetails(documentDetails?.SignerDetails)?.FirstOrDefault(x => (PasswordHashing.ValidateSignerHashedPassword(signerId, x) || (!string.IsNullOrEmpty(email) && x.SignerEmail.ToUpperInvariant() == email.ToUpperInvariant())));
      if (signerDetails != null)
      {
        name = signerDetails.SignerName;
        email = signerDetails.SignerEmail;
        userId = signerDetails.UserId;
        organizationId = signerDetails.OrganizationId;
      }

      if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(email) || string.IsNullOrEmpty(userId))
      {
        var ccDetail = documentDetails?.CCDetails?.FirstOrDefault(x => PasswordHashing.ValidateHashedPassword(signerId, x.Id) || (!string.IsNullOrEmpty(signerId) && x.MailLinkSettings != null && x.MailLinkSettings.Any(y => PasswordHashing.ValidateHashedPassword(signerId, y.SignerId))));
        if (ccDetail != null)
        {
          email = ccDetail?.EmailAddress;
          userId = ccDetail?.UserId;
          organizationId = ccDetail.OrganizationId;

          // When the CC downloads the document in private window we will not have the  name information, so setting the email as name value.
          name = ccDetail?.EmailAddress;
        }
      }

      List<Task> tasks = new List<Task>();

      // Update the last activity details in access rights when the status in In-Progress.
      if (documentDetails.Status == DocumentStatus.InProgress)
      {
        var accessRights = this.accessRightsDetailsService.InitializeAccessRightsDetail(documentDetails, organizationId == null ? documentDetails.OrganizationId : organizationId);
        accessRights.ActivityDate = DateTime.UtcNow;
        accessRights.ActivityAction = ActivityAction.Downloaded;
        accessRights.ActivityName = name;
        tasks.Add(this.accessRightsService.AddOrUpdateAccessRightsDetailsAsync(this.elasticClient, accessRights));
      }

      await this.documentAuditLog.CreateAuditLogAsync(documentId, userId, name, email, AuditAction.Downloaded, this.httpContext, adminOrgId: organizationId).ConfigureAwait(false);

      if (!string.IsNullOrEmpty(organizationId) && (documentDetails.OnBehalfOfDetails == null || (userId != documentDetails.OnBehalfOfDetails.UserId && email?.ToUpperInvariant() != documentDetails.OnBehalfOfDetails.EmailAddress.ToUpperInvariant())))
      {
        tasks.Add(this.orgActivityService.Add(EventAction.Downloaded, documentDetails.IsTemplate ? EventCategory.Template : EventCategory.Document, userId, organizationId, documentDetails?.MessageTitle, documentId));
      }

      await Task.WhenAll(tasks).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async Task AddPrintSignDownloadActivity(string documentId, string signerId)
    {
      DocumentDetails documentDetails = GetDocumentDetailsCache(this.httpContext);

      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      string name = this.userDataService.Name;
      string email = this.userDataService.Email;
      string userId = this.userDataService.Id;
      string organizationId = this.userDataService.OrganizationId;

      if (string.IsNullOrEmpty(name) || string.IsNullOrEmpty(email) || string.IsNullOrEmpty(userId))
      {
        var signerDetails = DocumentDetailsReader.GetCombinedSignerDetails(documentDetails?.SignerDetails)?.FirstOrDefault(x => PasswordHashing.ValidateHashedPassword(signerId, x.SignerId));
        if (signerDetails != null)
        {
          name = signerDetails.SignerName;
          email = signerDetails.SignerEmail;
          userId = signerDetails.UserId;
          organizationId = signerDetails.OrganizationId;
        }
      }

      List<Task> tasks = new List<Task>();

      // Update the last activity details in access rights when the status in In-Progress.
      if (documentDetails.Status == DocumentStatus.InProgress)
      {
        var accessRights = this.accessRightsDetailsService.InitializeAccessRightsDetail(documentDetails, organizationId == null ? documentDetails.OrganizationId : organizationId);
        accessRights.ActivityDate = DateTime.UtcNow;
        accessRights.ActivityAction = ActivityAction.DownloadedForPrintSign;
        accessRights.ActivityName = name;
        tasks.Add(this.accessRightsService.AddOrUpdateAccessRightsDetailsAsync(this.elasticClient, accessRights));
      }

      tasks.Add(this.documentAuditLog.CreateAuditLogAsync(documentId, userId, name, email, AuditAction.DownloadedForPrintSign, this.httpContext));

      if (!string.IsNullOrEmpty(organizationId))
      {
        var changeLogs = HelperMethods.AddSingleChangeLog(EventAction.DownloadedForPrintSign.ToString());
        tasks.Add(this.orgActivityService.Add(EventAction.Downloaded, documentDetails.IsTemplate ? EventCategory.Template : EventCategory.Document, userId, organizationId, documentDetails.MessageTitle, documentId, changeLogs));
      }

      await Task.WhenAll(tasks).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async Task AddDocumentCloneActivity(string documentId, bool includeFieldData)
    {
      DocumentDetails documentDetails = GetDocumentDetailsCache(this.httpContext);

      if (documentDetails == null)
      {
        return;
      }

      string name = this.userDataService.Name;
      string email = this.userDataService.Email;
      string userId = this.userDataService.Id;
      string organizationId = this.userDataService.OrganizationId;

      var auditAction = includeFieldData ? AuditAction.ClonedWithFieldValues : AuditAction.Cloned;
      await this.documentAuditLog.CreateAuditLogAsync(documentId, userId, name, email, auditAction, this.httpContext, adminOrgId: organizationId).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public async Task<List<TextLocationDetails>> GetTextLocationsAsync(string[] anchorText, Guid documentId, string organizationId)
    {
      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = this.userDataService?.OrganizationId;
      }

      BlobContainerClient cloudBlobContainer =
        await this.CloudStorage.GetContainer(documentId.ToString(), organizationId).ConfigureAwait(false);
      var blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentMergedText);
      List<DocumentText> documentText = new List<DocumentText>();
      if (blob.Exists())
      {
        documentText = await this.CloudStorage.DownloadAsync<List<DocumentText>>(blob, true).ConfigureAwait(false);
      }
      else
      {
        blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentText);
        documentText = blob.Exists() ? await this.CloudStorage.DownloadAsync<List<DocumentText>>(blob, true).ConfigureAwait(false) : new List<DocumentText>();
      }

      List<TextLocationDetails> textLocationDetails = new List<TextLocationDetails>();

      foreach (var text in anchorText)
      {
        List<TextLocations> textLocations = new List<TextLocations>();
        foreach (var docText in documentText)
        {
          foreach (var textLine in docText.TextLines)
          {
            textLocations.AddRange(this.SetBounds(textLine, text, docText.PageNumber));
          }
        }

        textLocationDetails.Add(new TextLocationDetails() { AnchorText = text, TextLocations = textLocations });
      }

      return textLocationDetails;
    }

    /// <summary>
    /// Updates the template text details.
    /// </summary>
    /// <param name="templateId">The template id.</param>
    /// <returns>A Task.</returns>
    public async Task UpgradeTemplate(Guid templateId)
    {
      var documentDetails = GetDocumentDetailsCache(this.httpContext);
      var accessRightDetails = GetAccessRightsDetailsCache(this.httpContext);
      var properties = documentDetails.DocumentProperties;
      var parentId = properties.FirstOrDefault(x => !string.IsNullOrEmpty(x.ParentId))?.ParentId;
      BlobContainerClient cloudBlobContainer = await this.CloudStorage
        .GetContainer(parentId ?? templateId.ToString(), documentDetails.OrganizationId).ConfigureAwait(false);
      BlobClient blob;
      foreach (var document in properties)
      {
        if (document.PageCount == 0 || document.FileType == UploadFileType.Image)
        {
          continue;
        }

        string blobName = $"{document.DocumentId}/{DbConstants.DocumentClient}";
        string textBlobName = $"{document.DocumentId}/{DbConstants.DocumentText}";
        if (string.IsNullOrEmpty(document.ParentId))
        {
          blobName = DbConstants.DocumentClient;
          textBlobName = DbConstants.DocumentText;
        }

        blob = cloudBlobContainer.GetBlobClient(blobName);
        await using MemoryStream documentStream = new MemoryStream();
        await this.CloudStorage.DownloadToStreamAsync(blob, documentStream, true, CancellationToken.None).ConfigureAwait(false);
        documentStream.Position = 0;
        using var pdfLoadedDocument = new PdfLoadedDocument(documentStream);
        var blobClientDocumentText = cloudBlobContainer.GetBlobClient(textBlobName);
        await this.GetDocumentText(pdfLoadedDocument, blobClientDocumentText).ConfigureAwait(false);
      }

      if (properties.Length > 1 || !string.IsNullOrEmpty(parentId))
      {
        await this.MergeDocumentTextAsync(properties.OrderBy(x => x.Order), cloudBlobContainer).ConfigureAwait(false);
      }

      documentDetails.DocumentProperties.ToList().ForEach(x => x.UploadRequestType = UploadRequestType.Template);
      accessRightDetails.TemplateVersion = documentDetails.TemplateVersion = "v2";
      await this.accessRightsService.AddOrUpdateAccessRightsDetailsAsync(this.elasticClient, accessRightDetails).ConfigureAwait(false);
      _ = this.UpdateDocumentDetailsAsync(documentDetails);
    }

    /// <inheritdoc/>
    public async Task<List<PageFormElements>> GetPdfFormFields(string documentId, string organizationId)
    {
      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = this.userDataService?.OrganizationId;
      }

      return await this.documentContentService.GetPdfFormFields(documentId, organizationId).ConfigureAwait(false);
    }

    public async Task<List<PageFormElements>> GetPdfFormField(string documentId, string organizationId,string zorder)
    {
      // Check whether the organization id is null or empty, and also it is guid, if not take from user data service.
      if (string.IsNullOrEmpty(organizationId) || !Guid.TryParse(organizationId, out _))
      {
        organizationId = this.userDataService?.OrganizationId;
      }

      return await this.documentContentService.GetPdfFormField(documentId, organizationId,zorder).ConfigureAwait(false);
    }

    /// <inheritdoc/>
    public JsonResult ImageConversion(string base64)
    {
      try
      {
        var base64StringValue = base64.Trim().Split("base64,");
        var imageBytes = Convert.FromBase64String(base64StringValue[1]);

        if (base64.Contains("data:image/svg", StringComparison.OrdinalIgnoreCase))
        {
          using var stream = new MemoryStream(imageBytes);
          using var svg = new SKSvg();
          using var loadedSvg = svg.Load(stream);

          // convert to png
          using var ms = new MemoryStream();
          svg.Save(ms, SKColors.Transparent);
          imageBytes = ms.ToArray();
        }

        using SKBitmap image = SKBitmap.Decode(imageBytes);
        float sourceWidth = image.Width;
        float sourceHeight = image.Height;
        float widthRatio = 150F / sourceWidth;
        float heightRatio = 56F / sourceHeight;
        float minRatio = Math.Min(widthRatio, heightRatio);
        int destWidth = (int)(sourceWidth * minRatio);
        int destHeight = (int)(sourceHeight * minRatio);
        using SKBitmap resized = image.Resize(new SKImageInfo(destWidth, destHeight), SKFilterQuality.High);
        using var resizedImage = SKImage.FromBitmap(resized);
        var data = resizedImage.Encode().ToArray();
        string emailBrandLogo = $"data:image/png;base64,{Convert.ToBase64String(data)}";
        return new JsonResult(new { EmailBrandLogo = emailBrandLogo, ImageWidth = destWidth, ImageHeight = destHeight });
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, ex.Message);
      }

      return null;
    }

    /// <inheritdoc/>
    public async Task<DocumentDetails> GetDocumentDetailsForTemplate(string documentId)
    {
      DocumentDetails documentDetails = await this.documentContentService.GetDocumentDetails(documentId).ConfigureAwait(false);
      if (!string.IsNullOrEmpty(documentDetails.ModifiedTemplateId))
      {
        documentDetails = await this.documentContentService.GetDocumentDetails(documentDetails.ModifiedTemplateId).ConfigureAwait(false);
      }

      return documentDetails;
    }

    /// <inheritdoc/>
    public async Task ProcessEvrotrustStatusAsync(EvroTrustWebHookEvent webHookEvent, string documentId, DigitalSignPublisher publisher, CancellationToken cancellationToken)
    {
      if (webHookEvent == null)
      {
        throw new ArgumentNullException(nameof(webHookEvent));
      }

      var normalizedDocumentId = NormalizeDocumentId(documentId);
      if (string.IsNullOrEmpty(normalizedDocumentId) || string.IsNullOrEmpty(webHookEvent.TransactionId))
      {
        return;
      }

      var documentDetails = await this.documentContentService
          .GetDocumentDetails(normalizedDocumentId)
          .ConfigureAwait(false)
          ?? throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      if (documentDetails.Status == DocumentStatus.Completed || documentDetails.Status == DocumentStatus.Expired || documentDetails.Status == DocumentStatus.Revoked || documentDetails.Status == DocumentStatus.Declined)
      {
        return;
      }

      var evrotrustStatus = await this.FetchEvrotrustStatusAsync(documentDetails, webHookEvent.TransactionId)
          .ConfigureAwait(false);

      if ((EvrotrustStatus)evrotrustStatus.Status != webHookEvent.Status)
      {
        return;
      }

      var signer = documentDetails.SignerDetails.FirstOrDefault(s => s.EnableQualifiedElectronicSignature && s.EvroTrustResponse != null && s.EvroTrustResponse.Any(x => x.TransactionID == webHookEvent.TransactionId));

      if (signer == null)
      {
        return;
      }

      if (documentDetails.QesVerificationLimit.Equals(signer.QesVerifiedCount) && webHookEvent.Status != EvrotrustStatus.Signed)
      {
        signer.IsQesVerificationLimitExceeded = true;
      }

      var documentElementDetails = await this.documentContentService
        .GetDocumentElementDetails(documentDetails.Id, documentDetails.OrganizationId).ConfigureAwait(false);

      documentDetails.HasAttachment = HasAttachment(documentElementDetails?.PageFormElements);
      if ((EvrotrustStatus)evrotrustStatus.Status == EvrotrustStatus.Signed)
      {
        await this.HandleDocumentSignedAsync(documentDetails, signer, webHookEvent, publisher).ConfigureAwait(false);
      }
      else
      {
        await this.HandleDocumentNotSignedAsync(documentDetails, signer, webHookEvent).ConfigureAwait(false);
      }
    }

    private async Task HandleDocumentSignedAsync(DocumentDetails documentDetails, SignerDetails signer, EvroTrustWebHookEvent webHookEvent, DigitalSignPublisher publisher)
    {
      var now = DateTime.UtcNow;

      // Update signer and document details for signed status
      signer.Status = SignerStatus.Completed;
      signer.LastActivityDate = now;
      signer.CompletedDate = now;

      documentDetails.Status = DocumentStatus.Completed;
      documentDetails.ModifiedDate = now;
      documentDetails.CompletedOn = now;

      // Updates the activity details.
      documentDetails.ActivityDate = now;
      documentDetails.ActivityAction = ActivityAction.Signed;
      documentDetails.ActivityName = signer.SignerName;
      documentDetails.ActivityBy = signer.SignerEmail;

      var evroTrustResponse = signer.EvroTrustResponse?.FirstOrDefault(x => x.TransactionID == webHookEvent.TransactionId);

      if (evroTrustResponse != null)
      {
        evroTrustResponse.Status = MapToEvroTrustStatus(webHookEvent.Status);
      }

      var tasks = new List<Task>();

      if (documentDetails.Status == DocumentStatus.Completed)
      {
        tasks.Add(this.scheduledService.SetScheduledDeletionOnDate(documentDetails, AllowedDocumentStatusForCleanUp.Completed));
      }

      var authTask = this.GetAuthorizationDetails(documentDetails.Id)
      .ContinueWith(
        async t =>
        {
          var authorizationDetails = t.Result;
          if (authorizationDetails != null)
          {
            if (!string.IsNullOrEmpty(signer.Id))
            {
              var authorizedSigner = authorizationDetails
              .AuthorizedSigners
              .FirstOrDefault(a => a.SignType == SigningType.Single && a.SignerId == signer.Id);

              if (authorizedSigner != null)
              {
                authorizedSigner.Status = signer.Status;
              }
            }

            await this.documentRepositoryService.ReplaceDocumentAsync(
            authorizationDetails,
            DbConstants.AuthorizationDetailsCollectionId,
            authorizationDetails.Id).ConfigureAwait(false);
          }
        }, TaskContinuationOptions.OnlyOnRanToCompletion).Unwrap();

      tasks.Add(authTask);

      // Update document and create audit logs
      tasks.Add(this.documentContentService.UpdateDocumentDetailsUsingLock(documentDetails));
      await this.documentAuditLog.CreateAuditLogAsync(documentDetails.Id, documentDetails.CreatedBy, signer.SignerName, signer.SignerEmail, AuditAction.QESVerified, this.httpContext, evrotrustTransactionId: webHookEvent.TransactionId, evrotrustUser: evroTrustResponse.User, evrotrustUserType: evroTrustResponse.UserType);
      await this.documentAuditLog.CreateAuditLogAsync(documentDetails.Id, documentDetails.CreatedBy, signer.SignerName, signer.SignerEmail, AuditAction.Completed, this.httpContext);

      await Task.WhenAll(tasks).ConfigureAwait(false);
      try
      {
        await this.webHookService.TriggerWebHook(
                new SignedWebhookEvent()
                {
                  DocumentId = documentDetails.Id,
                  EventType = WebHookEventType.Signed,
                  CurrentSignerEmailAddress = signer.SignerEmail,
                }, documentDetails).ConfigureAwait(false);
      }
      catch
      {
        Console.WriteLine("Error in Signed Webhook Event " + documentDetails.Id);
      }

      // Sign and timestamp the PDF
      var digitalSignPayload = new DigitalSignPayload()
      {
        DocumentId = documentDetails.Id,
        OrgId = documentDetails.OrganizationId,
      };

      await publisher.PublishAsync(digitalSignPayload).ConfigureAwait(false);
    }

    private async Task HandleDocumentNotSignedAsync(DocumentDetails documentDetails, SignerDetails signer, EvroTrustWebHookEvent webHookEvent)
    {
      var evroTrustResponse = signer.EvroTrustResponse?.FirstOrDefault(x => x.TransactionID == webHookEvent.TransactionId);

      if (evroTrustResponse != null)
      {
        evroTrustResponse.Status = MapToEvroTrustStatus(webHookEvent.Status);
        if (evroTrustResponse.Status == EvroTrustStatus.Rejected)
        {
          evroTrustResponse.RejectReason = webHookEvent.RejectReason;
        }
      }

      // Update document details for not signed status
      await this.documentContentService.UpdateDocumentDetailsUsingLock(documentDetails).ConfigureAwait(false);
      var auditLogAction = ((EvrotrustStatus)webHookEvent.Status) switch
      {
        EvrotrustStatus.Rejected => AuditAction.QESRejected,
        EvrotrustStatus.Withdrawn => AuditAction.QESWithdrawn,
        _ => AuditAction.QESExpired
      };

      await this.documentAuditLog.CreateAuditLogAsync(
          documentDetails.Id,
          documentDetails.CreatedBy,
          signer.SignerName,
          signer.SignerEmail,
          auditLogAction,
          this.httpContext,
          evrotrustTransactionId: webHookEvent.TransactionId,
          evrotrustUser: evroTrustResponse.User,
          evrotrustUserType: evroTrustResponse.UserType,
          evrotrustRejectReason: evroTrustResponse.RejectReason);
    }

    private async Task<EvroTrustSignStatus> FetchEvrotrustStatusAsync(DocumentDetails documentDetails, string transactionId)
    {
      bool isTestEnvironment = documentDetails.ApplicationEnvironment.IsSandboxMode();
      return documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually && !documentDetails.EnablePrintAndSign
        ? await this.evroTrustApiService.GetGroupStatus(transactionId, isTestEnvironment).ConfigureAwait(false)
        : await this.evroTrustApiService.GetStatus(transactionId, isTestEnvironment).ConfigureAwait(false);
    }

    private static string NormalizeDocumentId(string documentId)
    {
      var slashIndex = documentId.IndexOf('/');
      return slashIndex > 0 ? documentId[..slashIndex] : documentId;
    }

    private static EvroTrustStatus MapToEvroTrustStatus(EvrotrustStatus status)
    {
      return status switch
      {
        EvrotrustStatus.Signed => EvroTrustStatus.Signed,
        EvrotrustStatus.Rejected => EvroTrustStatus.Rejected,
        EvrotrustStatus.Expired => EvroTrustStatus.Expired,
        EvrotrustStatus.Withdrawn => EvroTrustStatus.Withdrawn,
        EvrotrustStatus.Failed => EvroTrustStatus.Failed,
        _ => EvroTrustStatus.InProgress
      };
    }

    private static bool HasAttachment(PageFormElements[] pageFormElements)
    {
      return pageFormElements?.Any(pfe =>
      pfe.FormElements?.Any(fe =>
      fe.ElementType == "attachment" && fe.AttachmentDetails?.Length > 0) == true) == true;
    }

    private async Task CloneBlobForDuplicatTemplateId(MergeTemplateList mergeTemplateList, Dictionary<string, string> tempIdPairs, BlobContainerClient mergeBlobContainer, BlobContainerClient thumbnailCloudBlobContainer, bool isContainerExist)
    {
      var templateIdList = mergeTemplateList.TemplateIds.ToList();
      var indices = templateIdList.Select((tempId, index) => (tempId, index));

      await indices.ParallelForEachAsync(
        async item =>
        {
          var tempId = item.tempId;
          var index = isContainerExist ? 1 : item.index;
          await this.CloneDocumentBlobContainers(mergeTemplateList, tempIdPairs, mergeBlobContainer, thumbnailCloudBlobContainer, index, tempId, true).ConfigureAwait(false);
        }, maxDegreeOfParallelism: 5).ConfigureAwait(false);
    }

    private async Task CloneDocumentBlobContainers(MergeTemplateList mergeTemplateList, Dictionary<string, string> tempIdPairs, BlobContainerClient mergeBlobContainer, BlobContainerClient thumbnailCloudBlobContainer, int index, string tempId, bool hasDuplicateTemplateId = false)
    {
      var modifiedTempId = tempIdPairs != null && tempIdPairs.ContainsKey(tempId) ? tempIdPairs.GetValueOrDefault(tempId) : string.Empty;

      // Get the document blob storage for the provided document id.
      BlobContainerClient sourceBlobContainer = !string.IsNullOrEmpty(modifiedTempId) ?
          await this.CloudStorage.GetContainer(modifiedTempId, mergeTemplateList.OrganizationId).ConfigureAwait(false) :
          await this.CloudStorage.GetContainer(tempId, mergeTemplateList.OrganizationId).ConfigureAwait(false);
      tempId = !string.IsNullOrEmpty(modifiedTempId) ? modifiedTempId : tempId;
      await this.CloneDocumentBlobsWithHierarchy(sourceBlobContainer, mergeBlobContainer, string.Empty, index, tempId, mergeTemplateList.DocumentProperties.ToArray(), hasDuplicateTemplateId).ConfigureAwait(false);

      // Get the thumbnails blob storage for the provided document id.
      BlobContainerClient sourceThumbNailContainer = !string.IsNullOrEmpty(modifiedTempId) ?
          await this.CloudStorage.GetContainer($"{modifiedTempId}-{DbConstants.Thumbnails}", mergeTemplateList.OrganizationId).ConfigureAwait(false) :
          await this.CloudStorage.GetContainer($"{tempId}-{DbConstants.Thumbnails}", mergeTemplateList.OrganizationId).ConfigureAwait(false);
      await this.CloneThumbnailContainerAsync(sourceThumbNailContainer, thumbnailCloudBlobContainer, index, tempId, mergeTemplateList.DocumentProperties.ToArray(), hasDuplicateTemplateId).ConfigureAwait(false);
    }

    private async Task<IActionResult> DownloadInprogressDocumentAsZip(BlobContainerClient blobContainer, DocumentDetails documentDetails, string containerId, string documentId, bool isWaterMarkEnabled)
    {
      DocumentElementDetails documentElementDetails = await this.documentContentService
        .GetDocumentElementDetails(containerId, documentDetails.OrganizationId).ConfigureAwait(false);
      using var zipArchive = new Zip.ZipArchive();
      zipArchive.DefaultCompressionLevel = Syncfusion.Compression.CompressionLevel.Best;
      await this.DownloadInProgressDocument(blobContainer, documentDetails, documentId, isWaterMarkEnabled, documentElementDetails, zipArchive).ConfigureAwait(false);
      return await this.CreateZipResult(zipArchive, documentDetails).ConfigureAwait(false);
    }

    private async Task<IActionResult> DownloadDocumentForEvroTrust(BlobContainerClient blobContainer, DocumentDetails documentDetails, string containerId, string documentId, bool isWaterMarkEnabled, string searchQueryType, string searchQuery, string countryCode)
    {
      DocumentElementDetails documentElementDetails = await this.documentContentService
        .GetDocumentElementDetails(containerId, documentDetails.OrganizationId).ConfigureAwait(false);
      return await this.ProcessDocumentForEvrotrust(blobContainer, documentDetails, documentElementDetails, documentId, null, isWaterMarkEnabled, false, searchQueryType, searchQuery, countryCode).ConfigureAwait(false);
    }

    private async Task<IActionResult> ProcessDocumentsAsZip(DocumentDetails documentDetails, BlobContainerClient blobContainer, CancellationToken token)
    {
      using var zipArchive = new Zip.ZipArchive();
      zipArchive.DefaultCompressionLevel = Syncfusion.Compression.CompressionLevel.Best;
      List<string> fileNames = new List<string>();
      var blobs = await blobContainer.GetBlobsAsync(prefix: DbConstants.IndividualDocumentSigned)
        .AsPages(pageSizeHint: 25)
        .FirstOrDefaultAsync(token)
        .ConfigureAwait(false);

      foreach (var blob in blobs.Values)
      {
        var byteArray = await this.DownloadAndProcessStreamAsync(blobContainer, blob.Name, token).ConfigureAwait(false);
        string fileName = Path.GetFileName(blob.Name);
        zipArchive.AddItem($"{fileName}.pdf", new MemoryStream(byteArray), false, Syncfusion.Compression.FileAttributes.Normal);
      }

      if (documentDetails.CombineAuditTrail)
      {
        var auditDocumentBlob = blobContainer.GetBlobClient(DbConstants.IndividualDocumentAuditTrail);
        if (await auditDocumentBlob.ExistsAsync(token).ConfigureAwait(false))
        {
          string fileName = await this.downloadAuditTrailService.GetFileNameForDownload(documentDetails, string.Empty).ConfigureAwait(false);
          fileName = string.IsNullOrEmpty(fileName) ? AuditLog : $"{fileName}_{AuditLog}";
          var auditByteArray = await this.DownloadAndProcessStreamAsync(auditDocumentBlob, token).ConfigureAwait(false);
          zipArchive.AddItem($"{fileName}.pdf", new MemoryStream(auditByteArray), false, Syncfusion.Compression.FileAttributes.Normal);
        }
      }

      return await this.CreateZipResult(zipArchive, documentDetails).ConfigureAwait(false);
    }

    private async Task<byte[]> DownloadAndProcessStreamAsync(BlobClient blobClient, CancellationToken token)
    {
      using var stream = new MemoryStream();
      await this.DownloadMemoryStream(blobClient, stream, token).ConfigureAwait(false);
      return stream.ToArray();
    }

    private async Task<byte[]> DownloadAndProcessStreamAsync(BlobContainerClient blobContainer, string blobName, CancellationToken token)
    {
      var blobClient = blobContainer.GetBlobClient(blobName);
      return await this.DownloadAndProcessStreamAsync(blobClient, token).ConfigureAwait(false);
    }

    private async Task<IActionResult> CreateZipResult(Zip.ZipArchive zipArchive, DocumentDetails documentDetails)
    {
      if (zipArchive.Count > 0)
      {
        var zipStream = new MemoryStream();
        zipArchive.Save(zipStream, false);
        zipStream.Position = 0;
        var fileName = await this.downloadAuditTrailService.GetFileNameForDownload(documentDetails, $"{documentDetails.MessageTitle}_{documentDetails.Status}").ConfigureAwait(false);
        return new FileStreamResult(zipStream, "application/zip")
        {
          FileDownloadName = $"{fileName}.zip",
        };
      }

      return null;
    }

    private IActionResult CreateZipResultForImportedDocuments(Zip.ZipArchive zipArchive, string documentId)
    {
      if (zipArchive.Count > 0)
      {
        var zipStream = new MemoryStream();
        zipArchive.Save(zipStream, false);
        zipStream.Position = 0;
        return new FileStreamResult(zipStream, "application/zip")
        {
          FileDownloadName = $"{documentId}.zip",
        };
      }

      return null;
    }

    private (List<string> BlobNames, List<string> DocumentNames) GetImportedDocumentsBlobNames(List<ImportedEnvelopeDocumentDetails> documentDetailsAsList)
    {
      var blobNameList = new List<string>();
      var documentNameList = new List<string>();

      for (int i = 0; i < documentDetailsAsList.Count; i++)
      {
        var details = documentDetailsAsList[i];

        var blobName = details.ImportedEnvelopeDocumentType switch
        {
          ImportedEnvelopeDocumentType.Document => $"{details.DocumentId}_Signed_{i + 1}",
          ImportedEnvelopeDocumentType.Attachment => $"{details.DocumentId}_Attachment_{i + 1}",
          ImportedEnvelopeDocumentType.AuditTrail => $"{details.DocumentId}",
          _ => $"{details.DocumentId}_Signed{i + 1}"
        };

        blobNameList.Add(blobName);
        documentNameList.Add(details.DocumentName);
      }

      return (blobNameList, documentNameList);
    }

    private string DuplicateFileName(string fileName, List<string> fileNames)
    {
      var modifiedFileName = Path.GetFileNameWithoutExtension(fileName);
      fileNames.Add(modifiedFileName.ToLowerInvariant());
      if (fileNames.Count(x => x == modifiedFileName.ToLowerInvariant()) > 1)
      {
        modifiedFileName = $"{modifiedFileName}[{fileNames.Count(x => x == modifiedFileName.ToLowerInvariant()) - 1}]";
      }

      return modifiedFileName;
    }

    private string GenerateUniqueFileName(string originalFileName, ConcurrentDictionary<string, bool> usedNames)
    {
      var baseName = Path.GetFileNameWithoutExtension(originalFileName);
      var extension = Path.GetExtension(originalFileName);

      // Regex to match the baseName and optional "[number]" suffix
      var regex = new System.Text.RegularExpressions.Regex($@"^{Regex.Escape(baseName)}(?:\[(\d+)\])?$");
      var matchingFiles = usedNames.Keys
          .Select(key => regex.Match(Path.GetFileNameWithoutExtension(key)))
          .Where(match => match.Success)
          .Select(match => match.Groups[1].Success ? int.Parse(match.Groups[1].Value) : 0);
      int conflictCount = matchingFiles.DefaultIfEmpty(-1).Max() + 1;
      string finalName = conflictCount == 0
          ? $"{baseName}{extension}"
          : $"{baseName}[{conflictCount}]{extension}";

      usedNames.TryAdd(finalName, true);
      return finalName;
    }

    private async Task<JsonResult> ProcessDocumentForEvrotrust(BlobContainerClient blobContainer, DocumentDetails documentDetails, DocumentElementDetails documentElementDetails, string documentId, List<DocumentHashDetails> individualSignedDocumentHashes, bool isWaterMarkEnabled, bool isupload, string searchQueryType, string searchQuery, string countryCode)
    {
      var propertyRanges = new List<(DocumentProperties property, int pageIndex, int endIndex)>();
      var documentHashesConcurrent = new ConcurrentBag<DocumentHash>();
      var fileNames = new ConcurrentDictionary<string, bool>(System.StringComparer.OrdinalIgnoreCase);
      var pageIndex = 1;
      var endIndex = 0;
      foreach (var property in documentDetails.DocumentProperties)
      {
        var fileName = this.GenerateUniqueFileName(property.DocumentName, fileNames);
        property.UniqueFileName = fileName;
        endIndex = endIndex == 0 ? property.PageCount : endIndex + property.PageCount;
        var documentBlob = this.GetDocumentBlob(blobContainer, property);
        using var downloadStream = new MemoryStream();
        await this.DownloadMemoryStream(documentBlob, downloadStream, CancellationToken.None).ConfigureAwait(false);
        downloadStream.Position = 0;
        PdfDocument.EnableCache = false;
        using var loadedDocument = new PdfLoadedDocument(downloadStream);
        loadedDocument.EnableMemoryOptimization = true;
        if (documentDetails.Status != DocumentStatus.Draft && documentElementDetails?.PageFormElements != null)
        {
          await this.DrawDocumentFields(documentElementDetails, loadedDocument, true, pageIndex, endIndex).ConfigureAwait(false);
        }

        this.ApplyWatermarksAndDocumentId(loadedDocument, documentDetails, documentId, isWaterMarkEnabled, isupload);
        var finalStream = new MemoryStream();
        loadedDocument.Save(finalStream);
        finalStream.Position = 0;
        var documentHash = await this.AddEvroTrustSignatureAsync(finalStream, searchQueryType, searchQuery, countryCode, documentId, documentDetails, true, property.DocumentId).ConfigureAwait(false);
        documentHashesConcurrent.Add(new DocumentHash
        {
          Hash = documentHash?.Value as string,
          Description = property.UniqueFileName,
        });
        pageIndex += property.PageCount;
      }

      var documentHashes = documentHashesConcurrent.ToArray();
      var (email, phoneNumber, identificationNumber) = ExtractUserDetails(searchQueryType, searchQuery);
      var epochTime = DateTimeOffset.UtcNow.AddMinutes(10).ToUnixTimeSeconds();
      bool isTestEnvironment = documentDetails.ApplicationEnvironment.IsSandboxMode();
      var response = await this.evroTrustApiService.SendGroupHashForSignAsync(documentHashes, documentDetails.MessageTitle, documentId, epochTime, email, countryCode, phoneNumber, identificationNumber, isTestEnvironment: isTestEnvironment).ConfigureAwait(false);
      return new JsonResult(response);
    }

    private static (string Email, string PhoneNumber, string IdentificationNumber) ExtractUserDetails(string searchQueryType, string searchQuery)
    {
      return searchQueryType switch
      {
        "email" => (searchQuery, string.Empty, string.Empty),
        "phoneNumber" => (string.Empty, searchQuery, string.Empty),
        "identificationNumber" => (string.Empty, string.Empty, searchQuery),
        _ => throw new ArgumentException($@"Invalid search query type: {searchQueryType}", nameof(searchQueryType)),
      };
    }

    private async Task ProcessDocument(BlobContainerClient blobContainer, DocumentDetails documentDetails, DocumentElementDetails documentElementDetails, string documentId, ConcurrentBag<DocumentHashDetails> individualSignedDocumentHashes, Zip.ZipArchive zipArchive, bool isWaterMarkEnabled, bool isupload, bool isQualifiedElectronicSign = false)
    {
      var fileNames = new ConcurrentDictionary<string, bool>(System.StringComparer.OrdinalIgnoreCase);
      var signedEvroTrustObject = documentDetails?.SignerDetails?
          .Where(s => s.EnableQualifiedElectronicSignature)
          .SelectMany(s => s.EvroTrustResponse ?? Enumerable.Empty<EvroTrustResponse>())
          .FirstOrDefault(r => r.TransactionID != null && r.Status == EvroTrustStatus.Signed);
      Organizations organizations = await this.organizationService.GetOrganization(documentDetails.OrganizationId)
        .ConfigureAwait(false);

      // Get encrypted files if qualified electronic sign is enabled
      var encryptedFiles = ImmutableList<EncryptedFiles>.Empty;
      bool isTestEnvironment = documentDetails.ApplicationEnvironment.IsSandboxMode();
      if (isQualifiedElectronicSign && signedEvroTrustObject?.TransactionID != null)
      {
        const int maxRetry = 5;
        for (int attempt = 1; attempt <= maxRetry; attempt++)
        {
          encryptedFiles = await this.evroTrustApiService.GetSignedFilesAsync(signedEvroTrustObject?.TransactionID, isTestEnvironment).ConfigureAwait(false);
          Console.WriteLine($"encrypted retry count is {attempt} and properties length is {documentDetails.DocumentProperties.Length} file length is {encryptedFiles.Count}");
          if (documentDetails.DocumentProperties.Length == encryptedFiles.Count)
          {
            break;
          }

          if (attempt < maxRetry)
          {
            await Task.Delay(TimeSpan.FromSeconds(BoldSignBase.EnvironmentVariables.EvroTrustConfigurationEnv.WaitTime)).ConfigureAwait(false);
          }
        }

        Console.WriteLine($"encrypted file {documentId} count is {encryptedFiles.Count}");
      }

      var pdfResults = new ConcurrentBag<(string FileName, MemoryStream Content)>();
      var propertyRanges = new List<(DocumentProperties property, int pageIndex, int endIndex)>();
      int pageIndex = 1;
      int endIndex = 0;
      foreach (var property in documentDetails.DocumentProperties)
      {
        var fileName = this.GenerateUniqueFileName(property.DocumentName, fileNames);
        property.UniqueFileName = fileName;
        endIndex = endIndex == 0 ? property.PageCount : endIndex + property.PageCount;
        await this.ProcessSingleDocumentAsync(
            blobContainer,
            documentDetails,
            documentElementDetails,
            documentId,
            property,
            pdfResults,
            individualSignedDocumentHashes,
            encryptedFiles,
            isWaterMarkEnabled,
            isupload,
            isQualifiedElectronicSign,
            organizations,
            pageIndex,
            endIndex).ConfigureAwait(false);
        pageIndex += property.PageCount;
      }

      foreach (var (fn, ms) in pdfResults)
      {
        zipArchive.AddItem($"{fn}.pdf", ms, false, Syncfusion.Compression.FileAttributes.Normal);
      }
    }

    private async Task ProcessSingleDocumentAsync(
        BlobContainerClient blobContainer,
        DocumentDetails documentDetails,
        DocumentElementDetails documentElementDetails,
        string documentId,
        DocumentProperties property,
        ConcurrentBag<(string FileName, MemoryStream Content)> pdfResults,
        ConcurrentBag<DocumentHashDetails> individualSignedDocumentHashes,
        ImmutableList<EncryptedFiles> encryptedFiles,
        bool isWaterMarkEnabled,
        bool isUpload,
        bool isQualifiedElectronicSign,
        Organizations organizations,
        int startPage,
        int endPage)
    {
      var fileNames = new List<string>();
      try
      {
        EncryptedFiles encryptedFile = null;
        if (isQualifiedElectronicSign && encryptedFiles.Count > 0)
        {
          encryptedFile = encryptedFiles.Find(e =>
              e.FileName.Equals(property.UniqueFileName, StringComparison.OrdinalIgnoreCase));
        }

        var ignoreProcess = isQualifiedElectronicSign && encryptedFile != null;
        BlobClient blob = ignoreProcess
            ? this.GetEvrotrustDocumentBlob(blobContainer, property)
            : this.GetDocumentBlob(blobContainer, property);
        var finalStream = new MemoryStream();
        using var downloadStream = new MemoryStream();

        await this.DownloadMemoryStream(blob, downloadStream, CancellationToken.None)
            .ConfigureAwait(false);
        downloadStream.Position = 0;
        PdfDocument.EnableCache = false;
        if (ignoreProcess)
        {
          await downloadStream.CopyToAsync(finalStream).ConfigureAwait(false);
          finalStream.Position = 0;
        }
        else
        {
          using var loadedDocument = new PdfLoadedDocument(downloadStream)
          {
            EnableMemoryOptimization = true,
          };

          if (documentDetails.Status != DocumentStatus.Draft && documentElementDetails?.PageFormElements != null)
          {
            await this.DrawDocumentFields(documentElementDetails, loadedDocument, true, startPage, endPage).ConfigureAwait(false);
          }

          this.ApplyWatermarksAndDocumentId(
              loadedDocument,
              documentDetails,
              documentId,
              isWaterMarkEnabled,
              isUpload);

          loadedDocument.Save(finalStream);
          finalStream.Position = 0;
        }

        var fileName = !string.IsNullOrEmpty(property.UniqueFileName) ? Path.GetFileNameWithoutExtension(property.UniqueFileName) : this.DuplicateFileName(property.DocumentName, fileNames);

        if (isUpload)
        {
          var manipulatedDocumentBytes = await this.downloadAuditTrailService.SignAndUploadDocument(blobContainer, finalStream, documentDetails.Id, documentDetails.OrganizationId, false, true, fileName, encryptedFile, isQualifiedElectronicSign, organizations).ConfigureAwait(false);
          individualSignedDocumentHashes.Add(new DocumentHashDetails
          {
            Name = fileName,
            HashValue = manipulatedDocumentBytes,
          });
        }
        else
        {
          pdfResults.Add((fileName, finalStream));
        }
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, "Error processing {DocumentName} in parallel", property.DocumentName);
      }
    }

    private async Task UploadSignedDocumentSeparately(DocumentDetails documentDetails, BlobContainerClient blobContainer, DocumentElementDetails documentFormFields, ConcurrentBag<DocumentHashDetails> individualSignedDocumentHashes, bool isQualifiedElectronicSign = false)
    {
      await this.ProcessDocument(blobContainer, documentDetails, documentFormFields, documentDetails.Id, individualSignedDocumentHashes, null, false, true, isQualifiedElectronicSign).ConfigureAwait(false);
    }

    private async Task DownloadInProgressDocument(BlobContainerClient blobContainer, DocumentDetails documentDetails, string documentId, bool isWaterMarkEnabled, DocumentElementDetails documentElementDetails, Zip.ZipArchive zipArchive)
    {
      await this.ProcessDocument(blobContainer, documentDetails, documentElementDetails, documentId, null, zipArchive, isWaterMarkEnabled, false, false).ConfigureAwait(false);
    }

    private BlobClient GetDocumentBlob(BlobContainerClient blobContainer, DocumentProperties property)
    {
      var blobName = string.IsNullOrEmpty(property.ParentId) ? DbConstants.Document : $"{property.DocumentId}/{DbConstants.Document}";
      return blobContainer.GetBlobClient(blobName);
    }

    private BlobClient GetEvrotrustDocumentBlob(BlobContainerClient blobContainer, DocumentProperties property)
    {
      var blobName = string.IsNullOrEmpty(property.ParentId) ? $"{EvrotrustDocument}" : $"{property.DocumentId}/{EvrotrustDocument}";
      return blobContainer.GetBlobClient(blobName);
    }

    private async Task DownloadMemoryStream(BlobClient blob, MemoryStream documentStream, CancellationToken token)
    {
      await this.CloudStorage.DownloadToStreamAsync(blob, documentStream, true, token)
        .ConfigureAwait(false);
    }

    private void ApplyWatermarksAndDocumentId(PdfLoadedDocument loadedDocument, DocumentDetails documentDetails, string documentId, bool isWaterMarkEnabled = false, bool isCompleted = false)
    {
      if (isCompleted)
      {
        this.UpdateDocumentId(loadedDocument, documentId);
      }

      string finalText = this.GetDocumentIdText(documentDetails, documentId);
      foreach (PdfPageBase page in loadedDocument.Pages)
      {
        if (isWaterMarkEnabled && documentDetails.Status != DocumentStatus.Completed)
        {
          string statusText = GetDescription(documentDetails.Status);
          this.DrawWatermark(page, statusText);
        }

        if (!string.IsNullOrEmpty(finalText))
        {
          DrawDocumentId(page, finalText);
        }
      }
    }

    private void UpdateDocumentId(PdfLoadedDocument loadedDocument, string documentId)
    {
      // Set the correct document ID in DocumentInformation in case the document is signed from form it may contain different documentId.
      if (!loadedDocument.DocumentInformation.CustomMetadata.ContainsKey(CommonResource.DocumentIdMetaData) ||
          loadedDocument.DocumentInformation.CustomMetadata[CommonResource.DocumentIdMetaData] != documentId)
      {
        loadedDocument.DocumentInformation.CustomMetadata[CommonResource.DocumentIdMetaData] = documentId;
      }
    }

    private string GetDocumentIdText(DocumentDetails documentDetails, string documentId)
    {
      bool canDrawDocId = documentDetails.EnableDocumentID;
      bool isApiTestDoc = documentDetails.ApplicationEnvironment is ApplicationEnvironment.Test;

      switch ((canDrawDocId, isApiTestDoc))
      {
        case (true, true):
          return $"{CommonResource.DocumentIdText}{documentId} ({CommonResource.SandBoxTrialText})";
        case (false, true):
          return CommonResource.SandBoxTrialText;
        case (true, false):
          return $"{CommonResource.DocumentIdText}{documentId}";
        default:
          return string.Empty;
      }
    }

    private async Task GetDocumentText(PdfLoadedDocument pdfLoadedDocument, BlobClient blobClientDocumentText)
    {
      List<DocumentText> documentText = new List<DocumentText>();

      for (int i = 0; i < pdfLoadedDocument.Pages.Count; i++)
      {
        TextLineCollection textLineCollection = null;
        pdfLoadedDocument.Pages[i].ExtractText(out textLineCollection);
        List<TextLines> textLines = new List<TextLines>();
        foreach (var textLine in textLineCollection.TextLine)
        {
          List<TextWords> textWords = new List<TextWords>();
          foreach (var textWord in textLine.WordCollection)
          {
            textWords.Add(new TextWords()
            {
              Bounds = textWord.Bounds,
              Text = textWord.Text,
            });
          }

          textLines.Add(new TextLines()
          {
            Text = textLine.Text,
            Bounds = textLine.Bounds,
            TextWords = textWords,
          });
        }

        documentText.Add(new DocumentText()
        {
          PageNumber = i + 1,
          TextLines = textLines,
        });
      }

      await this.CloudStorage.UploadFromByteArrayAsync(blobClientDocumentText, BinarySerializer.Serialize<List<DocumentText>>(documentText), 0, true).ConfigureAwait(false);
    }

    private List<TextLocations> SetBounds(TextLines textLine, string anchorText, int pageNumber)
    {
      List<TextLocations> textLocations = new List<TextLocations>();
      var tagText = anchorText;
      Syncfusion.Drawing.RectangleF textBounds = default(Syncfusion.Drawing.RectangleF);

      for (int wordIndex = 0; wordIndex < textLine.TextWords.Count; wordIndex++)
      {
        var textWord = textLine.TextWords[wordIndex];
        var wordText = textWord.Text;

        if (tagText.IsEqual(wordText))
        {
          tagText = string.Empty;

          textBounds = textBounds == default(Syncfusion.Drawing.RectangleF)
            ? new Syncfusion.Drawing.RectangleF(textWord.Bounds.X, textWord.Bounds.Y, textWord.Bounds.Width, textWord.Bounds.Height)
            : new Syncfusion.Drawing.RectangleF(textBounds.X, textBounds.Y, textBounds.Width + textWord.Bounds.Width, textBounds.Height);
          textLocations.Add(new TextLocations()
          {
            PageNumber = pageNumber,
            Location = new PointF(textBounds.Location.X, textBounds.Location.Y),
          });

          tagText = anchorText;
          textBounds = default(Syncfusion.Drawing.RectangleF);
        }
        else
        {
          if (tagText.StartsWith(wordText, StringComparison.InvariantCultureIgnoreCase))
          {
            textBounds = textBounds == default(Syncfusion.Drawing.RectangleF)
              ? new Syncfusion.Drawing.RectangleF(textWord.Bounds.X, textWord.Bounds.Y, textWord.Bounds.Width, textWord.Bounds.Height)
              : new Syncfusion.Drawing.RectangleF(textBounds.X, textBounds.Y, textBounds.Width + textWord.Bounds.Width, textBounds.Height);

            tagText = tagText.Remove(0, wordText.Length);
          }
          else if (textBounds != default(Syncfusion.Drawing.RectangleF))
          {
            tagText = anchorText;

            // check if the current word is present in anchor text.
            tagText = anchorText.StartsWith(wordText, StringComparison.InvariantCultureIgnoreCase) ? tagText.Remove(0, wordText.Length) : anchorText;
            textBounds = anchorText.StartsWith(wordText, StringComparison.InvariantCultureIgnoreCase) ? new Syncfusion.Drawing.RectangleF(textWord.Bounds.X, textWord.Bounds.Y, textWord.Bounds.Width, textWord.Bounds.Height) : default(Syncfusion.Drawing.RectangleF);
          }
        }
      }

      return textLocations;
    }

    private bool IsIgnoredElementType(string elementType) => elementType is "signature" or "initial" or "image" or "attachment";

    private bool IsIgnoredClonedElementType(string elementType) => elementType is "signature" or "initial" or "image" or "attachment" or "datepicker" or "formula";

    private bool IsCommonFields(string elementType) => elementType is "label" or "hyperlink";

    private List<string> ExtractCommonFields(IEnumerable<PageFormElements> pageFormElements, Func<FormElement, string> selector)
    {
      return pageFormElements.SelectMany(pfe => pfe.FormElements).Where(fe => this.IsCommonFields(fe.ElementType)).Select(selector).ToList();
    }

    private static string DefaultFileNameForDownload(string fileName, DocumentStatus status)
    {
      return SanitizedFileName.GetValidFileName(fileName) + "_" + status.ToString();
    }

    private static string GetFileNameForDownloadAttachment(string fileName, string extension)
    {
      return SanitizedFileName.GetValidFileName(fileName) + "." + extension;
    }

    private static string GetDescription(Enum enumValue)
    {
      if (enumValue is null)
      {
        throw new ArgumentNullException(nameof(enumValue));
      }

      FieldInfo info = enumValue.GetType().GetField(enumValue.ToString());

      DescriptionAttribute enumAttributes
        = Attribute.GetCustomAttribute(info, typeof(DescriptionAttribute))
          as DescriptionAttribute;

      return enumAttributes == null ? enumValue.ToString() : enumAttributes.Description;
    }

    private static async Task CloneBlobAsync(BlobClient sourceBlob, BlobClient clonedBlob)
    {
      if (clonedBlob is null)
      {
        throw new ArgumentNullException(nameof(clonedBlob));
      }

      BlobCopyFromUriOptions blobCopyFromUriOptions = new BlobCopyFromUriOptions();
      await clonedBlob.StartCopyFromUriAsync(sourceBlob.Uri, blobCopyFromUriOptions).ConfigureAwait(false);
    }

    private static async Task DeleteBlobs(BlobContainerClient cloudBlobContainer, string prefix)
    {
      var resultSegment = cloudBlobContainer.GetBlobsByHierarchyAsync(prefix: prefix, delimiter: "/")
        .AsPages(default, BlobRequestCount);

      await foreach (Azure.Page<BlobHierarchyItem> blobPage in resultSegment)
      {
        // Enumerate the blobs returned for each page.
        foreach (BlobHierarchyItem blobhierarchyItem in blobPage.Values)
        {
          if (blobhierarchyItem.IsBlob)
          {
            await cloudBlobContainer.DeleteBlobAsync(blobhierarchyItem.Blob.Name).ConfigureAwait(false);
          }
        }
      }
    }

    // Method to create thumbnail image for the provided image stream.
    // Note: This method is used only for converting the directly uploaded image to thumbnail.
    private static byte[] GenerateThumbnailImage(Stream imageStream)
    {
      int quality = 75;
      int width = 99;
      int height = 141;
      using var resized = new SKBitmap(width, height);
      imageStream.Seek(0, SeekOrigin.Begin);
      using var image = SKBitmap.Decode(imageStream);
      using var canvas = new SKCanvas(resized);
      canvas.DrawBitmap(image, new SKRect(0, 0, width, height));
      using var output = new MemoryStream();
      using var data = SKImage.FromBitmap(resized).Encode(SKEncodedImageFormat.Png, quality);
      data.SaveTo(output);
      return output.ToArray();
    }

    /// <summary>
    /// Retrieves the SignerID from the HTTP context, if the HTTP context does not have the details then  null value is returned.
    /// </summary>
    /// <param name="context">context.</param>
    /// <returns>string.</returns>
    private static string GetSignerIdCache(HttpContext context)
    {
      if (context != null && context.Items.TryGetValue(SignerIdData, out object signerIdObject))
      {
        if (signerIdObject is string signerId)
        {
          return signerId;
        }
      }

      return null;
    }

    /// <summary>
    /// Retrieves the DocumentID from the HTTP context, if the HTTP context does not have the details then  null value is returned.
    /// </summary>
    /// <param name="context">context.</param>
    /// <returns>DocumentID.</returns>
    private static string GetDocumentIdCache(HttpContext context)
    {
      if (context != null && context.Items.TryGetValue(DocumentDetailsReader.DocumentIdData, out object documentIdObj))
      {
        if (documentIdObj is string documentId)
        {
          return documentId;
        }
      }

      return null;
    }

    // Draw Document ID to the page based on the page width.
    private static void DrawDocumentId(PdfPageBase page, string text)
    {
      PdfFont font = new PdfStandardFont(PdfFontFamily.Helvetica, DocIdFontSize, PdfFontStyle.Bold);
      var sizef = font.MeasureString(text);

      float brushPositionX = DocIdPositionX - (font.Size / 2);
      float brushPositionY = DocIdPositionY - (font.Height / 15);

      PdfStringFormat pdfStringFormat = new PdfStringFormat(PdfTextAlignment.Left);
      pdfStringFormat.WordWrap = PdfWordWrapType.WordOnly;

      // Rectangle width is increased to 8 in draw rectangle method to avoid document id overlapping when downloading a reused document.
      page.Graphics.DrawRectangle(PdfBrushes.White, new Syncfusion.Drawing.RectangleF(brushPositionX, brushPositionY, sizef.Width + font.Size + 8, sizef.Height + (font.Height / 8)));
      page.Graphics.DrawString(text, font, PdfBrushes.Black, new Syncfusion.Drawing.RectangleF(DocIdPositionX, DocIdPositionY, sizef.Width, sizef.Height + (font.Height * 4)), pdfStringFormat);
    }

    private static float GetFontSize(float requiredWidth, string text)
    {
      float fontSize = 0;
      PdfFont font = new PdfStandardFont(PdfFontFamily.Helvetica, 1);

      var minimumSize = font.MeasureString(text);
      fontSize = requiredWidth / minimumSize.Width;
      return fontSize;
    }

    private static PdfColor HexToPdfColor(string hexString)
    {
      if (hexString.IndexOf('#', StringComparison.InvariantCultureIgnoreCase) != -1)
      {
        hexString = hexString.Replace("#", string.Empty, false, CultureInfo.InvariantCulture);
      }

      int red, green, blue = 0;

      red = int.Parse(hexString.Substring(0, 2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture);
      green = int.Parse(hexString.Substring(2, 2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture);
      blue = int.Parse(hexString.Substring(4, 2), NumberStyles.AllowHexSpecifier, CultureInfo.InvariantCulture);

      return new PdfColor(Syncfusion.Drawing.Color.FromArgb(red, green, blue));
    }

    private async Task UploadAndManipulateDocument(string parentId, string uniqueId, string childId, bool isPrintSignDocument, IDocumentUploadDetails documentUploadDetails, IResponseWriter responseWriter, CancellationToken cancellationToken)
    {
      string message = CommonResource.DocumentClientId + $" : {documentUploadDetails.DocumentClientId}\n" + CommonResource.DocumentId + $" : {uniqueId}";

      await this.UpdateUploadProgress(message, false).ConfigureAwait(false);
      string scannedBlobName = string.Empty;
      DocumentDetails documentDetails = null;
      BlobContainerClient cloudBlobContainer = null;
      BlobContainerClient thumbnailCloudBlobContainer = null;
      var userID = new UserDataService(this.httpContext).Id;

      if (isPrintSignDocument)
      {
        uniqueId = documentUploadDetails.PrintSignDocumentId;
        parentId = documentUploadDetails.PrintSignDocumentId;
        childId = string.Empty;
        scannedBlobName = $"{DbConstants.ScannedDocument}/";
      }

      cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, documentUploadDetails.OrganizationId)
        .ConfigureAwait(false);
      thumbnailCloudBlobContainer = await this.CloudStorage
        .GetContainer($"{parentId}-{DbConstants.Thumbnails}", documentUploadDetails.OrganizationId)
        .ConfigureAwait(false);

      if (string.IsNullOrEmpty(childId) && string.IsNullOrEmpty(documentUploadDetails.PrintSignDocumentId))
      {
        await cloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
        await thumbnailCloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
      }

      ValidateCorruptedPDFDocument(documentUploadDetails);
      async Task ProgressCallback(string msg) => await this.UpdateUploadProgress(msg, false).ConfigureAwait(false);

      var documentProgress = new DocumentProgress(4, ProgressCallback);
      using Stream documentStream = await this.GetPdfDocumentStream(documentUploadDetails, cloudBlobContainer, thumbnailCloudBlobContainer, childId, documentProgress).ConfigureAwait(false);
      PdfDocument.EnableCache = false;
      using var pdfLoadedDocument = new PdfLoadedDocument(documentUploadDetails.DocumentArray);
      this.DocumentUploadDetails = documentUploadDetails;
      if (pdfLoadedDocument.IsXFAForm && pdfLoadedDocument.Form.Fields.Count == 0)
      {
        throw new InvalidDataException(CommonResource.DynamicXFAErrorMessage);
      }

      var contentType = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType);
      if (contentType != ContentType.Images)
      {
        try
        {
          await this.ProcessAndExtractPdfFormFields(pdfLoadedDocument, parentId, childId, documentUploadDetails.OrganizationId).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
          this.logger.LogError(ex, CommonResource.ExtractfieldError);
        }
      }

      try
      {
        if (contentType != ContentType.Images
            && (documentUploadDetails.UploadRequestType == UploadRequestType.Template || documentUploadDetails.UploadRequestType == UploadRequestType.UseTemplate))
        {
          var blobClientDocumentText = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentText}");
          await this.GetDocumentText(pdfLoadedDocument, blobClientDocumentText).ConfigureAwait(false);
        }
      }
      catch (Exception e)
      {
        this.logger.LogError(e, "Unable to extract document text for template auto positioning");
      }

      // we are writing the document id in response initially then we will only write in SignalR, hence we disable response write after we have written the document id
      if (responseWriter is ResponseWriter<HttpResponse> res)
      {
        var docIdResponse = new { documentId = uniqueId, documentClientId = documentUploadDetails.DocumentClientId, pageCount = pdfLoadedDocument.PageCount, isTaggedPdf = pdfLoadedDocument.FileStructure?.TaggedPdf ?? false };
        await res.WriteAsync(docIdResponse.ToJson()).ConfigureAwait(false);
        responseWriter = null;
      }

      pdfLoadedDocument.EnableMemoryOptimization = true;

      var conetntType = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType, documentUploadDetails.DocumentName);

      if (isPrintSignDocument)
      {
        documentDetails = await this.GetPrintSignDocumentDetails(this.httpContext, pdfLoadedDocument.PageCount, documentUploadDetails).ConfigureAwait(false);
        documentUploadDetails.DocumentVersion = documentDetails.DocumentVersion;
      }

      if (string.IsNullOrEmpty(documentUploadDetails.IsEditTemplate) || !(bool.TryParse(documentUploadDetails.IsEditTemplate, out bool isEditTemplate) && isEditTemplate))
      {
        await this.ValidateDocument(documentUploadDetails, pdfLoadedDocument, cloudBlobContainer).ConfigureAwait(false);
      }

      MemoryStream manipulatedDocumentStream = null;
      Task documentCLientUploadTask = null;
      try
      {
        var blobClientDocument = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.DocumentClient}");
        documentStream.Position = 0;
        documentCLientUploadTask = this.CloudStorage.UploadFromStreamAsync(blobClientDocument, documentStream, true);
        manipulatedDocumentStream = await this.ManipulatePDF(pdfLoadedDocument, documentProgress, parentId, conetntType, uniqueId, documentUploadDetails.OrganizationId).ConfigureAwait(false);

        if (manipulatedDocumentStream == null)
        {
          throw new NullReferenceException(CommonResource.EmptyManipulatedDocumentStream);
        }
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);

        throw;
      }

      documentProgress.Reset();
      var documentUploadProgress = new Progress<long>();
      var documentLength = manipulatedDocumentStream.Length;

      async void UploadDocumentHandler(object sender, long bytesUploaded)
      {
        await (documentProgress?.UpdateUploadProgress(bytesUploaded, documentLength)).ConfigureAwait(false);
      }

      documentUploadProgress.ProgressChanged += UploadDocumentHandler;

      var blobClient = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Document}");
      try
      {
        manipulatedDocumentStream.Position = 0;

        // Upload the manipulated PDF document.
        await this.CloudStorage.UploadFromStreamAsync(blobClient, manipulatedDocumentStream, true, documentUploadProgress, cancellationToken).ConfigureAwait(false);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);
      }

      await documentCLientUploadTask.ConfigureAwait(false);
      manipulatedDocumentStream.Position = 0;
      float zoomFactor = GetZoomFactor(documentUploadDetails?.DocumentVersion);
      try
      {
        // Images will be uploaded directly so no need of uploading it by converting PDF to image
        if (conetntType != ContentType.Images)
        {
          // Upload PDF viewer objects like page count, page size, images and thumbnail.
          blobClient = await this.UploadPdfViewerObjects(
            childId,
            documentUploadDetails.OrganizationId,
            documentProgress,
            manipulatedDocumentStream,
            cloudBlobContainer,
            parentId,
            scannedBlobName,
            documentDetails,
            zoomFactor,
            cancellationToken).ConfigureAwait(false);
        }

        await this.UpdateUploadProgress(string.Format(CultureInfo.InvariantCulture, "Completed"), false).ConfigureAwait(false);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);

        throw;
      }
      finally
      {
        documentStream.Dispose();
        manipulatedDocumentStream?.Dispose();
        documentUploadProgress.ProgressChanged -= UploadDocumentHandler;

        // Release all the fonts which are cached
        PdfDocument.ClearFontCache();
      }
    }

    private async Task ReplaceDeskewedImagesInDocument(BlobContainerClient sourceBlobContainer, string documentId, bool canDrawDocId, float zoomFactor)
    {
      var documentBlob = sourceBlobContainer.GetBlobClient(DbConstants.Document);
      MemoryStream documentStream = new MemoryStream();
      await this.CloudStorage.DownloadToStreamAsync(documentBlob, documentStream, true, CancellationToken.None).ConfigureAwait(false);

      using var loadedDocument = new PdfLoadedDocument(documentStream);

      for (int i = 0; i < loadedDocument.PageCount; i++)
      {
        PdfLoadedPage page = loadedDocument.Pages[i] as PdfLoadedPage;
        var blockBlob = sourceBlobContainer.GetBlobClient($"{DbConstants.Page}-{i}-{zoomFactor}");
        using MemoryStream ms = new MemoryStream();
        var imageDetails = await this.CloudStorage.DownloadAsync<PdfViewerImage>(blockBlob, false).ConfigureAwait(false);

        using var imageMS = new MemoryStream(imageDetails.PngBytes);
        using PdfBitmap image = new PdfBitmap(imageMS);

        var imageOrientation = image.Width > image.Height ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;
        var pageOrientation = page.Graphics.ClientSize.Width > page.Graphics.ClientSize.Height ? PdfPageOrientation.Landscape : PdfPageOrientation.Portrait;
        PdfPageBase contentPage = null;

        // We need to change the orientation the uploaded print sign document document page based on original image orientation.
        if (pageOrientation == imageOrientation)
        {
          page.Graphics.DrawImage(image, new Syncfusion.Drawing.RectangleF(new Syncfusion.Drawing.PointF(0, 0), page.Size));
          contentPage = page;
        }
        else
        {
          contentPage = loadedDocument.Pages.Insert(i, new Syncfusion.Drawing.SizeF(page.Graphics.ClientSize.Height, page.Graphics.ClientSize.Width), new PdfMargins(), PdfPageRotateAngle.RotateAngle0, imageOrientation);
          contentPage.Graphics.DrawImage(image, new Syncfusion.Drawing.RectangleF(new Syncfusion.Drawing.PointF(0, 0), page.Size));
          loadedDocument.Pages.Remove(page);
        }

        if (canDrawDocId)
        {
          string text = CommonResource.DocumentIdText + documentId;
          DrawDocumentId(contentPage, text);
        }
      }

      using MemoryStream manipulatedDocumentStream = new MemoryStream();
      loadedDocument.Save(manipulatedDocumentStream);
      manipulatedDocumentStream.Position = 0;
      await this.CloudStorage.UploadFromStreamAsync(documentBlob, manipulatedDocumentStream, true).ConfigureAwait(false);
    }

    private async Task UpdateDocumentDetailsAsync(DocumentDetails documentDetails)
    {
      await this.extendedDocumentDetailsService.AddOrUpdateDocumentDetails(documentDetails).ConfigureAwait(false);
    }

    private async Task<AuthorizationDetails> GetAuthorizationDetails(string sourceDocumentId)
    {
      try
      {
        var sourceAuthorizationDetails = await this.authorizationDetailsService.GetAuthorizationDetailsAsync(sourceDocumentId).ConfigureAwait(false);
        return sourceAuthorizationDetails;
      }
      catch (Microsoft.Azure.Cosmos.CosmosException ex) when (ex.StatusCode == System.Net.HttpStatusCode.NotFound)
      {
        return null;
      }
    }

    private async Task CloneAccessRightDetails(string sourceDocumentId, string clonedDocumentId, bool isTemplate = false)
    {
      var sourceAccessRights = await this.accessRightsService.GetAccessRightsDetailsAsync(this.elasticClient, sourceDocumentId, this.userDataService.OrganizationId).ConfigureAwait(false);
      if (sourceAccessRights == null)
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }

      AccessRightsDetails clonedAccessRights = sourceAccessRights;
      clonedAccessRights.Id = clonedDocumentId + this.userDataService?.OrganizationId;
      clonedAccessRights.DocumentId = clonedDocumentId;
      clonedAccessRights.CreatedDate = DateTime.UtcNow;
      clonedAccessRights.ActivityDate = DateTime.UtcNow;
      clonedAccessRights.Status = DocumentStatus.Draft;
      clonedAccessRights.SignedDocumentHash = string.Empty;
      clonedAccessRights.SenderDetail.IsViewed = false;
      clonedAccessRights.SenderDetail.IsArchive = false;
      clonedAccessRights.SenderDetail.DisplayStatus = DisplayStatus.None;
      clonedAccessRights.ActivityAction = ActivityAction.None;
      clonedAccessRights.ActivityBy = string.Empty;
      clonedAccessRights.HasAttachment = false;
      clonedAccessRights.SenderDetail.UserId = this.userDataService.Id;
      clonedAccessRights.DownloadFileName = string.Empty;
      if (isTemplate)
      {
        clonedAccessRights.SenderDetail.Name = this.userDataService.Name;
        clonedAccessRights.SenderDetail.EmailAddress = this.userDataService.Email;
        clonedAccessRights.SenderDetail.AccessUid = this.userDataService.Id;
        clonedAccessRights.SenderDetail.OrganizationId = this.userDataService.OrganizationId;
        clonedAccessRights.SenderDetail.TeamId = this.userDataService.TeamId;
        clonedAccessRights.AccessTid = null;
      }

      void UpdateAccessRightsSigners(AccessRightsSignerDetails[] accessRightsSigners)
      {
        foreach (AccessRightsSignerDetails signer in accessRightsSigners)
        {
          if (signer.IsAuthenticationFailed != null)
          {
            signer.IsAuthenticationFailed = false;
          }

          signer.IsDeliveryFailed = false;
          signer.Status = SignerStatus.NotCompleted;
          signer.DisplayStatus = DisplayStatus.None;
          signer.HostDisplayStatus = DisplayStatus.None;
          signer.IsViewed = false;
          signer.IsArchive = false;

          if (signer.SignType == SigningType.Group && signer.SigningGroupDetails != null)
          {
            UpdateAccessRightsSigners(signer.SigningGroupDetails);
          }
        }
      }

      if (clonedAccessRights.SignerDetails.Any())
      {
        UpdateAccessRightsSigners(clonedAccessRights.SignerDetails);
      }

      if (clonedAccessRights.CCDetails != null && clonedAccessRights.CCDetails.Any())
      {
        foreach (AccessRightsCCDetails ccDetail in clonedAccessRights.CCDetails)
        {
          ccDetail.DisplayStatus = DisplayStatus.None;
          ccDetail.IsViewed = false;
          ccDetail.IsArchive = false;
        }
      }

      await this.accessRightsService.AddOrUpdateAccessRightsDetailsAsync(this.elasticClient, clonedAccessRights).ConfigureAwait(false);
    }

    private BoldSign.Base.Models.Rectangle ConvertToPixelsFromPoints(Syncfusion.Drawing.RectangleF bound)
    {
      var boundsInPixel = this.converter.ConvertToPixels(bound, PdfGraphicsUnit.Point);
      var bounds = new BoldSign.Base.Models.Rectangle()
      {
        X = boundsInPixel.X,
        Y = boundsInPixel.Y,
        Height = boundsInPixel.Height,
        Width = boundsInPixel.Width,
      };
      return bounds;
    }

    private Task CloneDocumentContainerAsync(BlobContainerClient sourceBlobContainer, BlobContainerClient cloneBlobContainer, DocumentDetails documentDetails, DocumentElementDetails documentElementDetails)
    {
      List<Task> blobTasks = new List<Task>();

      blobTasks.Add(this.CloneDocumentBlobsWithHierarchy(sourceBlobContainer, cloneBlobContainer, string.Empty, 0, string.Empty, null));

      // Resetting the field elements
      if (documentElementDetails != null && documentElementDetails.PageFormElements.Any() && !documentDetails.IsLinkForms)
      {
        foreach (var pageFormElement in documentElementDetails.PageFormElements)
        {
          if (pageFormElement.FormElements.Any())
          {
            foreach (var formElement in pageFormElement.FormElements)
            {
              // Resetting the fields IsDeleted as false
              formElement.IsDeleted = false;
              formElement.IsNewField = false;
              if (formElement.ElementType.ToUpperInvariant() == AttachmentField)
              {
                formElement.Value = formElement.AttachmentInfo.Title + AttachmentFieldValue;
                formElement.AttachmentDetails = Array.Empty<AttachmentDetails>();
              }
              else if (formElement.Value != null && !formElement.ElementType.IsEqual(LabelField) && !formElement.ElementType.IsEqual(NameField) && !formElement.ElementType.IsEqual(EmailField) && !(documentDetails.IsSelfSign && formElement.ElementType.IsEqual(CheckBoxField)) && !formElement.ElementType.IsEqual(HyperLinkField) && formElement.IsReadOnly != true)
              {
                formElement.OriginalImageBounds = null;
                if (!documentDetails.IsTemplate)
                {
                  formElement.Value = formElement.ElementType.IsEqual(CheckBoxField) ? "off" : null;
                }
                else if (!formElement.ElementType.IsEqual(CheckBoxField))
                {
                  formElement.Value = null;
                }

                formElement.ScaledBounds = null;
              }

              if (formElement.Children != null && formElement.Children.Any() && formElement.ElementType.ToUpperInvariant() == RadioField && formElement.IsReadOnly != true)
              {
                foreach (var childElement in formElement.Children)
                {
                  if (!documentDetails.IsTemplate)
                  {
                    childElement.Value = "off";
                  }
                }
              }
            }
          }
        }
      }

      blobTasks.Add(this.documentContentService.UpdateDocumentElementDetailsAsync(documentElementDetails, documentDetails.Id));
      blobTasks.Add(this.extendedDocumentDetailsService.AddOrUpdateDocumentDetails(documentDetails));

      return Task.WhenAll(blobTasks);
    }

    private Task CloneDocumentsContainerAsync(BlobContainerClient sourceBlobContainer, BlobContainerClient cloneBlobContainer, DocumentDetails documentDetails, DocumentElementDetails documentElementDetails, bool includeFieldData)
    {
      var blobTasks = new List<Task>
      {
        this.CloneDocumentBlobsWithHierarchy(sourceBlobContainer, cloneBlobContainer, string.Empty, 0, string.Empty, null),
      };

      // Resetting the field elements
      if (documentElementDetails != null && documentElementDetails.PageFormElements.Any() && !documentDetails.IsLinkForms)
      {
        foreach (var pageFormElement in documentElementDetails.PageFormElements)
        {
          if (!pageFormElement.FormElements.Any())
          {
            continue;
          }

          foreach (var formElement in pageFormElement.FormElements)
          {
            // Resetting the fields IsDeleted as false
            formElement.IsDeleted = false;
            formElement.IsNewField = false;
            if (formElement.ElementType.ToUpperInvariant() == AttachmentField)
            {
              formElement.Value = formElement.AttachmentInfo.Title + AttachmentFieldValue;
              formElement.AttachmentDetails = Array.Empty<AttachmentDetails>();
            }
            else if (!includeFieldData || (this.IsIgnoredClonedElementType(formElement.ElementType.ToLowerInvariant()) && !documentDetails.IsTemplate))
            {
              formElement.OriginalImageBounds = null;
              formElement.Value = formElement.ElementType.IsEqual(CheckBoxField) ? "off" : null;
              formElement.ScaledBounds = null;
              if (!includeFieldData && formElement.Children != null && formElement.Children.Any() && formElement.ElementType.ToUpperInvariant() == RadioField)
              {
                foreach (var childElement in formElement.Children)
                {
                  childElement.Value = "off";
                }
              }
            }
          }
        }
      }

      blobTasks.Add(this.documentContentService.UpdateDocumentElementDetailsAsync(documentElementDetails, documentDetails.Id));
      blobTasks.Add(this.extendedDocumentDetailsService.AddOrUpdateDocumentDetails(documentDetails));

      return Task.WhenAll(blobTasks);
    }

    private async Task CloneDocumentBlobsWithHierarchy(BlobContainerClient sourceBlobContainer, BlobContainerClient cloneBlobContainer, string prefix, int index, string tempId, DocumentProperties[] documentProperties, bool hasDuplicateTemplateId = false)
    {
      List<Task> blobTasks = new List<Task>();

      var resultSegment = sourceBlobContainer.GetBlobsByHierarchyAsync(prefix: prefix, delimiter: "/")
        .AsPages(default, BlobRequestCount);

      // Used GetBlobsByHierarchyAsync since we need to identify whether the blob is inside prefix before getting the name and cloning it.
      await foreach (Azure.Page<BlobHierarchyItem> blobPage in resultSegment)
      {
        foreach (var item in blobPage.Values)
        {
          if (item.IsPrefix)
          {
            if (item.Prefix != $"{DbConstants.IndividualDocumentSigned}/")
            {
              blobTasks.Add(this.CloneDocumentBlobsWithHierarchy(sourceBlobContainer, cloneBlobContainer, item.Prefix, index, tempId, documentProperties, hasDuplicateTemplateId));
            }
          }
          else
          {
            BlobClient blob = sourceBlobContainer.GetBlobClient(item.Blob.Name);
            string mergeBlobName;
            string name = mergeBlobName = blob.Name;

            if (name.Contains("/", StringComparison.InvariantCulture))
            {
              name = item.Blob.Name.Split('/')[1];
            }

            if (string.IsNullOrEmpty(tempId))
            {
              // Clones only the PdfViwer image objects and DocumentClient
              if (name != DbConstants.Document && name != DbConstants.DocumentMerged && name != DbConstants.DocumentSigned && name != DbConstants.DocumentAuditTrail && name != DbConstants.DocumentElementDetailsCollectionId && name != DbConstants.IndividualDocumentAuditTrail && name != EvrotrustDocument)
              {
                BlobClient clonedBlob = cloneBlobContainer.GetBlobClient($"{blob.Name}");
                blobTasks.Add(CloneBlobAsync(blob, clonedBlob));
              }
            }
            else
            {
              if (!hasDuplicateTemplateId)
              {
                mergeBlobName = !mergeBlobName.Contains("/", StringComparison.InvariantCulture) && index > 0 && documentProperties.Any(x => x.OldDocumentId.IsEqual(tempId)) ? $"{documentProperties.FirstOrDefault(x => x.OldDocumentId.IsEqual(tempId)).DocumentId}/{mergeBlobName}" : mergeBlobName.Contains("/", StringComparison.InvariantCulture) ? GetUpdatedBobName(mergeBlobName, tempId, documentProperties, index, hasDuplicateTemplateId) : mergeBlobName;
              }
              else
              {
                mergeBlobName = !mergeBlobName.Contains("/", StringComparison.InvariantCulture) && index > 0 && documentProperties.Any(x => x.OldDocumentId.IsEqual(tempId)) ? $"{documentProperties.FirstOrDefault(x => x.OldDocumentId.IsEqual(tempId) && x.TemplateIndex == index).DocumentId}/{mergeBlobName}" : mergeBlobName.Contains("/", StringComparison.InvariantCulture) ? GetUpdatedBobName(mergeBlobName, tempId, documentProperties, index, hasDuplicateTemplateId) : mergeBlobName;
              }

              if (name != DbConstants.DocumentMerged && name != DbConstants.DocumentSigned && name != DbConstants.DocumentAuditTrail && name != DbConstants.DocumentMergedDetails && name != DbConstants.DocumentMergedText && name != DbConstants.DocumentElementDetailsCollectionId && name != DbConstants.IndividualDocumentAuditTrail && name != EvrotrustDocument)
              {
                BlobClient clonedBlob = cloneBlobContainer.GetBlobClient($"{mergeBlobName}");
                blobTasks.Add(CloneBlobAsync(blob, clonedBlob));
              }
            }
          }
        }
      }

      await Task.WhenAll(blobTasks).ConfigureAwait(false);
    }

    private static string GetUpdatedBobName(string mergeBlobName, string tempId, DocumentProperties[] documentProperties, int index, bool hasDuplicateTemplateId)
    {
      string id = mergeBlobName.Split('/')[0];
      string blobName = mergeBlobName.Split('/')[1];

      var document = documentProperties.FirstOrDefault(x => x.OldDocumentId.IsEqual(id) && x.TemplateParentId.IsEqual(tempId));

      if (hasDuplicateTemplateId)
      {
        document = documentProperties.FirstOrDefault(x => x.OldDocumentId.IsEqual(id) && x.TemplateParentId.IsEqual(tempId) && x.TemplateIndex == index);
      }

      if (document == null)
      {
        return blobName;
      }

      mergeBlobName = document.DocumentId + "/" + blobName;

      return mergeBlobName;
    }

    private async Task CloneThumbnailContainerAsync(BlobContainerClient sourceBlobContainer, BlobContainerClient cloneBlobContainer, int index, string tempId, DocumentProperties[] documentProperties, bool hasDuplicateTemplateId = false)
    {
      List<Task> blobTasks = new List<Task>();
      var resultSegment = sourceBlobContainer.GetBlobsAsync().AsPages(default, BlobRequestCount);

      // Travers through all the blobs present in the container and copy it to the new cloned container.
      await foreach (Azure.Page<BlobItem> blobPage in resultSegment)
      {
        foreach (BlobItem blobItem in blobPage.Values)
        {
          string mergeBlobName;
          string name = mergeBlobName = blobItem.Name;
          BlobClient sourceBlob = sourceBlobContainer.GetBlobClient($"{name}");
          if (string.IsNullOrEmpty(tempId))
          {
            BlobClient clonedBlob = cloneBlobContainer.GetBlobClient($"{name}");
            blobTasks.Add(CloneBlobAsync(sourceBlob, clonedBlob));
          }
          else
          {
            if (!hasDuplicateTemplateId)
            {
              mergeBlobName = !mergeBlobName.Contains("/", StringComparison.InvariantCulture) && index > 0 && documentProperties.Any(x => x.OldDocumentId.IsEqual(tempId)) ? $"{documentProperties.FirstOrDefault(x => x.OldDocumentId.IsEqual(tempId)).DocumentId}/{mergeBlobName}" : mergeBlobName.Contains("/", StringComparison.InvariantCulture) ? GetUpdatedBobName(mergeBlobName, tempId, documentProperties, index, hasDuplicateTemplateId) : mergeBlobName;
            }
            else
            {
              mergeBlobName = !mergeBlobName.Contains("/", StringComparison.InvariantCulture) && index > 0 && documentProperties.Any(x => x.OldDocumentId.IsEqual(tempId)) ? $"{documentProperties.FirstOrDefault(x => x.OldDocumentId.IsEqual(tempId) && x.TemplateIndex == index).DocumentId}/{mergeBlobName}" : mergeBlobName.Contains("/", StringComparison.InvariantCulture) ? GetUpdatedBobName(mergeBlobName, tempId, documentProperties, index, hasDuplicateTemplateId) : mergeBlobName;
            }

            BlobClient clonedBlob = cloneBlobContainer.GetBlobClient($"{mergeBlobName}");
            blobTasks.Add(CloneBlobAsync(sourceBlob, clonedBlob));
          }
        }
      }

      await Task.WhenAll(blobTasks).ConfigureAwait(false);
    }

    private async Task ManipulateAndCloneDocuments(IOrderedEnumerable<DocumentProperties> documentOrder, BlobContainerClient cloudBlobContainer, bool canDrawDocId, string organizationId)
    {
      using PdfDocument pdfDocument = new PdfDocument();

      await documentOrder.ParallelForEachAsync(
        async document =>
        {
          if (document.Order != -1)
          {
            BlobClient blob;
            BlobClient clonedDocumentBlob;

            if (string.IsNullOrEmpty(document.ParentId))
            {
              blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentClient);
              clonedDocumentBlob = cloudBlobContainer.GetBlobClient($"{DbConstants.Document}");
            }
            else
            {
              blob = cloudBlobContainer.GetBlobClient($"{document.DocumentId}/{DbConstants.DocumentClient}");
              clonedDocumentBlob = cloudBlobContainer.GetBlobClient($"{document.DocumentId}/{DbConstants.Document}");
            }

            await this.CreateDocumentBlobForClonedContainer(blob, clonedDocumentBlob, document.DocumentId, canDrawDocId, organizationId, CancellationToken.None).ConfigureAwait(false);
          }
        },
        maxDegreeOfParallelism: 10).ConfigureAwait(false);

      // if there is only one document and it is replaced, we need to create the document_merged blob since multiple upload will not be called when created in viewer.
      if (documentOrder.Count() == 1 && !string.IsNullOrEmpty(documentOrder.FirstOrDefault().ParentId))
      {
        var mergedContainer = cloudBlobContainer.GetBlobClient($"{DbConstants.DocumentMerged}");
        var clonedDocumentBlob = cloudBlobContainer.GetBlobClient($"{documentOrder.FirstOrDefault().DocumentId}/{DbConstants.Document}");
        BlobCopyFromUriOptions blobCopyFromUriOptions = new BlobCopyFromUriOptions();
        await mergedContainer.StartCopyFromUriAsync(clonedDocumentBlob.Uri, blobCopyFromUriOptions).ConfigureAwait(false);
      }
    }

    private async Task CreateDocumentBlobForClonedContainer(BlobClient clonedDocumentClientBlob, BlobClient clonedDocumentBlob, string clonedId, bool canDrawDocId, string organizationId, CancellationToken token)
    {
      MemoryStream documentStream = new MemoryStream();
      MemoryStream manipulatedDocStream = null;
      try
      {
        await this.CloudStorage.DownloadToStreamAsync(clonedDocumentClientBlob, documentStream, true, token).ConfigureAwait(false);
        documentStream.Position = 0;
        PdfDocument.EnableCache = false;
        using var pdfLoadedDocument = new PdfLoadedDocument(documentStream);
        pdfLoadedDocument.EnableMemoryOptimization = true;

        manipulatedDocStream = await this.ManipulatePDF(pdfLoadedDocument, null, clonedId, ContentType.PDF, string.Empty, organizationId, true, canDrawDocId).ConfigureAwait(false);
        byte[] documentArray = manipulatedDocStream.ToArray();

        // Upload the manipulated PDF document.
        await this.CloudStorage.UploadFromByteArrayAsync(clonedDocumentBlob, documentArray, 0, true, token).ConfigureAwait(false);
      }
      catch (PdfException ex)
      {
        this.logger.LogError(ex, ex.Message);
#pragma warning disable CA2200 // Rethrow to preserve stack details.
        throw ex;
#pragma warning restore CA2200 // Rethrow to preserve stack details.
      }
      finally
      {
        documentStream.Dispose();
        manipulatedDocStream?.Dispose();
      }
    }

    private async Task DrawDocumentFields(DocumentElementDetails documentFormFields, PdfLoadedDocument loadedDocument, bool isSeparateDownload = false, int pageIndex = 1, int endIndex = 1, bool isPrintSignDocument = false)
    {
      var pageFormElements = isSeparateDownload
        ? documentFormFields.PageFormElements.Where(x =>
          (x.PageIndex >= pageIndex && x.PageIndex <= endIndex) ||
          x.FormElements.Any(y =>
            y.ElementType.Equals(RadioField, StringComparison.OrdinalIgnoreCase) &&
            y.Children.Any(z => z.PageIndex >= pageIndex && z.PageIndex <= endIndex)))
        : documentFormFields.PageFormElements;

      foreach (var pageFields in pageFormElements)
      {
        var currentPageIndex = pageFields.PageIndex - pageIndex;
        PdfPageBase loadedPage = null;
        if (isSeparateDownload && (currentPageIndex < 0 || currentPageIndex > endIndex || currentPageIndex >= loadedDocument.PageCount) && pageFields.FormElements.Any())
        {
          pageFields.FormElements = pageFields.FormElements.Where(x => x.ElementType.ToUpperInvariant() == RadioField)
            .ToArray();
        }
        else
        {
          loadedPage = loadedDocument.Pages[pageFields.PageIndex - pageIndex];
        }

        var pdfUnitConverter = new PdfUnitConverter();
        foreach (var field in pageFields.FormElements)
        {
          // The deleted fields should not be added.
          if (!field.IsDeleted)
          {
            var elementType = field.ElementType.ToUpperInvariant();
            switch (elementType)
            {
              case SignatureField:
              case InitialField:
              case ImageField:
                {
                  if (!string.IsNullOrEmpty(field.Value))
                  {
                    var signatureImage = field.Value.Base64StringToBitmap();
                    var signatureBounds = new Syncfusion.Drawing.RectangleF(
                      pdfUnitConverter.ConvertFromPixels(field.ScaledBounds.X, PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.ScaledBounds.Y, PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.ScaledBounds.Width, PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.ScaledBounds.Height, PdfGraphicsUnit.Point));
                    loadedPage.Graphics.DrawImage(signatureImage, signatureBounds);
                  }

                  break;
                }

              case CheckBoxField:
                {
                  var checkboxField = new PdfCheckBoxField(loadedPage, field.Id)
                  {
                    Bounds = new Syncfusion.Drawing.RectangleF(
                      pdfUnitConverter.ConvertFromPixels(field.Bounds.X, PdfGraphicsUnit.Point) + pdfUnitConverter.ConvertFromPixels(field.PaddingLeft, PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.Bounds.Y, PdfGraphicsUnit.Point) + pdfUnitConverter.ConvertFromPixels(field.PaddingTop, PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.Bounds.Width - (field.PaddingLeft + field.PaddingRight), PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.Bounds.Height - (field.PaddingTop + field.PaddingBottom), PdfGraphicsUnit.Point)),
                  };

                  if (!string.IsNullOrEmpty(field.Value) && field.Value.ToUpperInvariant() == "ON")
                  {
                    checkboxField.Checked = true;
                  }

                  if (loadedDocument.Form == null)
                  {
                    loadedDocument.CreateForm();
                  }

                  loadedDocument.Form.Fields.Add(checkboxField);
                  loadedDocument.Form.Flatten = true;
                  break;
                }

              case TextBoxField:
              case AttachmentField:
              case LabelField:
              case DropDownField:
              case DatePickerField:
              case EditableDateField:
              case EmailField:
              case CompanyField:
              case TitleField:
              case NameField:
              case FormulaField:
                {
                  if (elementType == LabelField && !string.IsNullOrEmpty(field.BackgroundColor))
                  {
                    var rectangleBounds = this.GetTextBounds(field, pdfUnitConverter, 0, true);

                    PdfBrush backgroundBrush = new PdfSolidBrush(HexToPdfColor(field.BackgroundColor));
                    loadedPage.Graphics.DrawRectangle(backgroundBrush, rectangleBounds);
                  }

                  if (!string.IsNullOrEmpty(field.Value))
                  {
                    if (elementType is AttachmentField && (field.AttachmentDetails == null || !field.AttachmentDetails.Any()))
                    {
                      break;
                    }

                    float lineSpacing = 0;
                    if (field.LineHeight > 0)
                    {
                      // The orginal line height in viewer include font size and 2 extra pixels so performed the belwo operation.
                      lineSpacing = pdfUnitConverter.ConvertFromPixels(field.LineHeight - 2, PdfGraphicsUnit.Point) - pdfUnitConverter.ConvertFromPixels(field.FontSize, PdfGraphicsUnit.Point);
                    }

                    var textBounds = this.GetTextBounds(field, pdfUnitConverter, lineSpacing);

                    var fontStyle = GetFontStyle(field.FontStyle, field.FontWeight, field.TextDecoration);

                    PdfBrush textBrush = new PdfSolidBrush(HexToPdfColor(field.FontColor));

                    var font = await GetFieldFontAsync(field.Value, field.FontFamily, fontStyle, pdfUnitConverter.ConvertFromPixels(field.FontSize, PdfGraphicsUnit.Point)).ConfigureAwait(false);

                    var format = GetTextAlignment(field.ElementType.ToUpperInvariant(), field.TextAlign);
                    if (elementType is TextBoxField or LabelField)
                    {
                      format.CharacterSpacing = pdfUnitConverter.ConvertFromPixels(field.CharacterSpacing, PdfGraphicsUnit.Point);
                    }

                    // Added line height to the field.
                    format.LineSpacing = lineSpacing;
                    format.TextDirection = PdfTextDirection.LeftToRight;
                    if (field.TextDirection == BoldSign.Base.Models.TextDirection.RTL)
                    {
                      format.TextDirection = PdfTextDirection.RightToLeft;
                      format.Alignment = PdfTextAlignment.Right;
                    }

                    var size = font.MeasureString(field.Value, new Syncfusion.Drawing.SizeF(textBounds.Width, 0), format);
                    if (textBounds.Height < size.Height)
                    {
                      textBounds.Height = size.Height;
                    }

                    loadedPage.Graphics.DrawString(field.Value, font, textBrush, textBounds, format);
                  }

                  break;
                }

              case RadioField:
                {
                  if (field.Children.Any())
                  {
                    var oldLoadedPage = loadedPage;
                    var groupedRadioButtons = isSeparateDownload ? field.Children.Where(x => (x.PageIndex >= pageIndex && x.PageIndex <= endIndex) || x.PageIndex == 0).GroupBy(y => y.PageIndex).OrderBy(g => g.Key) : field.Children.GroupBy(y => y.PageIndex).OrderBy(g => g.Key);

                    foreach (var groupedRadio in groupedRadioButtons)
                    {
                      if (isSeparateDownload && groupedRadio.Key == 0 && (currentPageIndex < 0 || currentPageIndex > endIndex || currentPageIndex >= loadedDocument.PageCount))
                      {
                        continue;
                      }

                      loadedPage = groupedRadio.Key != 0 ? loadedDocument.Pages[groupedRadio.Key - pageIndex] : loadedDocument.Pages[pageFields.PageIndex - pageIndex];
                      var radioButtonListField = new PdfRadioButtonListField(loadedPage, field.Id);
                      foreach (var child in groupedRadio)
                      {
                        var radioButtonItem = new PdfRadioButtonListItem(child.Id);
                        var x = child.Bounds.X + child.PaddingLeft;
                        var y = child.Bounds.Y + child.PaddingTop;
                        var width = child.Bounds.Width - (child.PaddingLeft + child.PaddingRight);
                        var height = child.Bounds.Height - (child.PaddingTop + child.PaddingBottom);

                        // if width and height is not same the radio button downloaded will be distorted, so assigning the height to width for the purpose of downloading without distortion in radio field.
                        if (width != height)
                        {
                          width = height;
                        }

                        radioButtonItem.Bounds = new Syncfusion.Drawing.RectangleF(
                          pdfUnitConverter.ConvertFromPixels(x, PdfGraphicsUnit.Point),
                          pdfUnitConverter.ConvertFromPixels(y, PdfGraphicsUnit.Point),
                          pdfUnitConverter.ConvertFromPixels(width, PdfGraphicsUnit.Point),
                          pdfUnitConverter.ConvertFromPixels(height, PdfGraphicsUnit.Point));

                        radioButtonListField.Items.Add(radioButtonItem);

                        if (!string.IsNullOrEmpty(child.Value) && child.Value.Equals("ON", StringComparison.OrdinalIgnoreCase))
                        {
                          radioButtonListField.SelectedIndex = groupedRadio.ToList().IndexOf(child);
                        }
                      }

                      if (loadedDocument.Form == null)
                      {
                        loadedDocument.CreateForm();
                      }

                      loadedDocument.Form.Fields.Add(radioButtonListField);
                      loadedDocument.Form.Flatten = true;
                      loadedPage = oldLoadedPage;
                    }
                  }

                  break;
                }

              case HyperLinkField:
                {
                  if (!string.IsNullOrEmpty(field.Value) && !isPrintSignDocument)
                  {
                    float lineSpacing = 0;
                    if (field.LineHeight > 0)
                    {
                      // The orginal line height in viewer include font size and 2 extra pixels so performed the belwo operation.
                      lineSpacing = pdfUnitConverter.ConvertFromPixels(field.LineHeight - 2, PdfGraphicsUnit.Point) - pdfUnitConverter.ConvertFromPixels(field.FontSize, PdfGraphicsUnit.Point);
                    }

                    var textBounds = new Syncfusion.Drawing.PointF(
                      pdfUnitConverter.ConvertFromPixels(field.Bounds.X + field.PaddingLeft, PdfGraphicsUnit.Point),
                      pdfUnitConverter.ConvertFromPixels(field.Bounds.Y + field.PaddingTop, PdfGraphicsUnit.Point));

                    var fontStyle = GetFontStyle(field.FontStyle, field.FontWeight, field.TextDecoration);

                    var textLink = new PdfTextWebLink
                    {
                      Brush = new PdfSolidBrush(HexToPdfColor(field.FontColor)),
                      Font = await GetFieldFontAsync(field.Value, field.FontFamily, fontStyle, pdfUnitConverter.ConvertFromPixels(field.FontSize, PdfGraphicsUnit.Point)).ConfigureAwait(false),
                      StringFormat = new PdfStringFormat(PdfTextAlignment.Left, PdfVerticalAlignment.Top)
                      {
                        LineSpacing = lineSpacing,
                      },
                      Url = field.Value,
                      Text = field.Label,
                    };

                    textLink.DrawTextWebLink(loadedPage.Graphics, textBounds);
                  }

                  break;
                }

              default:
                break;
            }
          }
        }
      }
    }

    private static async Task<PdfFont> GetFieldFontAsync(string text, string fontFamily, PdfFontStyle fontStyle, float fontSize)
    {
      if (IsArabicText(text))
      {
        // Arial is used to render Arabic
        string fontPath = fontStyle switch
        {
          PdfFontStyle.Regular => CommonResource.ArialRegularFontPath,
          PdfFontStyle.Bold => CommonResource.ArialBoldFontPath,
          PdfFontStyle.Italic => CommonResource.ArialItalicFontPath,
          PdfFontStyle.Bold | PdfFontStyle.Italic => CommonResource.ArialBoldItalicFontPath,
          PdfFontStyle.Underline | PdfFontStyle.Italic => CommonResource.ArialItalicFontPath,
          PdfFontStyle.Underline | PdfFontStyle.Bold => CommonResource.ArialBoldFontPath,
          PdfFontStyle.Bold | PdfFontStyle.Italic | PdfFontStyle.Underline => CommonResource.ArialBoldItalicFontPath,
          PdfFontStyle.Underline => CommonResource.ArialRegularFontPath,
          _ => CommonResource.ArialRegularFontPath,
        };

        return new PdfTrueTypeFont(new MemoryStream(await File.ReadAllBytesAsync(fontPath).ConfigureAwait(false)), fontSize, fontStyle);
      }
      else if (IsSimplifiedChineseText(text))
      {
        return new PdfCjkStandardFont(PdfCjkFontFamily.SinoTypeSongLight, fontSize, fontStyle);
      }
      else if (IsTraditionalChineseText(text))
      {
        return new PdfCjkStandardFont(PdfCjkFontFamily.MonotypeHeiMedium, fontSize, fontStyle);
      }
      else if (IsJapaneseText(text))
      {
        return new PdfCjkStandardFont(PdfCjkFontFamily.HeiseiMinchoW3, fontSize, fontStyle);
      }
      else if (IsKoreanText(text))
      {
        return new PdfCjkStandardFont(PdfCjkFontFamily.HanyangSystemsShinMyeongJoMedium, fontSize, fontStyle);
      }
      else if (IsHebrewText(text))
      {
        string fontPath = fontStyle switch
        {
          PdfFontStyle.Regular => CommonResource.NotoSansHebrewRegularFontPath,
          PdfFontStyle.Bold => CommonResource.NotoSansHebrewBoldFontPath,
          _ => CommonResource.NotoSansHebrewRegularFontPath
        };

        return new PdfTrueTypeFont(new MemoryStream(await File.ReadAllBytesAsync(fontPath).ConfigureAwait(false)), fontSize, fontStyle);
      }
      else if (!fontFamily.ToUpperInvariant().IsEqual(NotoSansFont) && IsNotBasicLatinLanguage(text))
      {
        string fontPath = fontStyle switch
        {
          PdfFontStyle.Regular => CommonResource.LiberationRegularPath,
          PdfFontStyle.Bold => CommonResource.LiberationBoldPath,
          PdfFontStyle.Italic => CommonResource.LiberationItalicPath,
          PdfFontStyle.Bold | PdfFontStyle.Italic => CommonResource.LiberationBoldItalicPath,
          PdfFontStyle.Underline | PdfFontStyle.Italic => CommonResource.LiberationItalicPath,
          PdfFontStyle.Underline | PdfFontStyle.Bold => CommonResource.LiberationBoldPath,
          PdfFontStyle.Bold | PdfFontStyle.Italic | PdfFontStyle.Underline => CommonResource.LiberationBoldItalicPath,
          PdfFontStyle.Underline => CommonResource.LiberationRegularPath,
          _ => CommonResource.LiberationRegularPath,
        };

        return new PdfTrueTypeFont(new MemoryStream(await File.ReadAllBytesAsync(fontPath).ConfigureAwait(false)), fontSize, fontStyle);
      }

      PdfFont pdfFont = fontFamily.ToUpperInvariant() switch
      {
        HelveticaFont => new PdfStandardFont(PdfFontFamily.Helvetica, fontSize, fontStyle),
        CourierFont => new PdfStandardFont(PdfFontFamily.Courier, fontSize, fontStyle),
        TimesNewRomanFont => new PdfStandardFont(PdfFontFamily.TimesRoman, fontSize, fontStyle),
        NotoSansFont => new PdfTrueTypeFont(new MemoryStream(await File.ReadAllBytesAsync(GetNotoSansPath(fontStyle)).ConfigureAwait(false)), fontSize, fontStyle),
        _ => new PdfStandardFont(PdfFontFamily.Helvetica, fontSize, fontStyle),
      };

      return pdfFont;
    }

    private static PdfStringFormat GetTextAlignment(string elementType, BoldSign.Base.Models.TextAlign textAlign)
    {
      PdfTextAlignment alignment = PdfTextAlignment.Left;
      if (elementType == TextBoxField || elementType == LabelField || elementType == FormulaField)
      {
        alignment = textAlign switch
        {
          BoldSign.Base.Models.TextAlign.Right => PdfTextAlignment.Right,
          BoldSign.Base.Models.TextAlign.Center => PdfTextAlignment.Center,
          _ => PdfTextAlignment.Left
        };
      }

      if (elementType == DropDownField || elementType == AttachmentField)
      {
        return new PdfStringFormat(alignment, PdfVerticalAlignment.Middle);
      }

      return new PdfStringFormat(alignment, PdfVerticalAlignment.Top);
    }

    private static bool IsArabicText(string text)
    {
      if (text.Any(x => x > 0x0600 && x < 0x06FF) || // Arabic script
          text.Any(x => x > 0x0750 && x < 0x077F) || // Arabic Supplement script
          text.Any(x => x > 0x08A0 && x < 0x08FF) || // Arabic Extended-A script
          text.Any(x => x > 0xFB50 && x < 0xFDFF) || // Arabic Presentation Forms-A script
          text.Any(x => x > 0xFE70 && x < 0xFEFF) || // Arabic Presentation Forms-B script
          text.Any(x => x > 0x1EE00 && x < 0x1EEFF)) // Arabic Mathematical Alphabetic Symbols script
      {
        return true;
      }

      return false;
    }

    private static bool IsSimplifiedChineseText(string text)
    {
      // This range includes most characters used in Simplified Chinese.
      return text.Any(x =>
          (x >= 0x4E00 && x <= 0x9FFF) || // CJK Unified Ideographs
          (x >= 0x3400 && x <= 0x4DBF) || // CJK Unified Ideographs Extension A
          (x >= 0x20000 && x <= 0x2A6DF) || // CJK Unified Ideographs Extension B
          (x >= 0x2A700 && x <= 0x2B73F)); // CJK Unified Ideographs Extension C (used in both Simplified and Traditional)
    }

    private static bool IsTraditionalChineseText(string text)
    {
      // This range includes most characters used in Traditional Chinese.
      return text.Any(x =>
          (x >= 0x4E00 && x <= 0x9FFF) || // CJK Unified Ideographs (used for both Simplified and Traditional)
          (x >= 0x3400 && x <= 0x4DBF) || // CJK Unified Ideographs Extension A
          (x >= 0x20000 && x <= 0x2A6DF) || // CJK Unified Ideographs Extension B
          (x >= 0x2F800 && x <= 0x2FA1F) || // CJK Compatibility Ideographs Supplement (mostly used in Traditional)
          (x >= 0xF900 && x <= 0xFAFF)); // CJK Compatibility Ideographs (mostly used in Traditional)
    }

    private static bool IsKoreanText(string text)
    {
      return text.Any(x =>
          (x >= 0xAC00 && x <= 0xD7AF) || // Hangul Syllables (Korean)
          (x >= 0x1100 && x <= 0x11FF) || // Hangul Jamo (Korean)
          (x >= 0x3130 && x <= 0x318F));   // Hangul Compatibility Jamo (Korean)
    }

    private static bool IsJapaneseText(string text)
    {
      return text.Any(x =>
          (x >= 0x3040 && x <= 0x309F) || // Hiragana
          (x >= 0x30A0 && x <= 0x30FF) || // Katakana
          (x >= 0x4E00 && x <= 0x9FFF) || // CJK Unified Ideographs (Kanji, shared with Chinese)
          (x >= 0x3400 && x <= 0x4DBF) || // CJK Unified Ideographs Extension A
          (x >= 0x20000 && x <= 0x2A6DF) || // CJK Unified Ideographs Extension B
          (x >= 0xFF65 && x <= 0xFF9F));   // Halfwidth Katakana
    }

    private static bool IsHebrewText(string text)
    {
      if (text.Any(x => x > 0x0590 && x < 0x05FF) || // Hebrew script
          text.Any(x => x > 0xFB1D && x < 0xFB4F)) // Hebrew Presentation Forms script
      {
        return true;
      }

      return false;
    }

    private static string GetNotoSansPath(PdfFontStyle fontStyle)
    {
      string notoSansPath = fontStyle switch
      {
        PdfFontStyle.Regular => CommonResource.NotoSansRegularPath,
        PdfFontStyle.Bold => CommonResource.NotoSansBoldPath,
        PdfFontStyle.Italic => CommonResource.NotoSansItalicPath,
        PdfFontStyle.Bold | PdfFontStyle.Italic => CommonResource.NotoSansBoldItalicPath,
        PdfFontStyle.Underline | PdfFontStyle.Italic => CommonResource.NotoSansItalicPath,
        PdfFontStyle.Underline | PdfFontStyle.Bold => CommonResource.NotoSansBoldPath,
        PdfFontStyle.Bold | PdfFontStyle.Italic | PdfFontStyle.Underline => CommonResource.NotoSansBoldItalicPath,
        PdfFontStyle.Underline => CommonResource.NotoSansRegularPath,
        _ => CommonResource.NotoSansRegularPath,
      };
      return notoSansPath;
    }

    private static bool IsNotBasicLatinLanguage(string text)
    {
      return text.Any(x => x > BasicLatinMaxRange || x < BasicLatinMinRange);
    }

    private async Task<MemoryStream> ManipulatePDF(PdfLoadedDocument loadedDocument, DocumentProgress documentProgress, string documentId, ContentType contentType, string subDocumentId, string organizationId, bool isCloneProcess = false, bool canDrawDocId = false)
    {
      MemoryStream manipulatedDocumentStream = null;
      loadedDocument.FileStructure.IncrementalUpdate = false;
      if (loadedDocument.IsPortfolio)
      {
        throw new PdfException(string.Format(CultureInfo.InvariantCulture, Constants.Portfolio));
      }

      if (loadedDocument.Form != null && loadedDocument.Form.Fields.Count > 0)
      {
        loadedDocument.Form.Flatten = true;
      }

      if (loadedDocument.IsEncrypted)
      {
        loadedDocument.Security.OwnerPassword = string.Empty;
        loadedDocument.Security.Permissions = PdfPermissionsFlags.Default;
      }

      loadedDocument.DocumentInformation.Title = string.Empty;
      loadedDocument.DocumentInformation.Creator =
        Constants.SyncfusionPdfLibrary + " - " + Constants.PdfLibraryLink;
      loadedDocument.DocumentInformation.Producer = Constants.SyncfusionPdfLibrary;
      loadedDocument.DocumentInformation.AddCustomMetaDataInfo(CommonResource.DocumentIdMetaData, documentId);

      if (loadedDocument.Layers != null)
      {
        var layerCount = loadedDocument.Layers.Count;
        for (var i = layerCount - 1; i >= 0; i--)
        {
          loadedDocument.Layers.Remove(loadedDocument.Layers[i], false);
        }
      }

      int loadedPageCount = loadedDocument.Pages.Count;
      if (contentType != ContentType.Images)
      {
        string pageCountPattern = string.Format(CultureInfo.InvariantCulture, $"\n{Constants.PageCount} : {loadedPageCount.ToString(CultureInfo.InvariantCulture)}\n {Constants.IsTaggedPdf} : {loadedDocument.FileStructure?.TaggedPdf}");
        if (!isCloneProcess)
        {
          await this.UpdateUploadProgress(pageCountPattern, false).ConfigureAwait(false);
        }
      }

      string docIdText = string.Empty;

      if (canDrawDocId)
      {
        docIdText = CommonResource.DocumentIdText + documentId;
      }

      var uploadTasks = new List<Task>();
      for (var i = 0; i < loadedPageCount; i++)
      {
        var loadedPage = loadedDocument.Pages[i];
        loadedPage.Annotations.Flatten = true;

        if (canDrawDocId)
        {
          DrawDocumentId(loadedPage, docIdText);
        }

        if (!isCloneProcess && loadedDocument.FileStructure.TaggedPdf)
        {
          uploadTasks.Add(this.UploadTaggedPdfContent(loadedDocument, documentId, subDocumentId, i, organizationId));
        }
      }

      await Task.WhenAll(uploadTasks).ConfigureAwait(false);
      void PdfHandler(object sender, ProgressEventArgs arguments)
      {
        if (documentProgress != null)
        {
          _ = documentProgress.UpdateOverallProgress(arguments.Progress * 100);
        }
      }

      if (!isCloneProcess)
      {
        loadedDocument.SaveProgress += PdfHandler;
      }

      manipulatedDocumentStream = new MemoryStream();
      loadedDocument.Save(manipulatedDocumentStream);
      loadedDocument.SaveProgress -= PdfHandler;
      return manipulatedDocumentStream;
    }

    private async Task<BlobClient> UploadPdfViewerObjects(string childId, string organizationId, DocumentProgress documentProgress, Stream manipulatedDocumentStream, BlobContainerClient cloudBlobContainer, string parentId, string scannedBlobName, DocumentDetails documentDetails, float zoomFactor, CancellationToken cancellationToken)
    {
      var thumbnailCloudBlobContainer = await this.CloudStorage
        .GetContainer($"{parentId}-{DbConstants.Thumbnails}", organizationId).ConfigureAwait(false);

      BlobClient blobClient = null;
      PdfRenderer renderer = null;
      try
      {
#pragma warning disable CA2000 // Dispose objects before losing scope
        renderer = new PdfRenderer();
#pragma warning restore CA2000 // Dispose objects before losing scope

        var pageDetails = renderer.LoadDocument(manipulatedDocumentStream, null, out var documentPtr); // await Task.FromResult(renderer.LoadDocument(manipulatedDocumentStream, null, out var documentPtr)).ConfigureAwait(false);
        var pageCount = pageDetails.Count;
        var pdfViewerLoadObject = new PdfViewerLoadDetails
        {
          PageCount = pageDetails.Count,
          PageSizes = pageDetails,
          DocumentLiveCount = 1,
        };
        documentProgress.Reset();

        var exportProgress = 0;
        documentProgress.Reset();
        var pageTask = new Task[pageCount];
        var webpTask = new Task[pageCount];
        for (int i = 0; i < pageCount; i++)
        {
          cancellationToken.ThrowIfCancellationRequested();
          SizeF pageSize = pageDetails[i];
          var pagePtr = PdfiumViewer.FPDF_LoadPage(documentPtr, i);

#pragma warning disable CA2000 // Dispose objects before losing scope
          var pageContent = PdfExport.ExportImage(pagePtr, zoomFactor, pageSize);
#pragma warning restore CA2000 // Dispose objects before losing scope

          if (!string.IsNullOrEmpty(scannedBlobName))
          {
            var message = $"Processing page {i + 1} 0f {pageCount}";
            await this.UpdateUploadProgress(message, false).ConfigureAwait(false);

            pageContent = await this.imageUtilityService.CompareAndDeSkewImage(
              pageContent, i, documentDetails, pdfViewerLoadObject).ConfigureAwait(false);
          }

          byte[] imageSerialized = BinarySerializer.Serialize(new PdfViewerImage
          {
            PngBytes = pageContent.PngBytes,
            ScaleFactor = pageContent.ScaleFactor,
          });
#pragma warning disable CA2000 // This object will be disposed asynchronously after the upload is completed
          var thumbnailContent = PdfExport.ExportPageAsThumbnail(pagePtr);
#pragma warning restore CA2000 // This object will be disposed asynchronously after the upload is completed
          var thumbnailBlobClient = thumbnailCloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Thumbnail}-{i}.png");
          thumbnailContent.Position = 0;

#pragma warning disable CA2008 // Do not create tasks without passing a TaskScheduler
          _ = thumbnailBlobClient.UploadAsync(thumbnailContent)
            .ContinueWith(
              async x =>
              {
                if (x.IsCompleted)
                {
                  await thumbnailContent.DisposeAsync().ConfigureAwait(false);
                }
              })
            .ConfigureAwait(false);
#pragma warning restore CA2008 // Do not create tasks without passing a TaskScheduler

          webpTask[i] = this.UploadWebPToBlob(childId, scannedBlobName, pageContent.WebPBytes, i, cloudBlobContainer, zoomFactor);

          // Upload page image with pattern, page-[page-number]-[zoom-factor].
          var blockBlob = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Page}-{i}-{zoomFactor}");

#pragma warning disable CA2008 // Do not create tasks without passing a TaskScheduler
          pageTask[i] = this.CloudStorage.UploadFromByteArrayAsync(blockBlob, imageSerialized, 0, false)
            .ContinueWith(
              x =>
              {
                pageContent.Dispose();
                imageSerialized = null;
              });
#pragma warning restore CA2008 // Do not create tasks without passing a TaskScheduler

          // The Interlocked usage is essential to avoid getting race-conditions.
          Interlocked.Increment(ref exportProgress);

          // Progress is updated until last before page of the document
          if (exportProgress < pageCount)
          {
            await documentProgress.UpdateUploadProgress(exportProgress, pageCount).ConfigureAwait(false);
            pageContent.Dispose();
          }

          PdfiumViewer.FPDF_ClosePage(pagePtr);
        }

        await Task.WhenAll(pageTask).ConfigureAwait(false);

        // Upload PDF viewer load object e.g. page count and page sizes.
        blobClient = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.DocumentDetails}");
        byte[] bytes = BinarySerializer.Serialize(pdfViewerLoadObject);

        await this.CloudStorage.UploadFromByteArrayAsync(blobClient, bytes, 0, false).ContinueWith(x => bytes = null, TaskScheduler.Current).ConfigureAwait(false);

        // Last page progress is updated after completeion of all upload tasks
        await documentProgress.UpdateUploadProgress(exportProgress, pageCount).ConfigureAwait(false);

        PdfiumViewer.FPDF_CloseDocument(documentPtr);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, ex.Message);

        throw;
      }
      finally
      {
        renderer?.Dispose(renderer.PdfDocumentId);
      }

      return blobClient;
    }

    private async Task UploadDirectImageToBlob(Stream imageStream, BlobContainerClient cloudBlobContainer, BlobContainerClient thumbnailCloudBlobContainer, string childId, SizeF imageSize, DocumentProgress documentProgress, float zoomFactor)
    {
      List<Task> pageTask = new List<Task>();
      var pageDetails = new Dictionary<int, SizeF>();
      pageDetails.Add(0, imageSize);
      var pdfViewerLoadObject = new PdfViewerLoadDetails
      {
        PageCount = 1,
        PageSizes = pageDetails,
        DocumentLiveCount = 1,
      };

      documentProgress.Reset();
      imageStream.Position = 0;
      using BinaryReader binaryReader = new BinaryReader(imageStream);
      byte[] imageArray = binaryReader.ReadBytes((int)imageStream.Length);

      // Upload PDF viewer load object e.g. page count and page sizes.
      var blobClient = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentDetails}");
      byte[] bytes = BinarySerializer.Serialize(pdfViewerLoadObject);
      pageTask.Add(this.CloudStorage.UploadFromByteArrayAsync(blobClient, bytes, 0, false));

      using var imageObject = new PdfViewerImage();
      imageObject.PngBytes = imageArray;
      imageObject.ScaleFactor = PdfExport.Scale;

      // Uplaoding the image as PdfViewerImage object in the blob.
      byte[] imageSerialized = BinarySerializer.Serialize(imageObject);
      var blockBlob = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.Page}-{0}-{zoomFactor}");
      pageTask.Add(this.CloudStorage.UploadFromByteArrayAsync(blockBlob, imageSerialized, 0, false));

      // Creating thumbnail for the uploaded image.
      var thumbnailContent = GenerateThumbnailImage(imageStream);

      // Uploading the Thumbnail image diretly in the thumbnail container
      var thumbnailBlobClient = thumbnailCloudBlobContainer.GetBlobClient($"{childId}{DbConstants.Thumbnail}-{0}.png");
      _ = this.CloudStorage.UploadFromByteArrayAsync(thumbnailBlobClient, thumbnailContent, 0, false).ConfigureAwait(false);

      // Creating webp image for the uploaded image and uploaded in the blob.
      pageTask.Add(this.ConvertAndUploadImageToWebP(childId, string.Empty, imageObject, 0, cloudBlobContainer, zoomFactor));

      // Updating the upload progress.
      await documentProgress.UpdateUploadProgress(1, 1).ConfigureAwait(false);

      documentProgress.Reset();
      await Task.WhenAll(pageTask).ConfigureAwait(false);
    }

    private async Task<DocumentDetails> GetPrintSignDocumentDetails(HttpContext context, int pageCount, IDocumentUploadDetails documentUploadDetails)
    {
      var documentDetails = GetDocumentDetailsCache(context);

      if (documentDetails == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      int sourcePageCount = documentDetails.DocumentProperties.Select(x => x.PageCount).Sum();

      if (pageCount != sourcePageCount)
      {
        throw new InvalidDataException(CommonResource.PageCountMisMatch);
      }

      documentDetails.PrintSignDocumentName = documentUploadDetails.DocumentName;
      _ = this.UpdateDocumentDetailsAsync(documentDetails);
      await this.UpdateUploadProgress($"Uploading Sacnned document".ToInvariantCulture(), false).ConfigureAwait(false);
      return documentDetails;
    }

    private async Task PerformBlobReplaceOperation(BlobContainerClient sourceBlobContainer)
    {
      if (sourceBlobContainer is null)
      {
        throw new ArgumentNullException(nameof(sourceBlobContainer));
      }

      string scannedBlobName = $"{DbConstants.ScannedDocument}/";

      List<Task> blobTasks = new List<Task>();

      // Enumerated using AsPages since we need to get all the list of blobs and traverse in 2 foreeach loops after that.
      async static Task DeleteReplaceBlobs(BlobContainerClient sourceBlobContainer, string prefix, string scannedBlobName, List<Task> blobTasks)
      {
        await foreach (Azure.Page<BlobHierarchyItem> blobPage in sourceBlobContainer.GetBlobsByHierarchyAsync(BlobTraits.None, BlobStates.None, "/", prefix).AsPages(default, BlobRequestCount))
        {
          // Deleting all the blobs which exist in main container and deleting sub directory blobs except scanned document blobs.
          foreach (var blobItem in blobPage.Values)
          {
            if (blobItem.IsBlob && blobItem.Blob.Name != DbConstants.DocumentContentCollectionId && blobItem.Blob.Name != DbConstants.DocumentElementDetailsCollectionId)
            {
              blobTasks.Add(sourceBlobContainer.DeleteBlobAsync(blobItem.Blob.Name));
            }
            else if (!blobItem.IsBlob && (string.IsNullOrEmpty(blobItem.Prefix) || !blobItem.Prefix.IsEqual(scannedBlobName)))
            {
              blobTasks.Add(DeleteReplaceBlobs(sourceBlobContainer, blobItem.Prefix, scannedBlobName, blobTasks));
            }
          }
        }

        await Task.WhenAll(blobTasks).ConfigureAwait(false);
        blobTasks.RemoveRange(0, blobTasks.Count);
      }

      await DeleteReplaceBlobs(sourceBlobContainer, string.Empty, scannedBlobName, blobTasks).ConfigureAwait(false);

      // Copy all the blobs from scanned document directory to main directory
      await foreach (var blobPage in sourceBlobContainer.GetBlobsByHierarchyAsync(BlobTraits.None, BlobStates.None, "/", $"{DbConstants.ScannedDocument}/").AsPages(default, BlobRequestCount))
      {
        foreach (var blob in blobPage.Values)
        {
          BlobClient sourceBlob = sourceBlobContainer.GetBlobClient(blob.Blob.Name);
          string name = blob.Blob.Name.Split('/')[1];
          BlobClient newBlob = sourceBlobContainer.GetBlobClient($"{name}");
          blobTasks.Add(CloneBlobAsync(sourceBlob, newBlob));
        }
      }

      await Task.WhenAll(blobTasks).ConfigureAwait(false);
    }

    private string UpdateOldSignerIdDetails(DocumentDetails documentDetails)
    {
      var lastSignedSignerId = string.Empty;

      var currentSignerId = GetSignerIdCache(this.httpContext);
      var combinedSigner = DocumentDetailsReader.GetCombinedSignerDetails(documentDetails.SignerDetails);
      foreach (var iSignerDetail in combinedSigner)
      {
        var signerDetail = iSignerDetail as BoldSign.Base.Models.SignerDetails;
        string oldSignerId = signerDetail.SignerId;
        string newSignerId = string.Join(string.Empty, "s_", HelperMethods.GetUniqueID());
        DateTime? expiryDate = DateTime.UtcNow.AddDays(BoldSignBase.EnvironmentVariables.DocumentLinkExpiryDays);
        signerDetail.UnhashedSignerId = newSignerId;

        if (!string.IsNullOrEmpty(currentSignerId) && PasswordHashing.ValidateHashedPassword(currentSignerId, oldSignerId))
        {
          lastSignedSignerId = newSignerId;
        }

        signerDetail.SignerId = PasswordHashing.CreateHashedPassword(newSignerId);
        signerDetail.MailLinkSettings = DocumentUtilities.AddExpiryToSignerId(signerDetail.SignerId, signerDetail.MailLinkSettings, expiryDate);

        // Add old Signer id into MailLink collection.
        if (!string.IsNullOrEmpty(oldSignerId) && oldSignerId.Length > 7 && !signerDetail.MailLinkSettings.Any(x => x.SignerId == oldSignerId))
        {
          if (signerDetail.OldSignerId == null || !signerDetail.OldSignerId.Contains(oldSignerId))
          {
            signerDetail.MailLinkSettings = DocumentUtilities.AddExpiryToSignerId(oldSignerId, signerDetail.MailLinkSettings, expiryDate);
          }
        }
      }

      foreach (var ccDetails in documentDetails.CCDetails)
      {
        string oldCcId = ccDetails.Id;
        string newCcId = string.Join(string.Empty, "s_", HelperMethods.GetUniqueID());
        DateTime? expiryDate = DateTime.UtcNow.AddDays(BoldSignBase.EnvironmentVariables.DocumentLinkExpiryDays);
        ccDetails.UnhashedSignerId = newCcId;
        ccDetails.Id = PasswordHashing.CreateHashedPassword(newCcId);
        ccDetails.MailLinkSettings = DocumentUtilities.AddExpiryToSignerId(ccDetails.Id, ccDetails.MailLinkSettings, expiryDate);

        // Add old Cc id into MailLink collection.
        if (!string.IsNullOrEmpty(oldCcId) && oldCcId.Length > 7 && !ccDetails.MailLinkSettings.Any(x => x.SignerId == oldCcId))
        {
          ccDetails.MailLinkSettings = DocumentUtilities.AddExpiryToSignerId(oldCcId, ccDetails.MailLinkSettings, expiryDate);
        }
      }

      return lastSignedSignerId;
    }

    private Task UpdateSignedHash(DocumentDetails documentDetails, AccessRightsDetails accessRightsDetails, byte[] signedPdfBytes, ConcurrentBag<DocumentHashDetails> individualSignedDocumentHashes)
    {
      using var shaHashing = SHA256.Create();
      if ((documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually) && !documentDetails.EnablePrintAndSign)
      {
        var signedPdfList = individualSignedDocumentHashes
          .Select(x => new IndividualSignedDocumentHash
          {
            DocumentName = x.Name,
            SignedHash = string.Concat(Array.ConvertAll(
              shaHashing.ComputeHash(x.HashValue),
              y => y.ToString(Format, CultureInfo.InvariantCulture))),
          })
          .ToArray();

        accessRightsDetails.SeperateSignedDocumentHashes = signedPdfList;
        documentDetails.IndividualSignedDocumentHashes = signedPdfList;
      }

      var signedHashBytes = shaHashing.ComputeHash(signedPdfBytes);
      var signedDocumentHash = string.Concat(Array.ConvertAll(signedHashBytes, x => x.ToString(Format, CultureInfo.InvariantCulture)));
      accessRightsDetails.SignedDocumentHash = signedDocumentHash;
      documentDetails.SignedDocumentHash = signedDocumentHash;
      List<Task> blobTasks = new List<Task>();
      blobTasks.Add(this.extendedDocumentDetailsService.AddOrUpdateDocumentDetails(documentDetails));
      blobTasks.Add(
        this.accessRightsService.AddOrUpdateAccessRightsDetailsAsync(this.elasticClient, accessRightsDetails));
      return Task.WhenAll(blobTasks);
    }

    private async Task MergeDocuments(IOrderedEnumerable<DocumentProperties> documentOrder, BlobContainerClient cloudBlobContainer, string documentId)
    {
      using PdfDocument pdfDocument = new PdfDocument();
      pdfDocument.DocumentInformation.AddCustomMetaDataInfo(CommonResource.DocumentIdMetaData, documentId);
      foreach (var document in documentOrder)
      {
        if (document.Order == -1)
        {
          continue;
        }

        BlobClient blob;
        if (string.IsNullOrEmpty(document.ParentId))
        {
          blob = cloudBlobContainer.GetBlobClient(DbConstants.Document);
        }
        else
        {
          blob = cloudBlobContainer.GetBlobClient($"{document.DocumentId}/{DbConstants.Document}");
        }

        MemoryStream documentStream = new MemoryStream();
        await this.CloudStorage.DownloadToStreamAsync(blob, documentStream, true, CancellationToken.None).ConfigureAwait(false);

#pragma warning disable CA2000 // Dispose objects before losing scope
        PdfLoadedDocument loadedDocument = new PdfLoadedDocument(documentStream);
#pragma warning restore CA2000 // Dispose objects before losing scope
        pdfDocument.Append(loadedDocument);
      }

      using MemoryStream stream = new MemoryStream();
      pdfDocument.Save(stream);
      var documentBlob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentMerged);
      stream.Seek(0, SeekOrigin.Begin);
      await this.CloudStorage.UploadFromStreamAsync(documentBlob, stream, true).ConfigureAwait(false);
    }

    private async Task MergeDocumentTextAsync(IOrderedEnumerable<DocumentProperties> documentOrder, BlobContainerClient cloudBlobContainer)
    {
      BlobClient blob;
      List<DocumentText> mergedDocumentText = new List<DocumentText>();
      foreach (var document in documentOrder)
      {
        if (document.Order == -1)
        {
          continue;
        }

        if (document.FileType == UploadFileType.Image)
        {
          // Updating merged document text with zero text lines for image.
          mergedDocumentText.AddRange(GetImageText());
          continue;
        }

        if (string.IsNullOrEmpty(document.ParentId))
        {
          blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentText);
        }
        else
        {
          blob = cloudBlobContainer.GetBlobClient($"{document.DocumentId}/{DbConstants.DocumentText}");
        }

        if (!blob.Exists())
        {
          continue;
        }

        var documentText = await this.CloudStorage.DownloadAsync<List<DocumentText>>(blob, true).ConfigureAwait(false);

        mergedDocumentText.AddRange(documentText);
      }

      List<DocumentText> documentTexts = new List<DocumentText>();

      for (int i = 0; i < mergedDocumentText.Count; i++)
      {
        documentTexts.Add(new DocumentText()
        {
          PageNumber = i + 1,
          TextLines = mergedDocumentText[i].TextLines,
        });
      }

      var documentBlob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentMergedText);
      await this.CloudStorage.UploadFromByteArrayAsync(documentBlob, BinarySerializer.Serialize<List<DocumentText>>(documentTexts), 0, true).ConfigureAwait(false);
    }

    private static List<DocumentText> GetImageText()
    {
      return new List<DocumentText>()
      {
        new DocumentText()
        {
          PageNumber = 1,
          TextLines = new List<TextLines>(),
        },
      };
    }

    private async Task<MemoryStream> ConvertImageToPdf(Stream documentStream, IDocumentUploadDetails documentUploadDetails, BlobContainerClient cloudBlobContainer, BlobContainerClient thumbnailCloudBlobContainer, string childId, DocumentProgress documentProgress)
    {
      try
      {
        // Updating page number count in the response.
        string pageCountPattern = string.Format(CultureInfo.InvariantCulture, $"\n{Constants.PageCount} : {1}");
        await this.UpdateUploadProgress(pageCountPattern, false).ConfigureAwait(false);

        // Initiliazing PdfBitmap image obejct.
        using PdfBitmap image = new PdfBitmap(documentStream);
        PdfUnitConverter converter = new PdfUnitConverter();

        // Convert the image width and height from pixel to points
        var pointSize = new Syncfusion.Drawing.SizeF(converter.ConvertFromPixels(image.Width, PdfGraphicsUnit.Point), converter.ConvertFromPixels(image.Height, PdfGraphicsUnit.Point));
        var imageSize = new SizeF(image.Width, image.Height);
        float zoomFactor = GetZoomFactor(documentUploadDetails?.DocumentVersion);

        // Uploading the Image in blob as PdfViewerImage, Thumbnails,  web-p
        await this.UploadDirectImageToBlob(documentStream, cloudBlobContainer, thumbnailCloudBlobContainer, childId, imageSize, documentProgress, zoomFactor).ConfigureAwait(false);

        // Adding image to PdfDocument.
        using PdfDocument document = new PdfDocument();
        document.PageSettings.Size = pointSize;

        // When width is higher than height we need to set orientation as Landscape
        if (image.Width > image.Height)
        {
          document.PageSettings.Orientation = PdfPageOrientation.Landscape;
        }

        document.PageSettings.Margins.All = 0;
        PdfPage page = document.Pages.Add();
        page.Graphics.DrawImage(image, new Syncfusion.Drawing.RectangleF(0, 0, page.Size.Width, page.Size.Height));
        MemoryStream ms = new MemoryStream();
        document.Save(ms);
        documentUploadDetails.DocumentArray = ms.ToArray();
        return ms;
      }
      catch (Exception ex)
      {
        this.logger.LogError(CommonResource.ErrorWhileConvertingImageToPdf, ex);
        throw new InvalidDataException(CommonResource.ErrorWhileConvertingImageToPdf, ex);
      }
    }

    private async Task MergePdfFieldAsync(IOrderedEnumerable<DocumentProperties> documentOrder, BlobContainerClient cloudBlobContainer)
    {
      BlobClient blob;
      List<PageFormElements> mergeFormElements = new List<PageFormElements>();
      List<PageFormElements> documentPdfFields = new List<PageFormElements>();
      var previousDocumentPageCount = 0;

      foreach (var document in documentOrder)
      {
        if (document.Order == -1)
        {
          continue;
        }

        blob = CheckBlob(cloudBlobContainer, document);
        if (blob != null && await blob.ExistsAsync().ConfigureAwait(false))
        {
          documentPdfFields = await this.CloudStorage.DownloadAsync<List<PageFormElements>>(blob, true).ConfigureAwait(false);
          if (document.Order > 0)
          {
            documentPdfFields.ForEach(x => x.PageIndex = x.PageIndex + previousDocumentPageCount);
          }

          previousDocumentPageCount = previousDocumentPageCount + document.PageCount;
          mergeFormElements.AddRange(documentPdfFields);
        }
        else
        {
          previousDocumentPageCount = previousDocumentPageCount + document.PageCount;
        }
      }

      if (mergeFormElements != null && mergeFormElements.Count > 0)
      {
        blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentPdfFieldsMerged);
        await this.CloudStorage.UploadFromByteArrayAsync(blob, BinarySerializer.Serialize<List<PageFormElements>>(mergeFormElements), 0, true).ConfigureAwait(false);
      }
    }

    private static BlobClient CheckBlob(BlobContainerClient cloudBlobContainer, DocumentProperties document)
    {
      BlobClient blob = null;
      if (string.IsNullOrEmpty(document.ParentId))
      {
        blob = cloudBlobContainer.GetBlobClient(DbConstants.DocumentPdfFields);
      }
      else
      {
        blob = cloudBlobContainer.GetBlobClient($"{document.DocumentId}/{DbConstants.DocumentPdfFields}");
      }

      return blob;
    }

    private async Task<Stream> GetPdfDocumentStream(IDocumentUploadDetails documentUploadDetails, BlobContainerClient cloudBlobContainer, BlobContainerClient thumbnailCloudBlobContainer, string childId, DocumentProgress documentProgress)
    {
      Stream ms = new MemoryStream(documentUploadDetails.DocumentArray);

      ms.Position = 0;
      ms = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType, documentUploadDetails.DocumentName) switch
      {
        ContentType.Word => await this.ConvertWordDocumentToPDF(ms, documentUploadDetails, cloudBlobContainer, childId, documentProgress).ConfigureAwait(false),
        ContentType.Images => await this.ConvertImageToPdf(ms, documentUploadDetails, cloudBlobContainer, thumbnailCloudBlobContainer, childId, documentProgress).ConfigureAwait(false),
        ContentType.Excel => await this.ConvertExcelDocumentToPdf(ms, documentUploadDetails, cloudBlobContainer, childId, documentProgress).ConfigureAwait(false),
        ContentType.PDF => ms,
        ContentType.Invalid => throw new InvalidDataException(CommonResource.UnsupportedContentType),
        _ => throw new InvalidDataException(CommonResource.UnsupportedContentType)
      };

      return ms;
    }

    private static Stream GetPdfDocumentStreamForValdiation(IDocumentUploadDetails documentUploadDetails)
    {
      Stream stream = null;
      if (documentUploadDetails is StreamDocumentUploadDetails streamDocument)
      {
        documentUploadDetails.ContentType = streamDocument.File.ContentType;
        documentUploadDetails.DocumentName = streamDocument.File.FileName;
        documentUploadDetails.DocumentArray = streamDocument.File.OpenReadStream().ToByteArray();
        stream = streamDocument.File.OpenReadStream();
      }
      else if (documentUploadDetails is DocumentUploadDetails documentUpload)
      {
        documentUploadDetails.ContentType = documentUpload.ContentType;
        stream = new MemoryStream(documentUploadDetails.DocumentArray);
      }

      return stream;
    }

    private Stream GetPdfAttachmentStream(RequestAttachmentDetails attachmentFileDetails, ref byte[] documentArray)
    {
      Stream ms = null;
      string contentType = string.Empty;
      if (attachmentFileDetails is RequestAttachmentDetails streamDocument)
      {
        contentType = streamDocument.File.ContentType;
        documentArray = streamDocument.File.OpenReadStream().ToByteArray();
        ms = streamDocument.File.OpenReadStream();
      }

      ms.Position = 0;
      ms = DocumentContentType.GetDocumentType(contentType, attachmentFileDetails.FileName) switch
      {
        ContentType.Word => this.ConvertWordDocumentToPDFMemoryStream(ms, ref documentArray),
        ContentType.Images => this.ConvertImageToPdfMemoryStream(ms, ref documentArray),
        ContentType.PDF => ms,
        ContentType.Invalid => throw new InvalidDataException(CommonResource.UnsupportedContentType),
        _ => throw new InvalidDataException(CommonResource.UnsupportedContentType)
      };

      return ms;
    }

    private async Task<MemoryStream> ConvertWordDocumentToPDF(Stream documentStream, IDocumentUploadDetails documentUploadDetails, BlobContainerClient cloudBlobContainer, string childId, DocumentProgress documentProgress)
    {
      try
      {
        var blobClientDocument = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.WordDocumentClient}");
        await this.CloudStorage.UploadFromStreamAsync(blobClientDocument, documentStream, true).ConfigureAwait(false);
        documentStream.Position = 0;

        // Saves the PDF file
        documentUploadDetails.DocumentArray = this.ConvertWordToPdf(documentStream, documentProgress);

        return new MemoryStream(documentUploadDetails.DocumentArray);
      }
      catch (ArgumentException ex) when (ex.Message == "Document is encrypted, password is needed to open the document")
      {
        this.logger.LogError(ex, CommonResource.InvalidPassword);
        throw new InvalidDataException(CommonResource.InvalidPassword, ex);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileConvertingWordToPdf);
        throw new InvalidDataException(CommonResource.ErrorWhileConvertingWordToPdf, ex);
      }
    }

    private async Task<MemoryStream> ConvertExcelDocumentToPdf(Stream documentStream, IDocumentUploadDetails documentUploadDetails, BlobContainerClient cloudBlobContainer, string childId, DocumentProgress documentProgress)
    {
      try
      {
        var blobClientDocument = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.WordDocumentClient}");
        await this.CloudStorage.UploadFromStreamAsync(blobClientDocument, documentStream, true).ConfigureAwait(false);
        documentStream.Position = 0;

        // Saves the PDF file
        documentUploadDetails.DocumentArray = this.ConvertExcelToPdf(documentStream, documentProgress);

        return new MemoryStream(documentUploadDetails.DocumentArray);
      }
      catch (ArgumentException ex) when (ex.Message == "Workbook is protected and password wasn't specified.")
      {
        this.logger.LogError(ex, CommonResource.InvalidPassword);
        throw new InvalidDataException(CommonResource.InvalidPassword, ex);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileConvertingXlToPdf);
        throw new InvalidDataException(CommonResource.ErrorWhileConvertingXlToPdf, ex);
      }
    }

    private MemoryStream ConvertImageToPdfMemoryStream(Stream documentStream, ref byte[] documentArray)
    {
      try
      {
        using PdfDocument document = new PdfDocument();
        using PdfBitmap image = new PdfBitmap(documentStream);
        PdfUnitConverter converter = new PdfUnitConverter();
        var pointSize = new Syncfusion.Drawing.SizeF(converter.ConvertFromPixels(image.Width, PdfGraphicsUnit.Point), converter.ConvertFromPixels(image.Height, PdfGraphicsUnit.Point));
        document.PageSettings.Size = pointSize;

        if (image.Width > image.Height)
        {
          document.PageSettings.Orientation = PdfPageOrientation.Landscape;
        }

        document.PageSettings.Margins.All = 0;
        PdfPage page = document.Pages.Add();
        page.Graphics.DrawImage(image, new Syncfusion.Drawing.RectangleF(0, 0, page.Size.Width, page.Size.Height));
        MemoryStream ms = new MemoryStream();
        document.Save(ms);
        documentArray = ms.ToArray();
        return ms;
      }
      catch (Exception ex)
      {
        this.logger.LogError(CommonResource.ErrorWhileConvertingImageToPdf, ex);
        throw new InvalidDataException(CommonResource.ErrorWhileConvertingImageToPdf, ex);
      }
    }

    private MemoryStream ConvertWordDocumentToPDFMemoryStream(Stream documentStream, ref byte[] documentArray)
    {
      try
      {
        // Loads file stream into Word document
        using WordDocument wordDocument = new WordDocument(documentStream, Syncfusion.DocIO.FormatType.Automatic);

        // SubstituteFont event for font fall back
        wordDocument.FontSettings.SubstituteFont += this.FontSettings_SubstituteFont;

        // Instantiation of DocIORenderer for Word to PDF conversion
        using DocIORenderer render = new DocIORenderer();

        // Sets Chart rendering Options.
        render.Settings.ChartRenderingOptions.ImageFormat = Syncfusion.OfficeChart.ExportImageFormat.Jpeg;
        render.Settings.EmbedFonts = true;

        // Converts Word document into PDF document
        PdfDocument pdfDocument = render.ConvertToPDF(wordDocument);

        // Saves the PDF file
        MemoryStream outputStream = new MemoryStream();
        pdfDocument.Save(outputStream);
        pdfDocument.Close(true);
        documentArray = outputStream.ToArray();
        return outputStream;
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileConvertingWordToPdf);
        throw new InvalidDataException(CommonResource.ErrorWhileConvertingWordToPdf, ex);
      }
    }

    private void FontSettings_SubstituteFont(object sender, SubstituteFontEventArgs args)
    {
      args.AlternateFontName = args.OriginalFontName switch
      {
        string fontName when fontName.ToUpperInvariant().Contains("TIMES", StringComparison.InvariantCulture) => "Liberation Serif",
        string fontName when fontName.ToUpperInvariant().Contains("Arial", StringComparison.InvariantCulture) => "Liberation Sans",
        string fontName when fontName.ToUpperInvariant().Contains("CALIBRI", StringComparison.InvariantCulture) => "Carlito",
        string fontName when fontName.ToUpperInvariant().Contains("SYMBOL", StringComparison.InvariantCulture) => "OpenSymbol",
        string fontName when fontName.ToUpperInvariant().Contains("WEBDING", StringComparison.InvariantCulture) => "OpenSymbol",
        string fontName when fontName.ToUpperInvariant().Contains("Wingdings", StringComparison.InvariantCulture) => "OpenSymbol",
        _ => "Liberation Sans",
      };

      if (string.IsNullOrEmpty(args.AlternateFontName))
      {
        this.logger.LogInformation(CommonResource.MissingFontWordToPdf + args.OriginalFontName);
        throw new InvalidDataException(CommonResource.ErrorWhileConvertingWordToPdf + args.OriginalFontName);
      }
    }

    private async Task DeletePdfFormFieldMerged(BlobContainerClient cloudBlobContainer, string prefix)
    {
      var resultSegment = cloudBlobContainer.GetBlobsByHierarchyAsync(prefix: prefix, delimiter: "/")
        .AsPages(default, BlobRequestCount);

      await foreach (Azure.Page<BlobHierarchyItem> blobPage in resultSegment)
      {
        foreach (BlobHierarchyItem blobhierarchyItem in blobPage.Values)
        {
          if (blobhierarchyItem.IsBlob)
          {
            string name = blobhierarchyItem.Blob.Name;
            if (!string.IsNullOrEmpty(prefix))
            {
              name = blobhierarchyItem.Blob.Name.Split('/')[1];
            }

            if (name == DbConstants.DocumentPdfFieldsMerged)
            {
              await cloudBlobContainer.DeleteBlobAsync(blobhierarchyItem.Blob.Name).ConfigureAwait(false);
            }
          }
        }
      }
    }

    private static Tuple<string, string> GetAuditNameAndEmail(UserDataService userDataService, DocumentDetails documentDetails)
    {
      if (documentDetails.OnBehalfOfDetails != null &&
          (userDataService.Id == documentDetails.OnBehalfOfDetails.UserId || userDataService.NormalizedEmail == documentDetails.OnBehalfOfDetails.EmailAddress.ToUpperInvariant()))
      {
        return new Tuple<string, string>(documentDetails.OnBehalfOfDetails.Name, documentDetails.OnBehalfOfDetails.EmailAddress);
      }

      return new Tuple<string, string>(userDataService.Name, userDataService.Email);
    }

    private async Task DeleteDocumentBlobs(BlobContainerClient cloudBlobContainer, string prefix)
    {
      var resultSegment = cloudBlobContainer.GetBlobsByHierarchyAsync(prefix: prefix, delimiter: "/")
        .AsPages(default, BlobRequestCount);

      await foreach (Azure.Page<BlobHierarchyItem> blobPage in resultSegment)
      {
        foreach (BlobHierarchyItem blobhierarchyItem in blobPage.Values)
        {
          if (blobhierarchyItem.IsBlob)
          {
            string name = blobhierarchyItem.Blob.Name;
            if (!string.IsNullOrEmpty(prefix))
            {
              name = blobhierarchyItem.Blob.Name.Split('/')[1];
            }

            if (name == DbConstants.Document || name == DbConstants.DocumentClient || name == DbConstants.DocumentDetails || name.StartsWith("page", StringComparison.InvariantCulture) || name == DbConstants.DocumentPdfFields || name == DbConstants.DocumentPdfFieldsMerged || name.Contains("taggedtext") || name == DbConstants.DocumentText)
            {
              await cloudBlobContainer.DeleteBlobAsync(blobhierarchyItem.Blob.Name).ConfigureAwait(false);
            }
          }
        }
      }
    }

    private async Task ValidateDocument(IDocumentUploadDetails documentUploadDetails, PdfLoadedDocument pdfDocument, BlobContainerClient blobContainer)
    {
      int pageCount = pdfDocument.PageCount;
      int documentCount = 0;

      if (!string.IsNullOrEmpty(documentUploadDetails.ParentDocumentId))
      {
        // Used AsPages since we need to get the document count with prefix count for whole container.
        await foreach (Azure.Page<BlobHierarchyItem> blobPage in blobContainer.GetBlobsByHierarchyAsync(BlobTraits.None, BlobStates.None, "/", string.Empty).AsPages(default, BlobRequestCount))
        {
          documentCount += blobPage.Values.Count(item => item.IsPrefix);
        }

        var documentContents = GetDocumentDetailsCache(this.httpContext);

        if (documentContents == null)
        {
          var documentDetails = await this.extendedDocumentDetailsService.GetDocumentDetailsAsync(documentUploadDetails.ParentDocumentId).ConfigureAwait(false);
          if (documentDetails != null)
          {
            pageCount += documentDetails.DocumentProperties.Where(x => x.Order != -1).Select(x => x.PageCount).Sum();
            documentCount = documentDetails.DocumentProperties.Where(x => x.Order != -1).Count() - 1;
          }
        }
      }

      if (pageCount > BoldSignBase.EnvironmentVariables.AllowedPageCount)
      {
        throw new InvalidDataException(CommonResource.PageCountExceeded);
      }

      if (documentCount >= (BoldSignBase.EnvironmentVariables.AllowedDocumentCount - 1))
      {
        throw new InvalidDataException(CommonResource.DocumentCountExceeded);
      }
    }

    private bool VerifyCertificateChain(X509Certificate2 signingCertificate, X509Certificate2 rootCertificate)
    {
      try
      {
        var signingX509Certificate = DotNetUtilities.FromX509Certificate(signingCertificate);
        var rootX509Certificate = DotNetUtilities.FromX509Certificate(rootCertificate);
        signingX509Certificate.Verify(rootX509Certificate.GetPublicKey());
        return true;
      }
      catch (InvalidKeyException ex)
      {
        this.logger.LogError(ex, CommonResource.DigitalSignatureVerificationFailed);
      }

      return false;
    }

    private void DrawWatermark(PdfPageBase page, string text)
    {
      PdfFont font = new PdfStandardFont(PdfFontFamily.Helvetica, 60f);

      PdfGraphicsState state = page.Graphics.Save();
      Syncfusion.Drawing.SizeF textSize = font.MeasureString(text);

      bool isLandscape = false;
      float percent = 0.90F;

      float pageWidth = page.Size.Width;
      float pageHeight = page.Size.Height;

      float heightMargin = page.Size.Height * percent;
      float widthMargin = page.Size.Width * percent;

      // Chnage the width and height if the angle is 90 or 180 degree
      if (page.Rotation == PdfPageRotateAngle.RotateAngle90 || page.Rotation == PdfPageRotateAngle.RotateAngle270)
      {
        pageWidth = page.Size.Height;
        pageHeight = page.Size.Width;

        heightMargin = page.Size.Width * percent;
        widthMargin = page.Size.Height * percent;
      }

      if (pageWidth > pageHeight)
      {
        isLandscape = true;
      }

      float tangent = heightMargin / widthMargin;
      float angle = -(float)(Math.Atan(tangent) * (180 / Math.PI));
      var marginSum = (heightMargin * heightMargin) + (widthMargin * widthMargin);
      float hypotenuse = (float)Math.Sqrt(marginSum);

      page.Graphics.SetTransparency(0.40F);

      float i = 0;
      while (true)
      {
        font = new PdfStandardFont(PdfFontFamily.Helvetica, i);
        Syncfusion.Drawing.SizeF sizef = font.MeasureString(text);

        double cos = Math.Cos((-angle) * (Math.PI / 180));
        double tan = Math.Tan((-angle) * (Math.PI / 180));

        if (!isLandscape && sizef.Width >= widthMargin)
        {
          float x = (float)cos * ((hypotenuse / 2.75F) - (sizef.Width / 2.75F));

          font = new PdfStandardFont(PdfFontFamily.Helvetica, i);
          float pos = (float)((sizef.Width / 2) * tan);
          float y = (pageHeight / 3) - sizef.Height;
          y = y + pos;
          page.Graphics.TranslateTransform(x, y);

          page.Graphics.RotateTransform(-45);
          break;
        }
        else if (isLandscape && sizef.Width >= heightMargin)
        {
          float x = (float)cos * ((hypotenuse / 1.75F) - (sizef.Width / 1.75F));
          font = new PdfStandardFont(PdfFontFamily.Helvetica, i);
          float pos = (float)((sizef.Width / 2) * tan);
          float y = (pageHeight / 2) - (sizef.Height / 2);
          y = y + pos;
          page.Graphics.TranslateTransform(x, y);

          page.Graphics.RotateTransform(-45);
          break;
        }

        i++;
      }

      page.Graphics.DrawString(text, font, PdfPens.White, PdfBrushes.Gray, new Syncfusion.Drawing.PointF(0, 0));
      page.Graphics.Restore(state);
    }

    private async Task UploadWebPToBlob(string childId, string scannedBlobName,
      byte[] webpBytes, int pageNumber, BlobContainerClient cloudBlobContainer,
      float zoomFactor)
    {
      using var pageContent = new PdfViewerImage
      {
        PngBytes = webpBytes,
        ScaleFactor = PdfExport.Scale,
      };

      // Upload page image with pattern, page-[page-number]-[zoom-factor]-webp.
      var blockBlob = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Page}-{pageNumber}-{zoomFactor}-webp");
      byte[] imageSerialized = BinarySerializer.Serialize(pageContent);
      await this.CloudStorage.UploadFromByteArrayAsync(blockBlob, imageSerialized, 0, false).ContinueWith(x => imageSerialized = null, TaskScheduler.Current).ConfigureAwait(false);
    }

    private async Task ConvertAndUploadImageToWebP(string childId, string scannedBlobName, PdfViewerImage jsonImage, int pageNumber, BlobContainerClient cloudBlobContainer, float zoomFactor)
    {
      using var img = SKBitmap.Decode(jsonImage.PngBytes);
      await using MemoryStream ms = new MemoryStream();
      using var skManagedWStream = new SKManagedWStream(ms);

      img.Encode(skManagedWStream, SKEncodedImageFormat.Webp, BoldSignBase.EnvironmentVariables.ImageConversionQuality);
      var base64WebP = ms.ToArray();

      using var pageContent = new PdfViewerImage
      {
        PngBytes = base64WebP,
        ScaleFactor = PdfExport.Scale,
      };

      // Upload page image with pattern, page-[page-number]-[zoom-factor]-webp.
      var blockBlob = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Page}-{pageNumber}-{zoomFactor}-webp");
      byte[] imageSerialized = BinarySerializer.Serialize(pageContent);
      await this.CloudStorage.UploadFromByteArrayAsync(blockBlob, imageSerialized, 0, false).ContinueWith(x => imageSerialized = null, TaskScheduler.Current).ConfigureAwait(false);
    }

    private string GetHashValue(byte[] fileNameByte)
    {
      using var shaHashing = SHA256.Create();
      var signedHashBytes = shaHashing.ComputeHash(fileNameByte);
      return string.Concat(Array.ConvertAll(fileNameByte, x => x.ToString(Format, CultureInfo.InvariantCulture)));
    }

    private BoldSign.Base.Models.SignerDetails[] GetAllSignersToClone(BoldSign.Base.Models.SignerDetails[] signerDetails)
    {
      var combinedSigners = signerDetails.Where(x => x.SignType == SigningType.Single).ToList();
      var parentGroupSigners = signerDetails.Where(x => x.SignType == SigningType.Group);
      combinedSigners.AddRange(parentGroupSigners);
      var groupSigners = parentGroupSigners.SelectMany(x => x.GroupSignerDetails);
      combinedSigners.AddRange(groupSigners);
      return combinedSigners.ToArray();
    }

    private FormElement CreateFormElementsFromPdfFields(PdfLoadedField field, BoldSign.Base.Models.Rectangle bounds = null)
    {
      FormElement formElement = new FormElement();
      BoldSign.Base.Models.Rectangle bound = null;

      switch (field)
      {
        case PdfLoadedTextBoxField textBoxField:
          if (string.IsNullOrEmpty(textBoxField.Text))
          {
            formElement.ElementType = "TextBox";
            formElement.FontFamily = GetFontFamily(textBoxField.Font.Name);
            formElement.FontSize = this.converter.ConvertToPixels(textBoxField.Font.Size, PdfGraphicsUnit.Point);
            formElement.EnableWrapping = true;
            formElement.Bounds = bound = this.ConvertToPixelsFromPoints(textBoxField.Bounds);
            formElement.MaxHeight = bound.Height;
            formElement.MaxWidth = bound.Width;
          }

          break;
        case PdfLoadedSignatureField signatureField:
          formElement.ElementType = "Signature";
          formElement.FontFamily = GetFontFamily(signatureField.Font.Name);
          formElement.FontSize = signatureField.Font.Size;
          formElement.EnableWrapping = false;
          formElement.Bounds = bounds;
          formElement.MaxHeight = bounds.Height;
          formElement.MaxWidth = bounds.Width;
          break;
        case PdfLoadedCheckBoxField checkBoxField:
          formElement.ElementType = "CheckBox";
          formElement.FontFamily = GetFontFamily(checkBoxField.Font.Name);
          formElement.FontSize = checkBoxField.Font.Size;
          formElement.EnableWrapping = false;
          formElement.Value = "off";
          formElement.Bounds = bound = this.ConvertToPixelsFromPoints(checkBoxField.Bounds);
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case PdfLoadedRadioButtonListField radioField:
          formElement.ElementType = "RadioButton";
          formElement.FontFamily = GetFontFamily(radioField.Font.Name);
          formElement.FontSize = radioField.Font.Size;
          formElement.EnableWrapping = false;
          formElement.GroupName = field.Name;
          break;
        case PdfLoadedComboBoxField dropDownField:
          formElement.ElementType = "DropDown";
          formElement.FontFamily = GetFontFamily(dropDownField.Font.Name);
          formElement.FontSize = this.converter.ConvertToPixels(dropDownField.Font.Size, PdfGraphicsUnit.Point);
          formElement.EnableWrapping = false;
          formElement.Bounds = bound = this.ConvertToPixelsFromPoints(dropDownField.Bounds);
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          formElement.Label = dropDownField.ActualFieldName;
          formElement.Value = dropDownField.SelectedValue;
          formElement.DropdownOptions = dropDownField.Values.ToList<PdfLoadedListItem>().Select(item => item.Value).ToArray();
          break;
      }

      formElement.Id = field.Name;
      formElement.IsRequired = field.Required;
      formElement.AllowEditing = true;
      return formElement;
    }

    private static string GetFontFamily(string font)
    {
      if (string.IsNullOrEmpty(font))
      {
        return "Helvetica";
      }

      return font.ToUpperInvariant() switch
      {
        string fontFamily when fontFamily == HelveticaFont || fontFamily == CourierFont || fontFamily == TimesNewRomanFont || fontFamily == NotoSansFont => font,
        _ => "Helvetica",
      };
    }

    private async Task ProcessAndExtractPdfFormFields(PdfLoadedDocument loadedDocument, string parentId, string childId, string organizationId)
    {
      if (loadedDocument != null)
      {

        List<TextTagDefinition> combinedTags = new List<TextTagDefinition>();
        int pageIndex = 1;

        using DocumentTextExtractor documentTextExtractor = new DocumentTextExtractor(this.DocumentUploadDetails.DocumentArray);
        var documentTags = documentTextExtractor.ExtractTextTags(null, ref pageIndex);
        combinedTags.AddRange(documentTags);

        List<BoldSign.ApiManagement.Models.FormField> tagField = TextTagMapper.MapTagsToSignerField(documentTags);
        var tagFields = TextTagMapper.MapTagsToSignerFields(documentTags);

        PdfLoadedForm loadedForm = loadedDocument.Form;
        PdfLoadedFormFieldCollection fieldCollection = loadedForm?.Fields;
        List<PageFormElements> pageFormElements = new List<PageFormElements>();
        List<FormElement> formElements = new List<FormElement>();
        var finalFormElement = new PageFormElements();


         foreach(var tagtexts in combinedTags.ToList())
          {
            finalFormElement = this.PrepareFormField(loadedDocument,tagtexts,tagtexts.Bounds,tagtexts.Type);
            pageFormElements.Add(finalFormElement);

         }

        // Dictionary<int, List<PageFormElements>> extractedformElement = new Dictionary<int, List<PageFormElements>>();

        // foreach (var signerEntry in tagFields)
        // {
        //   // signerEntry.Key is the SignerIndex (which can be used to group or manage per signer)
        //   // signerEntry.Value is the List<FormField> associated with this SignerIndex

        //   foreach (var formField in signerEntry.Value)
        //   {
        //     // For each FormField, prepare the final form element
        //     finalFormElement = this.PrepareFormField(loadedDocument, formField, formField.Bounds, formField.Type);

        //     // If the dictionary doesn't already contain the SignerIndex, initialize an empty list
        //     if (!extractedformElement.ContainsKey(signerEntry.Key))
        //     {
        //       extractedformElement[signerEntry.Key] = new List<PageFormElements>();
        //     }

        //     // Add the prepared form element to the list of FormElements under the current SignerIndex
        //     extractedformElement[signerEntry.Key].Add(finalFormElement);

        //     // Add the prepared form element to the list of page form elements
        //     pageFormElements.Add(finalFormElement);
        //   }
        // }

        if (pageFormElements!=null) {
           var group = pageFormElements.GroupBy(x => x.PageIndex).Select(x => x).ToList();
          List<PageFormElements> newPageFormElements = new List<PageFormElements>();
           for (int i = 0; i < group.Count; i++)
          {
            var checks = group[i].SelectMany(x => x.FormElements).ToList();
            PageFormElements formElement = new PageFormElements();
            formElement.PageIndex = group[i].Key;
            formElement.FormElements = checks.ToArray();
            newPageFormElements.Add(formElement);
          }

           if (newPageFormElements != null && newPageFormElements.Count > 0)
          {
            BlobContainerClient cloudBlobContainer = null;
            BlobClient blobClientDocument = null;
            cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, organizationId).ConfigureAwait(false);
            if (string.IsNullOrEmpty(childId))
            {
              blobClientDocument = cloudBlobContainer.GetBlobClient($"{DbConstants.DocumentPdfFields}");
            }
            else
            {
              blobClientDocument = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentPdfFields}");
            }

            await this.CloudStorage.UploadFromByteArrayAsync(blobClientDocument, BinarySerializer.Serialize<List<PageFormElements>>(newPageFormElements), 0, true).ConfigureAwait(false);
           }
         }

        // if (extractedformElement != null && extractedformElement.Count > 0)
        // {
        //   // Iterate through each SignerIndex (key) and its corresponding list of PageFormElements (value)
        //   foreach (var signerEntry in extractedformElement)
        //   {
        //     List<PageFormElements> newPageFormElements = signerEntry.Value;

        //     if (newPageFormElements != null && newPageFormElements.Count > 0)
        //     {
        //       // Group the PageFormElements by PageIndex as in the original code
        //       var group = newPageFormElements.GroupBy(x => x.PageIndex).Select(x => x).ToList();

        //       // New list to store the grouped PageFormElements
        //       List<PageFormElements> finalPageFormElements = new List<PageFormElements>();

        //       for (int i = 0; i < group.Count; i++)
        //       {
        //         // Combine all form elements on the same page into one PageFormElements object
        //         var checks = group[i].SelectMany(x => x.FormElements).ToList();
        //         PageFormElements formElement = new PageFormElements
        //         {
        //           PageIndex = group[i].Key,
        //           FormElements = checks.ToArray()
        //         };

        //         finalPageFormElements.Add(formElement);
        //       }

        //       // If there are any grouped PageFormElements, upload them
        //       if (finalPageFormElements.Count > 0)
        //       {
        //         BlobContainerClient cloudBlobContainer = null;
        //         BlobClient blobClientDocument = null;

        //         // Get the cloud blob container based on parentId and organizationId
        //         cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, organizationId).ConfigureAwait(false);

        //         if (string.IsNullOrEmpty(childId))
        //         {
        //           blobClientDocument = cloudBlobContainer.GetBlobClient($"{DbConstants.DocumentPdfFields}_signer{signerEntry.Key}");
        //         }
        //         else
        //         {
        //           blobClientDocument = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentPdfFields}_signer{signerEntry.Key}");
        //         }


        //         await this.CloudStorage.UploadFromByteArrayAsync(blobClientDocument, BinarySerializer.Serialize<List<PageFormElements>>(finalPageFormElements), 0, true).ConfigureAwait(false);
        //         if (string.IsNullOrEmpty(childId))
        //         {
        //           blobClientDocument = cloudBlobContainer.GetBlobClient($"{DbConstants.DocumentPdfFields}");
        //         }
        //         else
        //         {
        //           blobClientDocument = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentPdfFields}");
        //         }

        //         await this.CloudStorage.UploadFromByteArrayAsync(blobClientDocument, BinarySerializer.Serialize<List<PageFormElements>>(finalPageFormElements), 0, true).ConfigureAwait(false);


        //       }
        //     }
        //   }
        // }


        if (fieldCollection != null)
        {
          foreach (PdfLoadedField field in fieldCollection)
          {
            switch (field)
            {
              case PdfLoadedTextBoxField textBoxField:
              case PdfLoadedCheckBoxField checkBoxField:
              case PdfLoadedComboBoxField dropDownField:

                finalFormElement = this.PrepareFormFields(loadedDocument, field);
                pageFormElements.Add(finalFormElement);
                break;

              case PdfLoadedSignatureField signatureField:
                {
                  // condition to avoid extracting the fields from signed document.
                  if (signatureField.Bounds.X != 0 && signatureField.Bounds.Y != 0)
                  {
                    var bounds = this.ConvertToPixelsFromPoints(signatureField.Bounds);
                    finalFormElement = this.PrepareFormFields(loadedDocument, field, bounds);
                    pageFormElements.Add(finalFormElement);
                  }
                }

                break;

              case PdfLoadedRadioButtonListField radioButton:
                {
                  PdfLoadedRadioButtonItemCollection radioCollection = radioButton.Items;
                  List<FormElement> childFormElement = new List<FormElement>();
                  foreach (PdfLoadedRadioButtonItem item in radioCollection)
                  {
                    var bound = this.ConvertToPixelsFromPoints(item.Bounds);
                    FormElement childForm = new FormElement();
                    childForm.Id = item.OptionValue;
                    childForm.ElementType = "child";
                    childForm.Bounds = bound;
                    childForm.GroupName = field.Name;
                    childForm.FontFamily = GetFontFamily(item.Font.Name);
                    childForm.FontSize = item.Font.Size;
                    childForm.AllowEditing = true;
                    childForm.EnableWrapping = false;
                    childForm.IsRequired = true;
                    childFormElement.Add(childForm);
                  }

                  finalFormElement = this.PrepareFormFields(loadedDocument, field);
                  finalFormElement.FormElements[0].Children = childFormElement.ToArray();
                  pageFormElements.Add(finalFormElement);
                }

                break;
            }
          }


          var group = pageFormElements.GroupBy(x => x.PageIndex).Select(x => x).ToList();
          List<PageFormElements> newPageFormElements = new List<PageFormElements>();

          // forming page form elements based on the page index value.
          for (int i = 0; i < group.Count; i++)
          {
            var checks = group[i].SelectMany(x => x.FormElements).ToList();
            PageFormElements formElement = new PageFormElements();
            formElement.PageIndex = group[i].Key;
            formElement.FormElements = checks.ToArray();
            newPageFormElements.Add(formElement);
          }

          if (newPageFormElements != null && newPageFormElements.Count > 0)
          {
            BlobContainerClient cloudBlobContainer = null;
            BlobClient blobClientDocument = null;
            cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, organizationId).ConfigureAwait(false);
            if (string.IsNullOrEmpty(childId))
            {
              blobClientDocument = cloudBlobContainer.GetBlobClient($"{DbConstants.DocumentPdfFields}");
            }
            else
            {
              blobClientDocument = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentPdfFields}");
            }

            await this.CloudStorage.UploadFromByteArrayAsync(blobClientDocument, BinarySerializer.Serialize<List<PageFormElements>>(newPageFormElements), 0, true).ConfigureAwait(false);
          }
        }
      }
    }

    private PageFormElements PrepareFormFields(PdfLoadedDocument loadedDocument, PdfLoadedField field, BoldSign.Base.Models.Rectangle bounds = null)
    {
      List<FormElement> form = new List<FormElement>();
      FormElement formelement = this.CreateFormElementsFromPdfFields(field, bounds);
      if (formelement.ElementType != null)
      {
        form.Add(formelement);
      }

      PageFormElements preparedFields = new PageFormElements();
      preparedFields.PageIndex = loadedDocument.Pages.IndexOf(field.Page) + 1;
      preparedFields.FormElements = form.ToArray();
      return preparedFields;
    }

    private static PdfFontStyle GetFontStyle(bool style, bool fontWeight, bool textDecoration)
    {
      PdfFontStyle fontStyle = PdfFontStyle.Regular;

      if (style)
      {
        fontStyle |= PdfFontStyle.Italic;
      }

      if (fontWeight)
      {
        fontStyle |= PdfFontStyle.Bold;
      }

      if (textDecoration)
      {
        fontStyle |= PdfFontStyle.Underline;
      }

      return fontStyle;
    }

    private async Task DownloadLargeSizeBulkDocumentAsync(string bulkLinkId, string fileId, DocumentDetails documentDetails, List<LinkSignerDetails> completedLinkSignerDetails, CancellationToken token)
    {
      var currentUserEmail = this.userDataService.Email;
      var currentUserName = this.userDataService.Name;
      var currentUserId = this.userDataService.Id;
      var organizationId = this.userDataService.OrganizationId;
      string bulkFileDirectory = Path.Combine(Directory.GetCurrentDirectory(), $"download/{fileId}");
      var individualDownload = documentDetails.EnableIndividualDocumentDownloads || documentDetails.DocumentDownloadOption == DocumentDownloadOption.Individually;
      string zipFilePath = await this.GetDownloadedZipPathAsync(bulkFileDirectory, bulkLinkId, SanitizedFileName.GetValidFileName(documentDetails.FormTitle), completedLinkSignerDetails, individualDownload, documentDetails.CombineAuditTrail, documentDetails.EnablePrintAndSign, token).ConfigureAwait(false);
      await this.UploadZipFileAsync(bulkLinkId, fileId, SanitizedFileName.GetValidFileName(documentDetails.FormTitle), zipFilePath, bulkFileDirectory, documentDetails.OrganizationId, token).ConfigureAwait(false);
      _ = this.SendEmailForBulkLinkDownloadAsync(documentDetails, this.requestDetailsService.HostedDomain, bulkLinkId, fileId, currentUserEmail, currentUserName, currentUserId, organizationId).ConfigureAwait(false);
      var bulkDownloadDetails = new BulkDownloadDetails
      {
        Id = Guid.NewGuid().ToString(),
        BulkLinkId = bulkLinkId,
        FileId = fileId,
        ExpiryDate = DateTime.UtcNow.AddDays(7),
        CompletedDocumentIds = completedLinkSignerDetails.Select(x => x.DocumentId).ToArray(),
      };

      await this.documentRepositoryService.CreateDocumentAsync(bulkDownloadDetails, DbConstants.BulkDownloadDetails).ConfigureAwait(false);
      await this.DeleteBulkDownloadStatusAsync(bulkLinkId).ConfigureAwait(false);
    }

    private async Task SendEmailForBulkLinkDownloadAsync(DocumentDetails docDetails, string hostedDomain, string bulkId, string fileId, string userEmail, string userName, string userId, string organizationId)
    {
      string url = string.Join(string.Empty, $"{hostedDomain}/api/DocumentManipulator/DownloadCompletedBulkFiles/?bulkId={bulkId}&fileId={fileId}&organizationId={organizationId}");
      await this.PrepareAndSendEmailAsync(docDetails, url, MethodName.DownLoadBulkDocuments, userEmail, userName, userId).ConfigureAwait(false);
    }

    private async Task<bool> UpdateBulkDownloadStatusAsync(string bulkId, string fileId)
    {
      BulkDownloadStatus bulkDownloadStatus = new BulkDownloadStatus
      {
        BulkLinkId = bulkId,
        OrgId = this.userDataService.OrganizationId,
        FileId = fileId,
      };

      var queryable = this.documentRepositoryService.GetQueryable<BulkDownloadStatus>(
        DbConstants.BulkDownloadStatus);
      var bulkDownloadStatusEntry = await queryable.Where(f => f.BulkLinkId == bulkId && f.OrgId == this.userDataService.OrganizationId).FirstOrDefaultItemAsync().ConfigureAwait(false);

      if (bulkDownloadStatusEntry != null)
      {
        return true;
      }

      await this.documentRepositoryService.CreateDocumentAsync(bulkDownloadStatus, DbConstants.BulkDownloadStatus).ConfigureAwait(false);
      return false;
    }

    private async Task<bool> DeleteBulkDownloadStatusAsync(string bulkId)
    {
      await this.documentRepositoryService.DeleteDocumentAsync<BulkDownloadStatus>(DbConstants.BulkDownloadStatus, this.userDataService.OrganizationId, bulkId).ConfigureAwait(false);
      return true;
    }

    private async Task<string> GetDownloadedZipPathAsync(string bulkFileDirectory, string bulkLinkId, string formTitle, List<LinkSignerDetails> completedLinkSignerDetails, bool isIndividualDownload, bool isCombineAudit, bool isEnablePrintAndSign, CancellationToken token)
    {
      string finalPath = Path.Combine(bulkFileDirectory, bulkLinkId);
      Directory.CreateDirectory(finalPath);
      List<string> documentOrFolderNames = new List<string>();
      foreach (var signer in completedLinkSignerDetails)
      {
        string finalFilePath;
        string documentOrFolderName = await this.downloadAuditTrailService.GetFileNameForDownload(signer, $"{formTitle}-{signer.SignerName}").ConfigureAwait(false);
        string finalName = this.GenerateFileName(documentOrFolderName, documentOrFolderNames);

        if (isIndividualDownload && !isEnablePrintAndSign)
        {
          string finalIndividualPath = Path.Combine(finalPath, finalName);
          Directory.CreateDirectory(finalIndividualPath);
          List<string> fileNames = new List<string>();
          BlobContainerClient blobContainer =
            await this.CloudStorage.GetContainer(signer.DocumentId, signer.SenderOrgId).ConfigureAwait(false);
          var blobs = await blobContainer.GetBlobsAsync(prefix: DbConstants.IndividualDocumentSigned)
            .AsPages(pageSizeHint: 25)
            .FirstOrDefaultAsync(token)
            .ConfigureAwait(false);

          foreach (var blob in blobs.Values)
          {
            string fileName = Path.GetFileName(blob.Name);
            finalFilePath = Path.Combine(finalIndividualPath, $"{fileName}.pdf");
            await this.DownLoadToPathAsync(blobContainer, blob.Name, finalFilePath, token).ConfigureAwait(false);
          }

          if (isCombineAudit)
          {
            finalFilePath = Path.Combine(finalIndividualPath, $"{AuditLog}.pdf");
            await this.DownloadDocumentAsync(signer.DocumentId, finalFilePath, DbConstants.IndividualDocumentAuditTrail, signer.SenderOrgId, token).ConfigureAwait(false);
          }
        }
        else
        {
          finalFilePath = Path.Combine(finalPath, $"{finalName}.pdf");
          await this.DownloadDocumentAsync(signer.DocumentId, finalFilePath, DbConstants.DocumentSigned, signer.SenderOrgId, token).ConfigureAwait(false);
        }
      }

      string zipFilePath = Path.Combine(bulkFileDirectory, $"{bulkLinkId}.zip");
      System.IO.Compression.ZipFile.CreateFromDirectory(finalPath, zipFilePath);
      return zipFilePath;
    }

    private string GetFileName(bool isSameNameSigner, string fileName, LinkSignerDetails signer, int sameSignerCount)
    {
      return isSameNameSigner
        ? $"{fileName}-{signer.SignerName}-{signer.SignerStatus}-{sameSignerCount}.pdf"
        : $"{fileName}-{signer.SignerName}-{signer.SignerStatus}.pdf";
    }

    private async Task UploadTaggedPdfContent(PdfLoadedDocument pdfLoadedDocument, string rootFolderId, string subFolderId, int pageIndex, string organizationId)
    {
      try
      {
        var storageFolder = string.Empty;
        BlobContainerClient cloudBlobContainer =
          await this.CloudStorage.GetContainer(rootFolderId, organizationId).ConfigureAwait(false);
        var taggedDetails = new List<TaggedText>();
        PdfLoadedPage loadedPage = pdfLoadedDocument.Pages[pageIndex] as PdfLoadedPage;
        var rootElement = loadedPage?.StrutureElements;
        if (rootElement != null)
        {
          foreach (PdfStructureElement childElement in rootElement)
          {
            var taggedText = GetTaggedText(childElement, pageIndex);
            taggedDetails.Add(taggedText);
          }
        }

        if (rootFolderId != subFolderId)
        {
          storageFolder = $"{subFolderId}/";
        }

        var blockBlob = cloudBlobContainer.GetBlobClient($"{storageFolder}taggedtext-{pageIndex}-1");
        var serializedData = BinarySerializer.Serialize(taggedDetails);
        await this.CloudStorage.UploadFromByteArrayAsync(blockBlob, serializedData, 0, true).ConfigureAwait(false);

        taggedDetails.Clear();
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileCheckingTaggedPdf);
      }
    }

    private static TaggedText GetTaggedText(PdfStructureElement pdfStructureElement, int pageNumber)
    {
      TaggedText taggedText = new TaggedText();
      List<TaggedText> childTags = new List<TaggedText>(pdfStructureElement.ChildElements.Length);

      if (pdfStructureElement.Page != null)
      {
        string parentTagType = pdfStructureElement.Parent.TagType.ToString();
        taggedText = new TaggedText()
        {
          Order = pdfStructureElement.Order,
          TagType = pdfStructureElement.TagType.ToString(),
          ParentTagType = parentTagType,
          Text = pdfStructureElement.Text,
          Bounds = pdfStructureElement.Bounds,
          PageNumber = pageNumber,
        };
      }

      if (pdfStructureElement.ChildElements.Length > 0)
      {
        foreach (PdfStructureElement childElement in pdfStructureElement.ChildElements)
        {
          childTags.Add(GetTaggedText(childElement, pageNumber));
        }

        taggedText.ChildElements = childTags;
      }

      return taggedText;
    }

    private async Task PrepareAndSendEmailAsync(DocumentDetails docDetails, string url, MethodName methodForMessageDetails, string userEmail, string userName, string userId)
    {
      var recipientDetails = this.GetRecipientDetails(docDetails, userId, url, userEmail, userName);
      var participants = new List<RecipientDetails>
      {
        recipientDetails,
      };

      BuildQueueDetails emailSettings = new BuildQueueDetails
      {
        DocumentDetails = docDetails,
        Participants = participants,
        BulkDownloadLinkExpireDate = DateTime.Now.AddDays(7).ToString("MMMM dd, yyyy", CultureInfo.InvariantCulture),
      };

      MessageDetails messageDetails = HelperMethods.GetMessageDetails(methodForMessageDetails, emailSettings);
      await this.emailHandler.SendEmail(messageDetails, docDetails.OrganizationId).ConfigureAwait(false);
    }

    private RecipientDetails GetRecipientDetails(DocumentDetails docDetails, string userId, string url, string userEmail, string userName)
    {
      return new RecipientDetails()
      {
        Name = userName,
        EmailAddress = userEmail,
        Type = RecipientType.ResourceOwner,
        SignerType = SignerType.Signer,
        Url = url,
        UserId = userId,
        OrganizationId = docDetails.OrganizationId,
        Language = docDetails.SignerDetails[0].SelectedLanguage,
      };
    }

    private void SendSmsForSingleSignerCompletion(DocumentDetails docDetails, BoldSign.Base.Models.SignerDetails signerDetail, string hostedDomain)
    {
      if (docDetails.DisableSMS || !HelperMethods.HasSMSDelivery(signerDetail.DeliveryMode))
      {
        return;
      }

      this.SendSMSOrWhatsAppForSingleSignerCompletion(docDetails, signerDetail, hostedDomain, true);
    }

    private void SendWhatsAppForSingleSignerCompletion(DocumentDetails docDetails, BoldSign.Base.Models.SignerDetails signerDetail, string hostedDomain)
    {
      if (signerDetail.DeliveryMode != DeliveryMode.WhatsApp)
      {
        return;
      }

      this.SendSMSOrWhatsAppForSingleSignerCompletion(docDetails, signerDetail, hostedDomain, false);
    }

    private void SendSMSOrWhatsAppForSingleSignerCompletion(DocumentDetails docDetails, BoldSign.Base.Models.SignerDetails signerDetail, string hostedDomain, bool isSMSDelivery)
    {
      var link = HelperMethods.GetSMSLink(hostedDomain, docDetails.Id, signerDetail.UnhashedSignerId, false);
      var smsMessageDetails = new SMSMessageDetails()
      {
        DocumentName = isSMSDelivery ? HelperMethods.GetTruncatedName(docDetails.MessageTitle, true) : docDetails.MessageTitle,
        Link = link,
        SelectedLanguage = signerDetail.SelectedLanguage,
      };
      var smsDetail = new SMSDetail { SMSMessageDetails = smsMessageDetails, SMSActionType = SMSActionType.SingleSignerCompleted, };
      if (isSMSDelivery)
      {
        _ = this.twilioSmsService.SendSmsNotificationAsync(docDetails, signerDetail, smsDetail);
      }
      else
      {
        _ = this.twilioSmsService.SendWhatsAppNotificationAsync(docDetails, signerDetail, smsDetail);
      }
    }

    private void SendSMSForAllSignerCompleted(DocumentDetails docDetails, List<BoldSign.Base.Models.SignerDetails> signerDetails, string hostedDomain)
    {
      if (!docDetails.DisableSMS && signerDetails.Count > 1 && signerDetails.Any(x => HelperMethods.HasSMSDelivery(x.DeliveryMode)))
      {
        this.SendSMSOrWhatsAppForAllSignerCompleted(docDetails, signerDetails, hostedDomain, true);
      }
    }

    private void SendWhatsAppForAllSignerCompleted(DocumentDetails docDetails, List<BoldSign.Base.Models.SignerDetails> signerDetails, string hostedDomain)
    {
      if (signerDetails.Count > 1 && signerDetails.Any(x => x.DeliveryMode == DeliveryMode.WhatsApp))
      {
        this.SendSMSOrWhatsAppForAllSignerCompleted(docDetails, signerDetails, hostedDomain, false);
      }
    }

    private void SendSMSOrWhatsAppForAllSignerCompleted(DocumentDetails docDetails, List<BoldSign.Base.Models.SignerDetails> signerDetails, string hostedDomain, bool isSMSDelivery)
    {
      var signerList = signerDetails.Where(x => (isSMSDelivery ? HelperMethods.HasSMSDelivery(x.DeliveryMode) : x.DeliveryMode == DeliveryMode.WhatsApp) && !string.IsNullOrEmpty(x.PhoneNumberWithCountryCode)).ToList();
      signerList = signerList.GroupBy(x => x.PhoneNumberWithCountryCode).Select(x => x.First()).ToList();
      foreach (var signerDetail in signerList)
      {
        var link = HelperMethods.GetSMSLink(hostedDomain, docDetails.Id, signerDetail.UnhashedSignerId, false);
        var smsMessageDetails = new SMSMessageDetails()
        {
          DocumentName = isSMSDelivery ? HelperMethods.GetTruncatedName(docDetails.MessageTitle, true) : docDetails.MessageTitle,
          Link = link,
          SelectedLanguage = signerDetail.SelectedLanguage,
        };
        var smsDetail = new SMSDetail { SMSMessageDetails = smsMessageDetails, SMSActionType = SMSActionType.AllSignerCompleted, };
        if (isSMSDelivery)
        {
          _ = this.twilioSmsService.SendSmsNotificationAsync(docDetails, signerDetail, smsDetail);
        }
        else
        {
          _ = this.twilioSmsService.SendWhatsAppNotificationAsync(docDetails, signerDetail, smsDetail);
        }
      }
    }

    private (bool, T) CheckAuthorizationAndGetDetails<T>(AuthorizationResult authorizationResult, Func<HttpContext, T> getDetailsFunc)
    {
      if (!authorizationResult.Succeeded)
      {
        return (false, default);
      }

      var details = getDetailsFunc(this.httpContext);
      if (details == null)
      {
        throw new InvalidDataException(CommonResource.DocumentDetailsMissing);
      }

      return (true, details);
    }

    private async Task<string> GetDownloadUrl(string containerId, string fileId, string title, string organizationId)
    {
      BlobContainerClient cloudBlobContainer =
        await this.CloudStorage.GetBrandLogoContainer(containerId, organizationId).ConfigureAwait(false);
      BlobClient documentBlob = cloudBlobContainer.GetBlobClient($"csv/{fileId}/{title}.csv");
      var downloadUrl = CloudStorage.GetServiceSasUriForBlob(documentBlob);
      Uri.TryCreate($"{BoldSignBase.EnvironmentVariables.ThumbImageBaseUrl}{downloadUrl.PathAndQuery.Remove(0, 1)}", UriKind.Absolute, out downloadUrl);
      return downloadUrl.ToString();
    }

    private async Task<string> GetBulkSendDownloadedZipPathAsync(string bulkFileDirectory, string bulkSendDocumentId, string title, List<AccessRightsDetailsExtend> bulkSendDocumentsDetails, bool isIndividualDownload, bool isCombineAudit, bool isEnablePrintAndSign, CancellationToken token)
    {
      string finalPath = Path.Combine(bulkFileDirectory, bulkSendDocumentId);
      Directory.CreateDirectory(finalPath);
      List<string> documentOrFolderNames = new List<string>();

      foreach (var document in bulkSendDocumentsDetails)
      {
        string finalFilePath;
        string documentOrFolderName = await this.downloadAuditTrailService.GetFileNameForDownload(document, $"{document.MessageTitle}-{document.SignerDetails.FirstOrDefault()?.SignerName}").ConfigureAwait(false);
        string finalName = this.GenerateFileName(documentOrFolderName, documentOrFolderNames);
        if (isIndividualDownload && !isEnablePrintAndSign)
        {
          string finalIndividualPath = Path.Combine(finalPath, finalName);
          Directory.CreateDirectory(finalIndividualPath);
          List<string> fileNames = new List<string>();
          BlobContainerClient blobContainer = await this.CloudStorage
            .GetContainer(document.DocumentId, document.SenderDetail.OrganizationId).ConfigureAwait(false);
          var blobs = await blobContainer.GetBlobsAsync(prefix: DbConstants.IndividualDocumentSigned)
            .AsPages(pageSizeHint: 25)
            .FirstOrDefaultAsync(token)
            .ConfigureAwait(false);

          foreach (var blob in blobs.Values)
          {
            string fileName = Path.GetFileName(blob.Name);
            finalFilePath = Path.Combine(finalIndividualPath, $"{fileName}.pdf");
            await this.DownLoadToPathAsync(blobContainer, blob.Name, finalFilePath, token).ConfigureAwait(false);
          }

          if (isCombineAudit)
          {
            finalFilePath = Path.Combine(finalIndividualPath, $"{AuditLog}.pdf");
            await this.DownloadDocumentAsync(document.DocumentId, finalFilePath, DbConstants.IndividualDocumentAuditTrail, document.SenderDetail.OrganizationId, token).ConfigureAwait(false);
          }
        }
        else
        {
          finalFilePath = Path.Combine(finalPath, $"{finalName}.pdf");
          await this.DownloadDocumentAsync(document.DocumentId, finalFilePath, DbConstants.DocumentSigned, document.SenderDetail.OrganizationId, token).ConfigureAwait(false);
        }
      }

      string zipFilePath = Path.Combine(bulkFileDirectory, $"{bulkSendDocumentId}.zip");
      System.IO.Compression.ZipFile.CreateFromDirectory(finalPath, zipFilePath);
      return zipFilePath;
    }

    private async Task DownloadLargeSizeBulkSendDocumentsAsync(string bulkSendDocumentId, string fileId, BulkSendDetails bulkSendDetails, List<AccessRightsDetailsExtend> bulkSendDocumentsDetails, DocumentDetails defaultDetails, CancellationToken token)
    {
      var currentUserEmail = this.userDataService.Email;
      var currentUserName = this.userDataService.Name;
      var currentUserId = this.userDataService.Id;
      string bulkFileDirectory = Path.Combine(Directory.GetCurrentDirectory(), $"download/{fileId}");
      var individualDownload = defaultDetails.EnableIndividualDocumentDownloads || defaultDetails.DocumentDownloadOption == DocumentDownloadOption.Individually;
      string zipFilePath = await this.GetBulkSendDownloadedZipPathAsync(bulkFileDirectory, bulkSendDocumentId, bulkSendDetails.Title, bulkSendDocumentsDetails, individualDownload, defaultDetails.CombineAuditTrail, defaultDetails.EnablePrintAndSign, token).ConfigureAwait(false);
      var organizationId = this.userDataService.OrganizationId;
      await this.UploadZipFileAsync(bulkSendDocumentId, fileId, bulkSendDetails.Title, zipFilePath, bulkFileDirectory, organizationId, token).ConfigureAwait(false);
      _ = this.SendEmailForBulkSendDownloadAsync(defaultDetails, this.requestDetailsService.HostedDomain, bulkSendDocumentId, fileId, currentUserEmail, currentUserName, currentUserId, organizationId).ConfigureAwait(false);
      var bulkDownloadDetails = new BulkDownloadDetails
      {
        Id = Guid.NewGuid().ToString(),
        BulkLinkId = bulkSendDocumentId,
        BulkSendId = bulkSendDocumentId,
        FileId = fileId,
        ExpiryDate = DateTime.UtcNow.AddDays(7),
        Title = bulkSendDetails.Title,
        CompletedDocumentIds = bulkSendDocumentsDetails.Select(x => x.DocumentId).ToArray(),
      };

      await this.documentRepositoryService.CreateDocumentAsync(bulkDownloadDetails, DbConstants.BulkDownloadDetails).ConfigureAwait(false);
    }

    private async Task<byte[]> GenerateZipFileAsync<TData>(string fileId, string bulkId, string title, List<TData> documentDetails, DocumentDetails docDetails, Func<string, string, string, List<TData>, bool, bool, bool, CancellationToken, Task<string>> getDownloadedZipPathFunc, CancellationToken token)
    {
      string bulkFileDirectory = Path.Combine(Directory.GetCurrentDirectory(), $"download/{fileId}");
      var individualDownload = docDetails.EnableIndividualDocumentDownloads || docDetails.DocumentDownloadOption == DocumentDownloadOption.Individually;
      string zipFilePath = await getDownloadedZipPathFunc(bulkFileDirectory, bulkId, title, documentDetails, individualDownload, docDetails.CombineAuditTrail, docDetails.EnablePrintAndSign, token).ConfigureAwait(false);
      byte[] byteArray = await File.ReadAllBytesAsync(zipFilePath).ConfigureAwait(false);
      Directory.Delete(bulkFileDirectory, true);
      return byteArray;
    }

    private async Task<IActionResult> ProcessDownloadedBulkAsync(string bulkId, string fileId, string title, string downloadedBulkId, DocumentDetails documentDetails, BulkDownloadDetails downloadedBulk, Func<DocumentDetails, string, string, string, string, string, string, string, Task> sendEmailFunc, bool isBulkLinkDownload = false)
    {
      BlobContainerClient cloudBlobContainer =
        await this.CloudStorage.GetContainer(bulkId, documentDetails.OrganizationId).ConfigureAwait(false);
      BlobClient documentBlob = cloudBlobContainer.GetBlobClient($"{fileId}/{title}.zip");
      if (await documentBlob.ExistsAsync().ConfigureAwait(false))
      {
        downloadedBulk.ExpiryDate = DateTime.UtcNow.AddDays(7);
        await this.documentRepositoryService.ReplaceDocumentAsync(downloadedBulk, DbConstants.BulkDownloadDetails, downloadedBulk.Id, bulkId).ConfigureAwait(false);
        _ = sendEmailFunc(documentDetails, this.requestDetailsService.HostedDomain, bulkId, downloadedBulk.FileId, this.userDataService.Email, this.userDataService.Name, this.userDataService.Id, documentDetails.OrganizationId).ConfigureAwait(false);
        if (isBulkLinkDownload)
        {
          await this.DeleteBulkDownloadStatusAsync(bulkId).ConfigureAwait(false);
          return new OkObjectResult(new { message = CommonResource.BulkDocumentDownload, currentDate = DateTime.Now });
        }

        return new OkObjectResult(new { message = CommonResource.BulkSendDocumentDownload, currentDate = DateTime.Now });
      }

      await this.documentRepositoryService.DeleteDocumentAsync<BulkDownloadDetails>(DbConstants.BulkDownloadDetails, downloadedBulk.Id, downloadedBulkId).ConfigureAwait(false);
      return null;
    }

    private async Task UploadZipFileAsync(string id, string fileId, string title, string zipFilePath, string bulkFileDirectory, string organizationId, CancellationToken token)
    {
      BlobContainerClient cloudBlobContainer = null;
      cloudBlobContainer = await this.CloudStorage.GetBrandLogoContainer(id, organizationId).ConfigureAwait(false);
      await this.CloudStorage.CreateContainer(cloudBlobContainer, organizationId, token).ConfigureAwait(false);

      var blobClientDocument = cloudBlobContainer.GetBlobClient($"{fileId}/{title}.zip");
      await this.CloudStorage.UploadFromPathAsync(blobClientDocument, zipFilePath, false, token).ConfigureAwait(false);
      await blobClientDocument.SetTagsAsync(new Dictionary<string, string>() { { BoldSignBase.EnvironmentVariables.BulkBlobMetaDataKey, BoldSignBase.EnvironmentVariables.BulkBlobMetaDataValue } }).ConfigureAwait(false);
      Directory.Delete(bulkFileDirectory, true);
    }

    private async Task SendEmailForBulkSendDownloadAsync(DocumentDetails docDetails, string hostedDomain, string bulkSendId, string fileId, string userEmail, string userName, string userId, string organizationId)
    {
      string url = string.Join(string.Empty, $"{hostedDomain}/api/DocumentManipulator/DownloadBulkSendDocumentsFromLink/?bulkSendId={bulkSendId}&fileId={fileId}&organizationId={organizationId}");
      await this.PrepareAndSendEmailAsync(docDetails, url, MethodName.DownLoadBulkDocuments, userEmail, userName, userId).ConfigureAwait(false);
    }

    private async Task<string> GetDocumentDownloadUrl(string containerId, string fileId, string title, string organizationId)
    {
      BlobContainerClient cloudBlobContainer =
        await this.CloudStorage.GetBrandLogoContainer(containerId, organizationId).ConfigureAwait(false);
      BlobClient documentBlob = cloudBlobContainer.GetBlobClient($"{fileId}/{title}.zip");
      var downloadUrl = CloudStorage.GetServiceSasUriForBlob(documentBlob);
      Uri.TryCreate($"{BoldSignBase.EnvironmentVariables.ThumbImageBaseUrl}{downloadUrl.PathAndQuery.Remove(0, 1)}", UriKind.Absolute, out downloadUrl);
      return downloadUrl.ToString();
    }

    private async Task<IActionResult> GenerateAndReturnZipFileAsync<TData>(string fileId, string bulkId, string title, List<TData> documentDetails, DocumentDetails docDetails, Func<string, string, string, List<TData>, bool, bool, bool, CancellationToken, Task<string>> zipPathGetter, CancellationToken token)
    {
      byte[] byteArray = await this.GenerateZipFileAsync(fileId, bulkId, title, documentDetails, docDetails, zipPathGetter, token).ConfigureAwait(false);
      return new FileContentResult(byteArray, Constants.ZipContentType)
      {
        FileDownloadName = $"{title}.zip",
      };
    }

    private bool IsFileSizeWithinLimit<TData>(DocumentDetails documentDetails, List<TData> completedDocumentDetails)
    {
      var totalFileSize = documentDetails.DocumentProperties.Select(x => x.FileSize).Sum();
      return totalFileSize * completedDocumentDetails.Count <= BulkDocumentSizeLimit;
    }

    private void ValidateBulkSendId(string bulkSendId)
    {
      if (string.IsNullOrEmpty(bulkSendId))
      {
        throw new InvalidDataException(CommonResource.InvalidBulkSendDocumentId);
      }
    }

    private void ValidateBulkLinkId(string bulkLinkId)
    {
      if (string.IsNullOrEmpty(bulkLinkId))
      {
        throw new InvalidDataException(CommonResource.InvalidDocumentId);
      }
    }

    private void LogErrorAndThrow(Exception ex)
    {
      this.logger.LogError(ex.Message);
    }

    private string GenerateFileName(string fileName, List<string> fileNames)
    {
      fileNames.Add(fileName.ToLowerInvariant());
      if (fileNames.Count(x => x == fileName.ToLowerInvariant()) > 1)
      {
        return $"{fileName}[{fileNames.Count(x => x == fileName.ToLowerInvariant()) - 1}]";
      }

      return fileName;
    }

    private async Task DownloadDocumentAsync(string id, string finalFilePath, string blobName, string organizationId, CancellationToken token)
    {
      BlobContainerClient blobContainer = await this.CloudStorage.GetContainer(id, organizationId).ConfigureAwait(false);
      await this.DownLoadToPathAsync(blobContainer, blobName, finalFilePath, token).ConfigureAwait(false);
    }

    private async Task DownLoadToPathAsync(BlobContainerClient blobContainer, string blobName, string finalFilePath, CancellationToken token)
    {
      BlobClient documentBlob = blobContainer.GetBlobClient(blobName);
      var isSignedDocumentExist = await documentBlob.ExistsAsync(token).ConfigureAwait(false);
      if (isSignedDocumentExist)
      {
        await this.CloudStorage.DownloadToPathAsync(documentBlob, finalFilePath, true, token).ConfigureAwait(false);
      }
    }

    private async Task LogDownloadBulkLinkActivity(DocumentDetails documentDetails, string bulkLinkId)
    {
      await this.orgActivityService.Add(EventAction.Downloaded, EventCategory.Forms, targetSource: documentDetails.FormTitle, sourceId: bulkLinkId).ConfigureAwait(false);
    }

    private Syncfusion.Drawing.RectangleF GetTextBounds(FormElement field, PdfUnitConverter converter, float lineSpacing, bool isBackgroundColor = false)
    {
      var paddingLeft = isBackgroundColor ? 0 : converter.ConvertFromPixels(field.PaddingLeft, PdfGraphicsUnit.Point);
      var paddingTop = isBackgroundColor ? 0 : converter.ConvertFromPixels(field.PaddingTop, PdfGraphicsUnit.Point);

      return new Syncfusion.Drawing.RectangleF(
        converter.ConvertFromPixels(field.Bounds.X, PdfGraphicsUnit.Point) + paddingLeft,
        converter.ConvertFromPixels(field.Bounds.Y, PdfGraphicsUnit.Point) + paddingTop,
        converter.ConvertFromPixels(field.Bounds.Width, PdfGraphicsUnit.Point),
        converter.ConvertFromPixels(field.Bounds.Height, PdfGraphicsUnit.Point) + lineSpacing);
    }

    private async Task CopyBlobAsync(BlobContainerClient sourceContainer, BlobContainerClient targetContainer, string blobName)
    {
      var sourceBlob = sourceContainer.GetBlobClient(blobName);
      var targetBlob = targetContainer.GetBlobClient(blobName);
      await targetBlob.StartCopyFromUriAsync(sourceBlob.Uri).ConfigureAwait(false);
    }

    private async Task DeleteThumbnailBlobs(BlobContainerClient cloudBlobContainer, string prefix)
    {
      var resultSegment = cloudBlobContainer.GetBlobsByHierarchyAsync(prefix: prefix, delimiter: "/")
        .AsPages(default, BlobRequestCount);

      await foreach (var blobPage in resultSegment)
      {
        var blobsToDelete = blobPage.Values
          .Where(blobHierarchyItem => blobHierarchyItem.IsBlob &&
                                      (!string.IsNullOrEmpty(prefix)
                                        ? blobHierarchyItem.Blob.Name.Split('/')[1].Contains(DbConstants.Thumbnail)
                                        : blobHierarchyItem.Blob.Name.Contains(DbConstants.Thumbnail)))
          .Select(blobHierarchyItem => blobHierarchyItem.Blob.Name)
          .ToList();

        var deleteTasks = blobsToDelete.Select(blobName => cloudBlobContainer.DeleteBlobAsync(blobName)).Cast<Task>().ToList();

        await Task.WhenAll(deleteTasks).ConfigureAwait(false);
      }
    }

    private static PdfAuditTableDesign GetEditedDocumentLogs(AuditTrail auditTrail, string timeStamp)
    {
      var logBuilder = new StringBuilder($"{auditTrail.Name} ({auditTrail.Email}) has made edits to the document.");
      if (auditTrail.RecipientChangeLogs != null)
      {
        var addLogs = new List<string>();
        var removedLogs = new List<string>();
        foreach (var recipientChangeLog in auditTrail.RecipientChangeLogs)
        {
          switch (recipientChangeLog.Type)
          {
            case ChangeType.Add:
              addLogs.Add($"{recipientChangeLog.SignerName} ({GetSignerEmailOrPhone(recipientChangeLog.SignerEmail, recipientChangeLog.PhoneNumber)})");
              break;
            case ChangeType.Remove:
              removedLogs.Add($"{recipientChangeLog.OldSignerName} ({GetSignerEmailOrPhone(recipientChangeLog.OldSignerEmail, recipientChangeLog.OldPhoneNumber)})");
              break;
            case ChangeType.Update:
              addLogs.Add($"{recipientChangeLog.SignerName} ({GetSignerEmailOrPhone(recipientChangeLog.SignerEmail, recipientChangeLog.PhoneNumber)})");
              removedLogs.Add($"{recipientChangeLog.OldSignerName} ({GetSignerEmailOrPhone(recipientChangeLog.OldSignerEmail, recipientChangeLog.OldPhoneNumber)})");
              break;
          }
        }

        if (addLogs.Any())
        {
          logBuilder.AppendLine().Append($"\nAdded {string.Join(", ", addLogs)} as a recipient.");
        }

        if (removedLogs.Any())
        {
          logBuilder.AppendLine().Append($"\nRemoved {string.Join(", ", removedLogs)} as a recipient.");
        }
      }

      return new PdfAuditTableDesign(
        "Edited: ",
        logBuilder.ToString(),
        timeStamp,
        auditTrail.Email,
        $"IP: {auditTrail.IPAddress}");
    }

    private static string GetSignerEmailOrPhone(string signerEmail, string signerPhoneNumber)
    {
      var signerEmailOrPhone = !string.IsNullOrEmpty(signerEmail) && !string.IsNullOrEmpty(signerPhoneNumber)
        ? $"{signerEmail} / {signerPhoneNumber}"
        : !string.IsNullOrEmpty(signerPhoneNumber) ? signerPhoneNumber : signerEmail;

      return signerEmailOrPhone;
    }

    private static float GetZoomFactor(string documentVersion)
    {
      return documentVersion switch
      {
        "v2" => Version2ZoomFactor,
        _ => Version1ZoomFactor
      };
    }

    private async Task<JsonResult> AddEvroTrustSignatureAsync(
    MemoryStream documentStream,
    string searchQueryType,
    string searchQuery,
    string countryCode,
    string documentId,
    DocumentDetails documentDetails,
    bool isIndividualDocument,
    string childId)
    {
      var loadedDocument = new PdfLoadedDocument(documentStream);
      var page = loadedDocument.Pages[0] as PdfLoadedPage;
      var evroTrustSignature = new PdfSignature(loadedDocument, page, null, $"{documentId}_EvroTrust")
      {
        Bounds = new Syncfusion.Drawing.RectangleF(0, 0, 0, 0),
      };

      bool isTestEnvironment = documentDetails.ApplicationEnvironment.IsSandboxMode();
      var (email, phoneNumber, identificationNumber) = ExtractUserDetails(searchQueryType, searchQuery);
      var evroCertificateDetails = await this.evroTrustApiService
          .GetUserCertificateAsync(email, countryCode, phoneNumber, identificationNumber, isTestEnvironment);

      if (evroCertificateDetails.StatusCode != 0)
      {
        return new JsonResult(new EvroTrustResponse
        {
          StatusCode = evroCertificateDetails.StatusCode,
        });
      }

      var certBytes = Convert.FromBase64String(evroCertificateDetails.Certificate);
      var certificate = new X509Certificate2(certBytes);
      var chain = new X509Chain();
      chain.Build(certificate);
      var certificateDetail = chain.ChainElements.Select(t => t.Certificate).ToList();

      evroTrustSignature.Settings.DigestAlgorithm = DigestAlgorithm.SHA256;
      evroTrustSignature.SignedName = "BoldSign®";
      PdfSignatureSettings settings = evroTrustSignature.Settings;
      settings.CryptographicStandard = CryptographicStandard.CADES;
      var signer = new EvroTrustSignatureService(
          "SHA256",
          this.evroTrustApiService,
          documentDetails.MessageTitle,
          email,
          phoneNumber,
          identificationNumber,
          countryCode,
          documentId,
          isIndividualDocument,
          isTestEnvironment);

      evroTrustSignature.AddExternalSigner(signer, certificateDetail, null);

      using var ms = new MemoryStream();
      loadedDocument.Save(ms);
      var cloudBlobContainer = await this.CloudStorage
          .GetContainer(documentId, documentDetails.OrganizationId);
      var blobName = documentId == childId ? $"{EvrotrustDocument}" : $"{childId}/{EvrotrustDocument}";
      var blob = cloudBlobContainer.GetBlobClient(blobName);
      await this.CloudStorage.UploadFromStreamAsync(blob, ms, true);

      // Return the result based on document type
      if (!isIndividualDocument)
      {
        // Retrieve the response from signer
        var response = signer.GetSendForSignResponse();
        return new JsonResult(response);
      }

      // Retrieve the hash for individual documents
      var documentHash = signer.GetDocumentHash();
      return new JsonResult(documentHash);
    }
    private FormElement CreateFormElementsFromPdfField(BoldSign.ApiManagement.Models.FieldType? field, BoldSign.ApiManagement.Models.Rectangle bounds, BoldSign.ApiManagement.Models.TextTags.Models.TextTagDefinition tag)
    {
      FormElement formElement = new FormElement();


      BoldSign.Base.Models.Rectangle bound = new BoldSign.Base.Models.Rectangle()
      {
        X = bounds.X,
        Y = bounds.Y,
        Height = bounds.Height,
        Width = bounds.Width
      };

      switch (field)
      {
        case BoldSign.ApiManagement.Models.FieldType.TextBox:
          {
            formElement.ElementType = "TextBox";
            if (tag.Font != null)
            {
              formElement.FontFamily = (tag.Font.Name).ToString();
              formElement.FontSize = tag.Font.Size;
              formElement.FontColor = tag.Font.Color;
            }
            formElement.EnableWrapping = true;
            formElement.Bounds = bound;
            formElement.MaxHeight = bound.Height;
            formElement.MaxWidth = bound.Width;
            formElement.Index = tag.SignerIndex;
            // formElement.PlaceHolder=tag.Placeholder;
            // formElement.Value=tag.Placeholder;

          }

          break;
        case BoldSign.ApiManagement.Models.FieldType.Signature:
          formElement.ElementType = "Signature";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.Name).ToString();
            formElement.FontSize = tag.Font.Size;
            formElement.FontColor = tag.Font.Color;
          }
          formElement.EnableWrapping = false;
          formElement.Bounds = bound;
          formElement.MaxHeight = bounds.Height;
          formElement.MaxWidth = bounds.Width;
          break;

        case BoldSign.ApiManagement.Models.FieldType.EditableDate:
          formElement.ElementType = "EditableDate";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.Name).ToString();
            formElement.FontSize = tag.Font.Size;
            formElement.FontColor = tag.Font.Color;
          }
          // formElement.DateFormat=tag.EditableDateFieldSettings.DateFormat;
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          // formElement.DateFormat=tag.EditableDateFieldSettings.DateFormat;
          break;
        case BoldSign.ApiManagement.Models.FieldType.Initial:
          formElement.ElementType = "Initial";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.Name).ToString();
            formElement.FontSize = tag.Font.Size;
            formElement.FontColor = tag.Font.Color;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case BoldSign.ApiManagement.Models.FieldType.Title:
          formElement.ElementType = "Title";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.Name).ToString();
            formElement.FontSize = tag.Font.Size;
            formElement.FontColor = tag.Font.Color;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case BoldSign.ApiManagement.Models.FieldType.Company:
          formElement.ElementType = "Company";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.Name).ToString();
            formElement.FontSize = tag.Font.Size;
            formElement.FontColor = tag.Font.Color;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case BoldSign.ApiManagement.Models.FieldType.DateSigned:
          formElement.ElementType = "DateSigned";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.Name).ToString();
            formElement.FontSize = tag.Font.Size;
            formElement.FontColor = tag.Font.Color;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
      }
      formElement.Id = tag.SignerIndex.ToString();
      formElement.IsRequired = tag.IsRequired;
      formElement.AllowEditing = true;
      return formElement;
    }

    private FormElement CreateFormElementsFromPdfField(BoldSign.ApiManagement.Models.FieldType? field, BoldSign.ApiManagement.Models.Rectangle bounds, BoldSign.ApiManagement.Models.FormField tag)
    {
      FormElement formElement = new FormElement();

      BoldSign.Base.Models.Rectangle bound = new BoldSign.Base.Models.Rectangle()
      {
        X = bounds.X,
        Y = bounds.Y,
        Height = bounds.Height,
        Width = bounds.Width
      };

      switch (field)
      {
        case BoldSign.ApiManagement.Models.FieldType.TextBox:
          {
            formElement.ElementType = "TextBox";
            if (tag.Font != null)
            {
              formElement.FontFamily = tag.Font.ToString();
              formElement.FontSize = tag.FontSize;
              formElement.FontColor = tag.FontHexColor;
            }
            formElement.EnableWrapping = true;
            formElement.Bounds = bound;
            formElement.MaxHeight = bound.Height;
            formElement.MaxWidth = bound.Width;
            // formElement.PlaceHolder=tag.Placeholder;
            // formElement.Value=tag.Placeholder;

          }

          break;
        case BoldSign.ApiManagement.Models.FieldType.Signature:
          formElement.ElementType = "Signature";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.ToString());
            formElement.FontSize = tag.FontSize;
            formElement.FontColor = tag.FontHexColor;
          }
          formElement.EnableWrapping = false;
          formElement.Bounds = bound;
          formElement.MaxHeight = bounds.Height;
          formElement.MaxWidth = bounds.Width;
          break;

        case BoldSign.ApiManagement.Models.FieldType.EditableDate:
          formElement.ElementType = "EditableDate";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.ToString());
            formElement.FontSize = tag.FontSize;
            formElement.FontColor = tag.FontHexColor;
          }
          // formElement.DateFormat=tag.EditableDateFieldSettings.DateFormat;
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          // formElement.DateFormat=tag.EditableDateFieldSettings.DateFormat;
          break;
        case BoldSign.ApiManagement.Models.FieldType.Initial:
          formElement.ElementType = "Initial";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.ToString());
            formElement.FontSize = tag.FontSize;
            formElement.FontColor = tag.FontHexColor;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case BoldSign.ApiManagement.Models.FieldType.Title:
          formElement.ElementType = "Title";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.ToString());
            formElement.FontSize = tag.FontSize;
            formElement.FontColor = tag.FontHexColor;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case BoldSign.ApiManagement.Models.FieldType.Company:
          formElement.ElementType = "Company";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.ToString());
            formElement.FontSize = tag.FontSize;
            formElement.FontColor = tag.FontHexColor;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
        case BoldSign.ApiManagement.Models.FieldType.DateSigned:
          formElement.ElementType = "DateSigned";
          if (tag.Font != null)
          {
            formElement.FontFamily = (tag.Font.ToString());
            formElement.FontSize = tag.FontSize;
            formElement.FontColor = tag.FontHexColor;
          }
          formElement.Bounds = bound;
          formElement.MaxHeight = bound.Height;
          formElement.MaxWidth = bound.Width;
          break;
      }
      formElement.Id = tag.Id;
      formElement.IsRequired = tag.IsRequired;
      formElement.AllowEditing = true;
      return formElement;
    }

    private PageFormElements PrepareFormField(PdfLoadedDocument loadedDocument, BoldSign.ApiManagement.Models.TextTags.Models.TextTagDefinition tag, BoldSign.ApiManagement.Models.Rectangle bounds, BoldSign.ApiManagement.Models.FieldType? field)
    {
      List<FormElement> form = new List<FormElement>();
      FormElement formelement = this.CreateFormElementsFromPdfField(field, bounds, tag);
      if (formelement.ElementType != null)
      {
        form.Add(formelement);
      }

      PageFormElements preparedFields = new PageFormElements();
      preparedFields.PageIndex = 1;
      preparedFields.FormElements = form.ToArray();
      return preparedFields;
    }
    private PageFormElements PrepareFormField(PdfLoadedDocument loadedDocument, BoldSign.ApiManagement.Models.FormField tag, BoldSign.ApiManagement.Models.Rectangle bounds, BoldSign.ApiManagement.Models.FieldType? field)
    {
      List<FormElement> form = new List<FormElement>();
      FormElement formelement = this.CreateFormElementsFromPdfField(field, bounds, tag);
      if (formelement.ElementType != null)
      {
        form.Add(formelement);
      }

      PageFormElements preparedFields = new PageFormElements();
      preparedFields.PageIndex = 1;
      preparedFields.FormElements = form.ToArray();
      return preparedFields;
    }

  }
}
