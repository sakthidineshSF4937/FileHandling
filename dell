getSaveData (isDraft: boolean, fromMergeTemplate?: boolean): any {
      const reviewData: any = this.$session.reviewData;
      if (reviewData.expiryDateType === 'SpecificDateTime' && this.$data.signbuilderType !== 'createtemplate') {
        this.expiryDateUpdateForSpecificDateTimeType();
      }

      let uploadedDocumentList: DocumentProperties[] = this.$session.mainData.uploadedDocumentList;
      uploadedDocumentList = uploadedDocumentList.filter(x => x.isDocumentLoaded && !x.isFailed);
      let parentDocument: DocumentProperties = uploadedDocumentList[0];
      const mainData: any = this.$session.mainData;
      if (fromMergeTemplate && !parentDocument && mainData.removedDocumentList && mainData.removedDocumentList.length > 0) {
        parentDocument = mainData.removedDocumentList.find(x => x.parentId === '') || mainData.removedDocumentList[0];
      }
      const signerData: any = this.$session.signerData;
      const oAuthAppCreatorDetailsData: any = this.$session.oAuthAppCreatorDetailsData;
      const bulkLinkDocumentExpirySettings: any = this.$session.bulkLinkDocumentExpirySettings;
      const reminderSetting: ReminderSettings = { enableAutoReminder: reviewData.autoReminder, reminderDays: reviewData.reminderDays, reminderCount: reviewData.reminderCount };
      const signerDetails: any[] = [];
      const documentInfo: any[] = [];
      if (!this.$session.mainData.isSelfSign) {
        for (const signerDetail of signerData.signerDetails) {
          signerDetails.push(
            {
              signerId: signerDetail.id,
              signerEmail: signerDetail.signerMail,
              signerName: signerDetail.signerName,
              signerRole: signerDetail.signerRole,
              privateMessage: signerDetail.privateMessage,
              authenticationCode: signerDetail.authenticationCode,
              signerType: signerDetail.signerType,
              status: signerDetail.status,
              signerColor: signerDetail.color2,
              zOrder: signerDetail.zOrder,
              enableEditRecipients: signerDetail.enableEditRecipients,
              enableAccessCode: signerDetail.enableAccessCode,
              enableDeleteRecipients: signerDetail.enableDeleteRecipients,
              additionalRecipientVisibility: false,
              enableEmailOTP: signerDetail.enableEmailOTP,
              signerAuthType: signerDetail.signerAuthType,
              hostEmail: signerDetail.hostEmail,
              hostName: signerDetail.hostName,
              hostUserId: signerDetail.hostUserId,
              roleSignerId: signerDetail.roleSignerId,
              hostAccessUid: signerDetail.hostUserId,
              hostTeamId: signerDetail.hostTeamId,
              hostOrganizationId: signerDetail.hostOrganizationId,
              signType: signerDetail.signType,
              groupSignerDetails: this.getSigningGroupDetails(signerDetail.groupSignerDetails),
              selectedLanguage: signerDetail.selectedLanguage,
              deliveryMode: signerDetail.deliveryMode,
              enableSMSOTP: signerDetail.enableSMSOTP,
              phoneNumberWithCountryCode: signerDetail.phoneNumberWithCountryCode,
              signerIdVerificationSettings: signerDetail.signerIdVerificationSettings ? signerDetail.signerIdVerificationSettings : reviewData.idVerificationSettings,
              allowConfigureFields: signerDetail.allowConfigureFields,
              fieldRelationId: mainData.isEditDocument ? signerDetail.id : '',
              recipientNotificationSettingsData: signerDetail.recipientNotificationSettingsData ? signerDetail.recipientNotificationSettingsData : null,
              isPredefinedRole: signerDetail.isPredefinedRole,
              enableQualifiedElectronicSignature: signerDetail.enableQualifiedElectronicSignature,
              authenticationRetryCount: signerDetail.authenticationRetryCount ? signerDetail.authenticationRetryCount : null
            }
          );
          const isdocumetInfo = documentInfo.find(x => x.language === signerDetail.selectedLanguage);
          if (!isdocumetInfo) {
            const documentInfoDetails = signerData.documentInfo.find(x => x.language === signerDetail.selectedLanguage);
            documentInfo.push(documentInfoDetails);
          }
        }
      } else {
        const signerDetail: any = signerData.signerDetails[0];
        signerDetails.push({
          signerId: signerDetail.id,
          signerType: signerDetail.signerType,
          privateMessage: '',
          authenticationCode: '',
          enableEditRecipients: signerDetail.enableEditRecipients,
          enableDeleteRecipients: signerDetail.enableDeleteRecipients,
          additionalRecipientVisibility: false,
          status: 'NotCompleted',
          signerRole: signerDetail.signerRole,
          signerColor: signerDetail.color2,
          signerEmail: signerDetail.signerMail,
          signerName: signerDetail.signerName,
          zOrder: signerDetail.zOrder,
          selectedLanguage: signerDetail.selectedLanguage,
          phoneNumberWithCountryCode: '',
          signerIdVerificationSettings: signerDetail.signerIdVerificationSettings ? signerDetail.signerIdVerificationSettings : reviewData.idVerificationSettings,
          allowConfigureFields: false
        });
        const isdocumetInfo = documentInfo.find(x => x.language === signerDetail.selectedLanguage);
        if (!isdocumetInfo) {
          const documentInfoDetails = signerData.documentInfo.find(x => x.language === signerDetail.selectedLanguage);
          documentInfo.push(documentInfoDetails);
        }
      }
      const messageDetails = this.getMessageDetails(documentInfo);
      const messageTitle = messageDetails.title;
      const messageDescription = messageDetails.description;
      const enableCcFromHIPAA = UtilityMethods.EnableCCFromHIPAA(this.$session.HIPAAData);
      const documentDetails: DocumentDetails = {
        id: mainData.parentDocumentId,
        documentName: parentDocument.documentName,
        documentPageCount: parentDocument.pageCount,
        applicationEnvironment: mainData.applicationEnvironment,
        documentProperties: uploadedDocumentList,
        removedDocumentList: (isDraft || this.isEditTempateUpdate) ? mainData.removedDocumentList : [],
        replacedDocumentDetails: mainData.replacedDocDetails,
        uploadedDocumentDetails: mainData.uploadedDocDetails,
        resetStartPosition: mainData.resetStartPosition,
        isDocumentAddedorReplaced: mainData.isDocumentAddedorReplaced,
        ccDetails: (!enableCcFromHIPAA) ? [] : (signerData.ccDetails.filter((ccDetail: CCDetail): CCDetail => { return ccDetail.emailAddress ? ccDetail : null; })),
        messageDescription: messageDescription || signerData.messageDescription,
        messageTitle: messageTitle || signerData.messageTitle,
        signerDetails,
        expiryDays: reviewData.enableExpiryDays || this.$data.signbuilderType !== 'createlink' ? reviewData.expiryDays : 0,
        expiryDateType: reviewData.expiryDateType,
        selfOthers: mainData.selfOthers,
        onlyOthers: mainData.onlyOthers,
        isSelfSign: mainData.isSelfSign,
        enableSigningOrder: signerData.allowDraggable,
        expiryDate: reviewData.enableExpiryDays || this.$data.signbuilderType !== 'createlink' ? reviewData.expiryDate : null,
        bulkLinkDocumentExpirySettings: this.$data.signbuilderType === 'createlink' && bulkLinkDocumentExpirySettings.enableBulkLinkDocumentExpiry ? bulkLinkDocumentExpirySettings : null,
        uploadType: parentDocument.uploadType,
        warnDocumentExpiry: reviewData.warnDocumentExpiry,
        templateName: mainData.templateName,
        version: mainData.version || '1.0',
        templateVersion: mainData.templateVersion || 'v2',
        documentVersion: mainData.documentVersion,
        formTitle: mainData.formTitle,
        welcomeMessage: mainData.welcomeMessage,
        acknowledgementMessage: mainData.acknowledgementMessage,
        templateDescription: mainData.templateDescription,
        useTemplateDocumentId: mainData.useTemplateDocumentId,
        enableExpiration: true,
        reminderSettings: reminderSetting,
        enableSubjectEditing: signerData.enableSubjectEditing,
        enableAddAdditionalRecipients: signerData.enableAddAdditionalRecipients,
        enableAddAdditionalFiles: signerData.enableAddAdditionalFiles,
        enableReplaceOrDeleteFiles: signerData.enableReplaceOrDeleteFiles,
        enableDigitalSign: reviewData.enableDigitalSign,
        linkLimit: reviewData.enableLimit ? reviewData.linkLimit : 0,
        signerEmailValidationRegex: reviewData.enableRegex && reviewData.regexDescription ? reviewData.signerEmailValidationRegex : '',
        regexDescription: reviewData.enableRegex && reviewData.signerEmailValidationRegex ? reviewData.regexDescription : '',
        enablePrintAndSign: mainData.allowPrintAndSign ? reviewData.enablePrintAndSign : false,
        enableIndividualDocumentDownloads: false,
        documentDownloadOption: mainData.allowDownloadSeparateDocument ? reviewData.documentDownloadOption : 'Combined',
        selectedBrandID: this.validatedBrandId(reviewData),
        enableDocumentID: reviewData.enableDocumentID,
        enableLocalizationForAuditLogs: reviewData.enableLocalizationForAuditLogs,
        enableReassign: reviewData.enableReassign,
        senderTimeZone: reviewData.senderTimeZone,
        documentInfo,
        mergedTemplateIds: mainData.mergedTemplateIds,
        isMergeTemplate: mainData.isMergeTemplate,
        requireEmailVerification: mainData.requireEmailVerification,
        multipleSigningEnabled: reviewData.multipleSigningEnabled,
        isBulkSend: this.$data.signbuilderType === 'bulksend',
        oAuthAppCreatorDetails: (!isNullOrUndefined(oAuthAppCreatorDetailsData) && !isNullOrUndefined(oAuthAppCreatorDetailsData.organizationId)) ? oAuthAppCreatorDetailsData : null,
        inEditingMode: false,
        recipientNotificationSettingsData: mainData.recipientNotificationSettingsData ? mainData.recipientNotificationSettingsData : null,
        downloadedFileName: this.$session.mainData.downloadedFileName,
        scheduledSendOn: mainData.scheduledSendOn,
      };

      const signbuilderType: string = this.$data.signbuilderType;
      if (signbuilderType === 'createlink' || signbuilderType === 'createtemplate') {
        if (isDraft) {
          documentDetails.status = 'Draft';
        } else {
          documentDetails.status = 'Completed';
        }
      } else if ((signbuilderType === 'signing' || signbuilderType === 'usetemplate') && isDraft) {
        documentDetails.status = 'Draft';
      } else if (signbuilderType === 'bulksend') {
        documentDetails.status = 'Completed';
        documentDetails.isBulkSend = true;
      }

      const documentElementDetails: any = { id: mainData.parentDocumentId, scaleFactor: 1 };
      if (this.$session.prepareData.formElementsData) {
        const formElementsData: any = JSON.parse(this.$session.prepareData.formElementsData);
        documentElementDetails.pageFormElements = this.getUpdatedPageFormElements(formElementsData.pageFormElementsList);
        documentElementDetails.scaleFactor = formElementsData.currentZoom;
        documentElementDetails.pageHeight = formElementsData.pageHeight;
        documentElementDetails.pageMargin = formElementsData.pageMargin;
      }
      const viewDocumentContent: any = { documentDetails, documentElementDetails };
      viewDocumentContent.id = documentDetails.id;
      viewDocumentContent.azureETag = this.$data.azureETag;
      viewDocumentContent.blobETag = this.$data.blobETag;
      viewDocumentContent.isDraftSaved = this.$session.mainData.isDraftSaved;
      viewDocumentContent.labels = this.$session.documentTags.labels;
      viewDocumentContent.templateLabels = this.$session.templateTags.labels;
      const embedData = this.$session.embedData;
      if (this.oldDocumentDetails || (embedData.isEmbedPage && embedData.isEmbeddedTemplateEdit)) {
        viewDocumentContent.oldDocumentId = mainData.editTemplateDocumentId ? mainData.editTemplateDocumentId : this.oldDocumentDetails.id;
      }
      if (embedData.isEmbedPage) {
        const embedDocumentDetails = embedData.documentDetails;
        viewDocumentContent.azureETag = embedData.azureETag;
        viewDocumentContent.organizationId = embedData.organizationId;
        viewDocumentContent.documentDetails.isEmbedDocument = true;
        viewDocumentContent.documentDetails.sentBy = embedDocumentDetails.sentBy;
        viewDocumentContent.documentDetails.senderEmail = embedDocumentDetails.senderEmail;
        viewDocumentContent.documentDetails.createdBy = embedDocumentDetails.createdBy;
        viewDocumentContent.documentDetails.teamId = embedDocumentDetails.teamId;
        viewDocumentContent.documentDetails.subscriptionId = embedDocumentDetails.subscriptionId;
        viewDocumentContent.documentDetails.senderTimeZone = embedDocumentDetails.senderTimeZone;
        viewDocumentContent.documentDetails.applicationClientId = embedDocumentDetails.applicationClientId;
        viewDocumentContent.documentDetails.enableEmbeddedSigning = embedDocumentDetails.enableEmbeddedSigning;
        viewDocumentContent.documentDetails.onBehalfOfDetails = embedDocumentDetails.onBehalfOfDetails;
        viewDocumentContent.documentDetails.templateEmbedId = embedData.templateEmbeddedId;
        viewDocumentContent.documentDetails.metaData = embedDocumentDetails.metaData;
      }
      if (signbuilderType === 'usetemplate') {
        viewDocumentContent.isCloned = mainData.isCloned;
      }
      if (mainData.isEditCreatedTemplate && embedData.documentDetails) {
        viewDocumentContent.documentDetails.onBehalfOfDetails = embedData.documentDetails.onBehalfOfDetails;
      }
      return viewDocumentContent;
    },

    getUpdatedPageFormElements (pageFormElementsList: any): any {
      const pageFormElements = JSON.parse(JSON.stringify(pageFormElementsList));

      // Flatten all checkbox formElements into a single array
      const allCheckboxElements = pageFormElements.flatMap((pageFormElement: any) =>
        pageFormElement.formElements.filter((formElement: any) => formElement.elementType === 'checkbox' && formElement.groupName)
      );

      // Create a map to count occurrences of each groupName
      const groupNameCounts = allCheckboxElements.reduce((counts: { [key: string]: number }, formElement: any) => {
        counts[formElement.groupName] = (counts[formElement.groupName] || 0) + 1;
        return counts;
      }, {});

      // Set groupName and checkboxConditionInfo to null if checkbox count is one
      pageFormElements.forEach((pageFormElement: any) => {
        pageFormElement.formElements.forEach((formElement: any) => {
          if (formElement.groupName && groupNameCounts[formElement.groupName] === 1) {
            formElement.groupName = null;
            formElement.checkboxConditionInfo = null;
          }
        });
      });

      return pageFormElements;
    },

    getBulkSendSaveData (): any {
      const reviewData: any = this.$session.reviewData;
      if (reviewData.expiryDateType === 'SpecificDateTime' && this.$data.signbuilderType !== 'createtemplate') {
        this.expiryDateUpdateForSpecificDateTimeType();
      }
      let uploadedDocumentList: DocumentProperties[] = this.$session.mainData.uploadedDocumentList;
      uploadedDocumentList = uploadedDocumentList.filter(x => x.isDocumentLoaded && !x.isFailed);
      const parentDocument: DocumentProperties = uploadedDocumentList[0];
      const mainData: any = this.$session.mainData;
      const signerData: any = this.$session.signerData;
      const bulkSendData: any = this.$session.bulkSendData;
      const reminderSetting: ReminderSettings = { enableAutoReminder: reviewData.autoReminder, reminderDays: reviewData.reminderDays, reminderCount: reviewData.reminderCount };
      const signerDetails: any[] = [];
      const documentInfo: any[] = [];
      bulkSendData.bulkSendSigners.forEach((signerDetails) => {
        for (let i = 1; i < signerDetails.length; i++) {
          const isdocumetInfo = documentInfo.find(x => x.language === signerDetails[i].selectedLanguage);
          if (!isdocumetInfo) {
            const documentInfoDetails = signerData.documentInfo.find(x => x.language === signerDetails[i].selectedLanguage);
            documentInfo.push(documentInfoDetails);
          }
        }
      });
      const enableCcFromHIPAA = UtilityMethods.EnableCCFromHIPAA(this.$session.HIPAAData);
      const documentDetails: DocumentDetails = {
        id: mainData.parentDocumentId,
        documentName: parentDocument.documentName,
        documentPageCount: parentDocument.pageCount,
        applicationEnvironment: mainData.applicationEnvironment,
        documentProperties: uploadedDocumentList,
        removedDocumentList: [],
        replacedDocumentDetails: mainData.replacedDocDetails,
        uploadedDocumentDetails: mainData.uploadedDocDetails,
        resetStartPosition: mainData.resetStartPosition,
        isDocumentAddedorReplaced: mainData.isDocumentAddedorReplaced,
        ccDetails: (!enableCcFromHIPAA) ? [] : (signerData.ccDetails.filter((ccDetail: CCDetail): CCDetail => { return ccDetail.emailAddress ? ccDetail : null; })),
        messageDescription: '',
        messageTitle: '',
        signerDetails,
        expiryDays: reviewData.enableExpiryDays || this.$data.signbuilderType !== 'createlink' ? reviewData.expiryDays : 0,
        expiryDateType: reviewData.expiryDateType,
        selfOthers: mainData.selfOthers,
        onlyOthers: mainData.onlyOthers,
        isSelfSign: mainData.isSelfSign,
        enableSigningOrder: signerData.allowDraggable,
        expiryDate: reviewData.enableExpiryDays || this.$data.signbuilderType !== 'createlink' ? reviewData.expiryDate : null,
        uploadType: parentDocument.uploadType,
        warnDocumentExpiry: reviewData.warnDocumentExpiry,
        templateName: mainData.templateName,
        version: mainData.version || '1.0',
        templateVersion: mainData.templateVersion || 'v2',
        documentVersion: mainData.documentVersion,
        formTitle: mainData.formTitle,
        welcomeMessage: mainData.welcomeMessage,
        acknowledgementMessage: mainData.acknowledgementMessage,
        templateDescription: mainData.templateDescription,
        useTemplateDocumentId: mainData.useTemplateDocumentId,
        enableExpiration: true,
        reminderSettings: reminderSetting,
        enableSubjectEditing: signerData.enableSubjectEditing,
        enableAddAdditionalRecipients: signerData.enableAddAdditionalRecipients,
        enableAddAdditionalFiles: signerData.enableAddAdditionalFiles,
        enableReplaceOrDeleteFiles: signerData.enableReplaceOrDeleteFiles,
        enableDigitalSign: reviewData.enableDigitalSign,
        linkLimit: reviewData.enableLimit ? reviewData.linkLimit : 0,
        signerEmailValidationRegex: reviewData.enableRegex && reviewData.regexDescription ? reviewData.signerEmailValidationRegex : '',
        regexDescription: reviewData.enableRegex && reviewData.signerEmailValidationRegex ? reviewData.regexDescription : '',
        enablePrintAndSign: mainData.allowPrintAndSign ? reviewData.enablePrintAndSign : false,
        selectedBrandID: reviewData.selectedBrand,
        enableDocumentID: reviewData.enableDocumentID,
        enableLocalizationForAuditLogs: reviewData.enableLocalizationForAuditLogs,
        enableReassign: reviewData.enableReassign,
        enableIndividualDocumentDownloads: false,
        documentDownloadOption: mainData.allowDownloadSeparateDocument ? reviewData.documentDownloadOption : 'Combined',
        senderTimeZone: reviewData.senderTimeZone,
        documentInfo,
        mergedTemplateIds: mainData.mergedTemplateIds,
        isMergeTemplate: mainData.isMergeTemplate,
        requireEmailVerification: mainData.requireEmailVerification,
        multipleSigningEnabled: reviewData.multipleSigningEnabled,
        isBulkSend: this.$data.signbuilderType === 'bulksend',
        bulkSendTitle: bulkSendData.bulkSendTitle,
        inEditingMode: false,
        downloadedFileName: this.$session.mainData.downloadedFileName
      };
      const documentElementDetails: any = { id: mainData.parentDocumentId, scaleFactor: 1 };
      if (this.$session.prepareData.formElementsData) {
        const formElementsData: any = JSON.parse(this.$session.prepareData.formElementsData);
        formElementsData.pageFormElementsList.forEach((value) => {
          value.formElements.forEach((value1, index1) => {
            const isRolePresent = this.$session.bulkSendData.bulkSendSigners[0].find(x => x && ((x.roleSignerId && x.roleSignerId === value1.signerId) || value1.elementType === 'label' || value1.elementType === 'hyperlink'));
            if (!isRolePresent) {
              value.formElements.splice(index1, 1);
            }
          });
        });
        documentElementDetails.pageFormElements = formElementsData.pageFormElementsList;
        documentElementDetails.scaleFactor = formElementsData.currentZoom;
        documentElementDetails.pageHeight = formElementsData.pageHeight;
        documentElementDetails.pageMargin = formElementsData.pageMargin;
      }
      const BulkSendDetailsViewModel: any = { documentDetails, documentElementDetails };
      BulkSendDetailsViewModel.id = '';
      BulkSendDetailsViewModel.labels = this.$session.documentTags.labels;
      BulkSendDetailsViewModel.templateId = bulkSendData.templateId;
      const signerDetailsList: any[] = [];
      const fieldDetailsList: any[] = [];
      const documentInfoDetailsList: any[] = [];
      bulkSendData.bulkSendSigners.forEach((signerDetails) => {
        const signers = [];
        for (let i = 1; i < signerDetails.length; i++) {
          signers.push(signerDetails[i]);
        }
        signerDetailsList.push(signers);
      });
      bulkSendData.fieldDetails.forEach((fieldDetails) => {
        const fields = [];
        for (let i = 1; i < fieldDetails.length; i++) {
          fields.push(fieldDetails[i]);
        }
        fieldDetailsList.push(fields);
      });
      if (bulkSendData.documentInfoDetails && bulkSendData.documentInfoDetails[0].length > 1) {
        bulkSendData.documentInfoDetails.forEach((documentInfoDetails) => {
          const documentInfo = [];
          for (let i = 1; i < documentInfoDetails.length; i++) {
            documentInfo.push(documentInfoDetails[i]);
          }
          documentInfoDetailsList.push(documentInfo);
        });
      } else {
        bulkSendData.bulkSendSigners.forEach((signerDetails) => {
          const documentInfoFinal = [];
          for (let i = 1; i < signerDetails.length; i++) {
            const langInfo = documentInfo.find(x => x.language === signerDetails[i].selectedLanguage);
            if (langInfo) {
              documentInfoFinal.push(langInfo);
            }
          }
          documentInfoDetailsList.push(documentInfoFinal);
        });
      }

      BulkSendDetailsViewModel.bulkSendSignerDetails = signerDetailsList;
      BulkSendDetailsViewModel.fieldDetails = fieldDetailsList;
      BulkSendDetailsViewModel.documentInfoDetails = documentInfoDetailsList;
      BulkSendDetailsViewModel.bulkSendCCDetails = bulkSendData.cCDetails;
      BulkSendDetailsViewModel.bulkSendTagsDetails = bulkSendData.tagsDetails;
      return BulkSendDetailsViewModel;
    },

    getMessageDetails (documentInfo: any) {
      if (documentInfo.length > 0) {
        const info = documentInfo.find((a: any) => a.language === 'English');
        if (info) {
          return info;
        } else {
          return documentInfo[0];
        }
      }
    },

    getSigningGroupDetails (signerGroupDetails: any): any {
      const signerDetails: any[] = [];
      for (const signingGroupUsers of signerGroupDetails) {
        signerDetails.push(
          {
            signerId: signingGroupUsers.id,
            signerEmail: signingGroupUsers.signerMail,
            signerName: signingGroupUsers.signerName,
            signerRole: signingGroupUsers.signerRole,
            privateMessage: signingGroupUsers.privateMessage,
            authenticationCode: signingGroupUsers.authenticationCode,
            signerType: signingGroupUsers.signerType,
            status: signingGroupUsers.status,
            signerColor: signingGroupUsers.color2,
            zOrder: signingGroupUsers.zOrder,
            enableEditRecipients: signingGroupUsers.enableEditRecipients,
            enableAccessCode: signingGroupUsers.enableAccessCode,
            enableDeleteRecipients: signingGroupUsers.enableDeleteRecipients,
            enableEmailOTP: signingGroupUsers.enableEmailOTP,
            signType: signingGroupUsers.signType
          }
        );
      }
      return signerDetails;
    },

    setfooterClass (newClass) {
      this.$data.footerClass = newClass; // Update the footer class
    },

    discardChanges (): void {
      const signbuilderType: string = this.$data.signbuilderType;
      let auditType: number = 0;
      const context = (this as any);
      const ids: any[] = [];
      ids.push(this.$session.mainData.parentDocumentId);
      this.$data.footerClass = ' disable';
      this.$mutation.updateMainData({ showProgress: true });
      this.$data.editTemplateVisible = false;
      if (signbuilderType === 'signing') {
        context.$nuxt.$userInsight.track(MixPanelAction.DiscardDocumentClick, new UserInsight({
          Page: UserInsightPage.CreateDocumentPage,
          Action: UserInsightAction.DiscardDocumentAction,
          Origin: UserInsightOrigin.CreateDocument
        }));
      } else if (signbuilderType === 'createtemplate') {
        context.$nuxt.$userInsight.track(MixPanelAction.DiscardTemplateClick, new UserInsight({
          Page: UserInsightPage.CreateTemplatePage,
          Action: UserInsightAction.DiscardDocumentAction,
          Origin: UserInsightOrigin.CreateTemplate
        }));
        auditType = 1;
        if (!this.$session.mainData.isEditCreatedTemplate) {
          this.$nuxt.$api.documentViewer.deleteDraftTemplate(ids)
            .then(() => { this.pageRedirection(); })
            .catch((e: any) => {
              this.updateFailedMessage(e);
            });
        }
      } else if (signbuilderType === 'usetemplate') {
        context.$nuxt.$userInsight.track(MixPanelAction.DiscardTemplateClick, new UserInsight({
          Page: UserInsightPage.UseTemplatePage,
          Action: UserInsightAction.DiscardDocumentAction,
          Origin: UserInsightOrigin.UseTemplate
        }));
        auditType = 1;
      } else if (signbuilderType === 'createlink') {
        context.$nuxt.$userInsight.track(MixPanelAction.DiscardLinkClick, new UserInsight({
          Page: UserInsightPage.CreateLinkPage,
          Action: UserInsightAction.DiscardDocumentAction,
          Origin: UserInsightOrigin.CreateForm
        }));
        this.$nuxt.$api.documentViewer.deleteDraftForm(ids)
          .then(() => { this.pageRedirection(); })
          .catch((e: any) => {
            this.updateFailedMessage(e);
          });
      }

      if (signbuilderType === 'usetemplate' || signbuilderType === 'signing' || (signbuilderType === 'createtemplate' && this.$session.mainData.isEditCreatedTemplate)) {
        this.$nuxt.$api.documentViewer.discardDocumentDetails({
          data: {},
          query: {
            documentId: this.$session.mainData.parentDocumentId,
            messageTitle: this.$session.signerData.messageTitle,
            auditType
          }
        }).then((data) => {
          if (data) {
            this.pageRedirection();
          } else {
            const toastObj = context.$refs.failureCustomToast;
            toastObj.hide();
            toastObj.show(context.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
            this.$mutation.updateMainData({ showProgress: false });
          }
        }).catch((e: any) => {
          this.updateFailedMessage(e);
        });
      }
    },

    pageRedirection (): void {
      clearInterval(this.lastInterval);
      this.clearSessionStorage();
      window.location.replace('/dashboard');
    },

    moveToPreparePage (): void {
      const mainData: any = this.$session.mainData;
      const signerDetails: any = this.$session.signerData.signerDetails;
      const signerLength = signerDetails.length;
      if (signerLength > 0) {
        const firstEmptySignerIndex = mainData.signbuilderType === 'createtemplate' || mainData.signbuilderType === 'createlink' ? signerDetails.findIndex(s => s.signerRole === '') : signerDetails.findIndex(s => this.validateEmptySigner(s));
        if (firstEmptySignerIndex !== -1) {
          for (let i = (signerLength - 1); i >= firstEmptySignerIndex; i--) {
            this.$mutation.removeSignerData({ index: i, isRemoveSigner: true });
          }
        }
      }
from default vue

export default defineComponent({
  name: 'PreparePage',
  components: {
    'ejs-dropdownlist': DropDownListComponent,
    'ejs-button': ButtonComponent,
    'ejs-textbox': TextBoxComponent,
    'ejs-contextmenu': ContextMenuComponent,
    'ejs-dialog': DialogComponent,
    'ejs-datepicker': DatePickerComponent,
    PrepareProgressTemplate,
    Signature,
    MobileFieldContainerComponent,
    MobileContextMenu,
    CustomToast,
    ThumbnailComponent,
    FieldContainerComponent,
    AdvanceSettings,
    PDFViewerRenderComponent,
    ImageTemplate,
    RemoveImageWarning
  },

  data () {
    const context = this as any;
    const app = createApp({});
    const iTemplate = app.component('ItemVue', itemVue);
    const isDesktopMode: boolean = this.$session.responsiveLayout.responsiveMode === ResponsiveMode.DesktopMode;
    const isMobileMode: boolean = this.$session.responsiveLayout.responsiveMode === ResponsiveMode.MobileMode;
    const signbuilderType: string = this.$session.mainData.signbuilderType;
    const signerDetails: any = UtilityMethods.getSignerDetails(this.$session.signerData.signerDetails);
    const defaultSignerDetails: any = UtilityMethods.getDefaultSignerDetail(this);
    let assigneeTextField: string = 'customSignerName';
    const datePickerPopUpX: number = 0;
    const datePickerPopUpY: number = 0;
    if (signbuilderType === 'createtemplate' || signbuilderType === 'createlink' || signbuilderType === 'usetemplate') {
      assigneeTextField = 'signerRole';
    }
    if (this.$session.embedData.isEmbedPage) {
      this.$mutation.updateMainData({ showProgress: false });
    }
    return {
      datePickerPopUpX,
      datePickerPopUpY,
      lastInterval: null as NodeJS.Timeout,
      customFieldsInterval: null as NodeJS.Timeout,
      signatureInstance: null as any,
      initialInstance: null as any,
      thumbnailInstance: null as any,
      pdfRenderInstance: null as any,
      fieldContainerInstance: null as any,
      advanceSettingsInstance: null as any,
      imageInstance: null as any,
      removeImageInstance: null as any,
      conditionalLogicMethods: new ConditionalLogicMethods(),
      globalize: new Internationalization(),
      signatureDetails: null as any,
      lastSavedSignature: {},
      lastSavedInitial: {},
      customEvent: CustomEventHandler,
      isDocumentLoaded: false,
      dropdownObjInstance: null as any,
      datePickerObjInstance: DatePicker,
      doubleTabDetected: false,
      eventListeners: [
        { event: 'showSkeleton', handler: this.showSkeleton },
        { event: 'hideSkeleton', handler: this.hideSkeleton },
        { event: 'confirmDeleteImageDialog', handler: this.confirmDeleteImageDialog },
        { event: 'resizePDFViewer', handler: this.resizePDFViewer },
        { event: 'imageBtnClick', handler: this.imageBtnClick },
        { event: 'closeAdvance', handler: this.closeAdvance },
        { event: 'getConditionalLogicConfirmationDialogContent', handler: this.getConditionalLogicConfirmationDialogContent },
        { event: 'updateConditionalRuleDefaultDialogButton', handler: this.updateConditionalRuleDefaultDialogButton },
        { event: 'hideDropdownConfirmationDialog', handler: this.HideDropdownConfirmationDialog },
        { event: 'showAdvanceSettings', handler: this.updateAdvanceSettingsVariables },
        { event: 'conditionalLogicCreateOrCancelAction', handler: this.conditionalLogicCreateOrCancelAction },
        { event: 'confirmationDialogButtonForDropdownOptionsEdit', handler: this.confirmationDialogButtonForDropdownOptionsEdit },
        { event: 'confirmationDialogButtonForDropdownOptionsDelete', handler: this.confirmationDialogButtonForDropdownOptionsDelete },
        { event: 'showAnchorTxtConfigDltConfirmDlg', handler: this.showAnchorTxtConfigDltConfirmDlg },
        { event: 'updateAnchorTextVal', handler: this.updateAnchorTextVal },
        { event: 'updateCanEditCustomField', handler: this.updateCanEditCustomField },
        { event: 'updateAssigneeForCustomFields', handler: this.updateAssigneeForCustomFields },
        { event: 'updateCustomFieldId', handler: this.updateCustomFieldId },
        { event: 'hideRightSideBar', handler: this.hideRightSideBar },
        { event: 'showRightSideBar', handler: this.showRightSideBar },
        { event: 'updateAssigneeForCustomFields', handler: this.updateAssigneeForCustomFields },
        { event: 'updateSignatureImageForSelfSign', handler: this.updateSignatureImageForSelfSign },
        { event: 'updateCustomFieldButtonContent', handler: this.updateCustomFieldButtonContent },
        { event: 'saveCustomFieldBtnClick', handler: this.saveCustomFieldBtnClick },
        { event: 'saveEditedCustomField', handler: this.saveEditedCustomField },
        { event: 'mobileContextMenuSelection', handler: this.mobileContextMenuSelection },
        { event: 'getVisibilityOfTooltipDialog', handler: this.getVisibilityOfTooltipDialog },
        { event: 'isSharableFormField', handler: this.isSharableFormField },
        { event: 'updateInitialAssignee', handler: this.updateInitialAssignee },
        { event: 'fetchAIFieldDetails', handler: this.fetchAIFieldDetails },
        { event: 'aiFieldDropDownSelect', handler: this.aiFieldDropDownSelect },
        { event: 'stopAiFieldProcess', handler: this.stopAiFieldProcess },
      ],
      signalRInstance: null as signalR.HubConnection,
      value: 'sign3.png',
      height: '440px',
      width: '638px',
      header: 'Draw Signature',
      serviceUrl: '/api/pdfviewer',
      pdfFormElement: this.pdfFormElement,
      customToastObj: this.customToastObj,
      isSharedFieldSelected: this.isSharedFieldSelected,
      visible: false,
      isCustomFieldLoaded: false,
      selectedRecipients: defaultSignerDetails.id,
      assigneeFields: {
        text: assigneeTextField,
        value: 'id'
      },
      deleteConditionDlgButtons: [
        {
          buttonModel: { content: context.$t('common.cancel'), cssClass: 'e-flat' },
          click: this.hideDeleteDialog.bind(this)
        },
        {
          buttonModel: { content: context.$t('common.continue'), cssClass: 'e-danger e-flat' },
          click: this.confirmDeleteDialog.bind(this)
        }
      ],
      anchorTxtConfigDeleteDlgButtons: [
        {
          buttonModel: { content: context.$t('common.cancel'), cssClass: 'e-flat' },
          click: this.closeAnchorTxtConfigDeleteDlg.bind(this)
        },
        {
          buttonModel: { content: context.$t('common.delete'), cssClass: 'e-flat e-danger', isPrimary: true },
          click: this.deleteAnchorTxtConfiguration.bind(this)
        }
      ],
      conditionalPlaceHolder: context.$t('preparePage.conditionalPlaceHolder'),
      conditionalLogicConfirmationDialogContent: '',
      conditionalLogicDataSource: [],
      conditionalDropdownText: '',
      selectedConditionalRule: this.$session.advanceSettings.selectedConditionalRule,
      isFormulaConditionalField: false,
      isConditionalPage: false,
      deleteConditionDialogVisible: false,
      anchorTxtConfigDeleteDlgVisibility: false,
      dropdownValue: this.$session.advanceSettings.dropdownValue,
      anchorTxtValidationMsg: '',
      dateFormat: UtilityMethods.getDateFormat(this.$session),
      timeFormat: UtilityMethods.getTimeFormat(this.$session),
      showTodayButton: false,
      selectAssigneePlaceholder: context.$t('preparePage.selectAssigneePlaceholder'),
      showAdvanceFields: false,
      selectedElementType: 'signature',
      showThumbContainer: true,
      anchorTextVal: this.$session.advanceSettings.anchorTextVal,
      isDesktopMode,
      isMobileMode,
      formMenuItems: [
        {
          text: context.$t('preparePage.changeSignMenuItem'),
          id: 'change_sign_item',
          iconCss: 'bs-change-sign-icon'
        },
        {
          text: context.$t('preparePage.changeImageMenuItem'),
          id: 'change_image_item',
          iconCss: 'bs-change-sign-icon'
        },
        {
          text: context.$t('preparePage.clearMenuItem'),
          id: 'clear_item',
          iconCss: 'bs-clear-icon'
        },
        {
          text: context.$t('preparePage.duplicate'),
          id: 'duplicate_item',
          iconCss: 'bs-dupicate-fields-icon'
        },
        { separator: true },
        {
          text: context.$t('preparePage.cut'),
          id: 'cut_item',
          iconCss: 'bs-cut-icon'
        },
        {
          text: context.$t('preparePage.copy'),
          id: 'copy_item',
          iconCss: 'bs-copy-icon'
        },
        {
          text: context.$t('preparePage.paste'),
          id: 'paste_item',
          iconCss: 'bs-paste-icon'
        },
        {
          text: context.$t('preparePage.pasteHereMenuItem'),
          id: 'pastehere_item',
          iconCss: 'bs-paste-icon'
        },
        {
          text: context.$t('preparePage.replicateToAllPages'),
          id: 'apply_to_all_pages_item',
          iconCss: 'bs-replicateToAllPage-icon'
        },
        { separator: true },
        {
          text: context.$t('common.delete'),
          id: 'delete_item',
          iconCss: 'bs-delete-icon'
        },
        {
          text: context.$t('settings'),
          id: 'settings_item',
          iconCss: 'sf-icon-Setting'
        }
      ],
      conditionalFields: { text: 'text', value: 'value' },
      pageNoList: [],
      hasPdfFormFields: false,
      currentDropdownOptions: [],
      showDropdown: false,
      dropdownPlaceholder: context.$t('common.dropdownTxt'),
      dropdownFields: {
        text: 'value',
        value: 'value'
      },
      dropdownPopUpX: 0,
      dropdownPopUpY: 0,
      dropdownWidth: 0,
      datePickerValue: this.$session.advanceSettings.datePickerValue,
      minDate: this.$session.advanceSettings.minDate,
      maxDate: this.$session.advanceSettings.maxDate,
      classToAnimatePropertyPanel: '',
      isHiddenThumbContainer: false,
      isFieldsUpdated: false,
      allDocPageIndexNeeded: false,
      signerDetails,
      isPdfDocLoaded: false,
      isTemplatePage: false,
      showMobileContextMenu: false,
      contextMenuX: 0,
      contextMenuY: 0,
      mobileContextMenuItems: {},
      showSkeletonProgress: false,
      tooltipContent: this.$session.mainData.isSelfSign ? context.$t('preparePage.selfSignToolTipContent') : context.$t('preparePage.toolTipContent'),
      tooltipDlgVisibility: false,
      isLatestVersion: false,
      isEmbedPage: this.$session.embedData.isEmbedPage,
      signbuilderType,
      iTemplate: function () {
        return {
          template: iTemplate
        };
      },
      closeOnEscape: true,
      aiFieldDetectionConfirmationVisible: false,
      isModal: true,
      animationSettings: { effect: 'none' },
      target: document.body,
      aiFieldDetectionConfirmationButtons: [
        {
          buttonModel: { content: context.$t('common.cancel'), cssClass: 'e-flat' },
          click: this.cancelFieldDetect.bind(this),
        },
        {
          buttonModel: { content: context.$t('preparePage.startPlaceFieldsBtnContent'), cssClass: 'e-flat', isPrimary: true },
          click: this.startPlaceFieldsClick.bind(this),
        },
      ],
      aiImageAlt: context.$t('accessibility.infoImageAlt'),
      aiFieldPlaceConfirmationDlgHeader: context.$t('preparePage.aiFieldPlaceConfirmationDlgHeader'),
      aiDialogDescription: context.$t('preparePage.aiDialogDescription'),
      aiDialogNote: context.$t('preparePage.aiDialogNote'),
      aiFieldDetectionErrorDlgVisible: false,
      aiFieldDetectionErrorDlgHeader: context.$t('preparePage.aiFieldDetectionErrorDlgHeader'),
      aiFieldDetectionErrorDlgDescription: context.$t('preparePage.aiFieldDetectionErrorDlgDescription'),
      aiFieldDetectionErrorDlgButtons: [
        {
          buttonModel: { content: context.$t('common.cancel'), cssClass: 'e-flat' },
          click: this.aiFieldErrorDialogBtnClick.bind(this),
        },
        {
          buttonModel: { content: context.$t('preparePage.addMyOwnBtnContent'), cssClass: 'e-flat', isPrimary: true },
          click: this.aiFieldErrorDialogBtnClick.bind(this),
        },
      ],
      isSignalRProcessCompleted: false,
      removeAiFieldConfirmationDlg: false,
      removeAiFieldConfirmationDlgButtons: [
        {
          buttonModel: { content: context.$t('preparePage.keepFieldsText'), cssClass: 'e-flat' },
          click: this.keepFieldsBtnClick.bind(this),
        },
        {
          buttonModel: { content: context.$t('preparePage.removeFieldsBtnText'), cssClass: 'e-flat', isPrimary: true },
          click: this.removeFieldsBtnTextClick.bind(this),
        },
      ],
      fieldDetectStatus: '',
    };
  },

  beforeUnmount (): void {
    document.body.removeEventListener('click', this.documentClickListener);
    window.removeEventListener('touchstart', this.touchStart);
    window.removeEventListener('touchmove', this.touchMove);
    window.removeEventListener('touchend', this.touchEnd);
    const parentElement: HTMLElement = document.getElementsByClassName('bs-prepare-page')[0] as HTMLElement;
    parentElement.style.display = 'none';
  },

  mounted () {
    useHead({ title: this.$t('metaInfo.preparePageMetaInfo') });
    this.eventListeners.forEach(({ event, handler }) => {
      this.$eventBus.on(event, handler);
    });
    debugger
    this.$mutation.updateResponsiveLayout({ currentPageType: ResponsivePageType.PreparePage, previousPage: ResponsivePageType.DocumentSettings });
    this.$data.isLatestVersion = UtilityMethods.isLatestVersionedDocument(this.$session.mainData.documentVersion);
    document.body.addEventListener('click', this.documentClickListener);
    window.addEventListener('touchstart', this.touchStart, { passive: false });
    window.addEventListener('touchmove', this.touchMove);
    window.addEventListener('touchend', this.touchEnd);
    this.signatureInstance = this.$refs.signatureObj;
    this.initialInstance = this.$refs.initialObj;
    this.thumbnailInstance = this.$refs.thumbnailObj;
    this.pdfRenderInstance = this.$refs.pdfRenderObj;
    this.imageInstance = this.$refs.imageObj;
    this.removeImageInstance = this.$refs.removeImageRef;
    this.dropdownObjInstance = this.$refs.dropDownFormFieldObj;
    if (!this.$data.isDesktopMode) {
      this.fieldContainerInstance = this.$refs.mobileFieldContainerObj;
    } else {
      this.fieldContainerInstance = this.$refs.fieldContainerObj;
    }
    this.datePickerObjInstance = this.$refs.datePickerObj.ej2Instances;
    this.pdfFormElement = this.pdfRenderInstance.PdfFormElement;
    this.pdfFormElement.isEditDocument = UtilityMethods.inEditMode(this);
    this.advanceSettingsInstance = this.$refs.advanceSettingsObj;
    this.customToastObj = this.$refs.customToast;
    this.pdfFormElement.enableFieldEditing = !!((this.$session.mainData.isSelfSign && this.$data.signbuilderType !== 'createtemplate'));
    document.ondblclick = this.documentDoubleClick.bind(this);
    this.$mutation.updateMainData({ prepareProgress: true, anchorTxtConfigSectionVisibility: false });
    this.$mutation.updateMainData({ enableNextPage: this.$data.signbuilderType === 'createtemplate' });

    if (this.pdfFormElement.enableFieldEditing && !this.$session.embedData.isEmbedPage) {
      this.$nuxt.$api.common.getSignatureDetails({}).then((data) => {
        this.signatureDetails = data;
      });
      for (const formElement of this.fieldContainerInstance.formElements) {
        formElement.isRequired = false;
        if (formElement.elementType === 'checkbox') {
          formElement.value = 'on';
        } else if (formElement.elementType === 'title') {
          formElement.value = this.$session.mainData.jobTitle;
        } else if (formElement.elementType === 'company') {
          formElement.value = this.$session.mainData.companyName;
        }
      }
    }
    if (UtilityMethods.getResponsiveModes(this.$session.responsiveLayout.responsiveMode).isTabMode) {
      this.$data.showThumbContainer = false;
      this.$data.isHiddenThumbContainer = true;
    }
    this.loadPdf();
    this.updateInitialAssignee();
    const onboardingData = this.$session.onboardingData;
    if (onboardingData.showTour && onboardingData.pageName === PageName.Filling) {
      this.$mutation.updateOnboardingData({ tourAction: TourAction.DragDrop, pageName: PageName.Prepare });
    }

    // set brand button color and button text color.
    const { buttonColor, buttonTextColor } = this.$session.embedData;
    UtilityMethods.setBrandButton(buttonColor, buttonTextColor);
    this.initializeSignalR();
  },

  unmounted () {
    this.saveDraftFormElements();
    window.onresize = null;
    document.onmousedown = null;
    document.ondblclick = null;
    this.eventListeners.forEach(({ event, handler }) => {
      this.$eventBus.off(event, handler);
    });
  },

  methods: {
    documentClickListener (args: any): void {
      this.contextMenuCloseEvent();
      if (!this.$data.isTextOrDropdownValueChange && !(args.target as any).closest('.bs-dataSyncTag_props') && (this.pdfFormElement.isConditionalPage && !(args.target as any).closest('#formElementsContainer')) && !(args.target as any).closest('.e-toast-container') && !(args.target as any).closest('#conditionalRuleApply')) {
        const toastObj = (this as any).$refs.customToast;
        toastObj.hide();
      }
      const embedData = this.$session.embedData;
      if (embedData.isEmbedPage && embedData.showTooltip) {
        this.updateTooltip();
      }
    },

    updateInitialAssignee (): void {
      this.advanceSettingsInstance.updateAssignee(this.fieldContainerInstance.formElements, this.pdfFormElement);
    },

    initializeSignalR () {
      const retryDelay: number[] = [1000, 3000, 3000, 3000];
      const logger = new SignalRLogger((this as any).$nuxt.$signalRLogger.applicationInsightAnalytics);
      const hubUrl = '/signDocumentHub';
      this.signalRInstance = new signalR.HubConnectionBuilder()
        .withUrl(hubUrl)
        .withAutomaticReconnect(retryDelay)
        .configureLogging(logger)
        .build();
      this.signalRInstance.start()
        .catch((err: any) => {
          this.signalRConnectionError(err);
        });
    },

    signalRConnectionError (err: any) {
      const $this = (this as any);
      $this.$nuxt.$signalRLogger.log(signalR.LogLevel.Error, err.toString());
    },

    updateAssigneeForCustomFields (assigneeData) {
      if (this.fieldContainerInstance.myFormFields.length > 0 || this.fieldContainerInstance.sharedFormFields.length > 0) {
        const customFields = this.fieldContainerInstance.getCustomFields();
        for (const customField of customFields) {
          const formElementType = customField.formField.elementType;
          if (formElementType !== 'label' && formElementType !== 'hyperlink') {
            customField.formField.fill1 = assigneeData.color1;
            customField.formField.fill2 = assigneeData.color2;
            if (formElementType === 'name' || formElementType === 'email') {
              customField.formField.value = formElementType === 'name' ? assigneeData.signerName : assigneeData.signerMail;
            }
          }
        }
      }
    },

    updateAdvanceSettingsVariables (args: any): void {
      this.$data.showAdvanceFields = args;
      document.getElementById('pdfViewer_parent').focus();
    },

    isSharableFormField (selectedCustomFieldId: string) {
      this.isSharedFieldSelected = this.fieldContainerInstance.sharedFormFields.some((element: any) => element.formField.id === selectedCustomFieldId);
    },

    showThumb (value: boolean): void {
      this.$data.showThumbContainer = value;
      this.$data.isHiddenThumbContainer = !this.$data.showThumbContainer;
      this.resizePDFViewer();
    },

    resizePDFViewer (): void {
      setTimeout((): void => {
        window.dispatchEvent(new Event('resize'));
        this.pdfFormElement.scaleFormContainer(this.pdfFormElement.pdfInstance.zoomPercentage);
      }, 0);
    },

    updateStyleOnResizePDFViewer (): string[] {
      const classList: string[] = [];
      if (this.$data.isConditionalPage) {
        this.$data.isDesktopMode ? classList.push('createLogicSectionEnabled', 'animateOnResizePdf') : classList.push('createLogicSectionEnabledResponsiveMode', 'animateOnResizePdf');
      } else if (this.$session.mainData.anchorTxtConfigSectionVisibility) {
        this.$data.isDesktopMode ? classList.push('anchorTxtConfigSecEnabled', 'animateOnResizePdf') : classList.push('anchorTxtConfigSecResponsiveModeEnabled', 'animateOnResizePdf');
      } else {
        classList.push('animateOnPdfToOriginalPosition');
      }

      if (this.$session.responsiveLayout.responsiveMode === ResponsiveMode.TabMode) {
        if (this.$session.mainData.isSelfSign) {
          classList.push('selfSignPdfViwerPosition');
        } else {
          classList.push('tabLayoutPosition');
        }
      }

      return classList;
    },

    saveFormElements (): void {
      this.$mutation.updatePrepareFormData({ formElementsData: this.pdfFormElement.save() });
      this.updateFieldCount();
    },

    updateFieldCount (): void {
      this.$mutation.resetSignerFieldCount();
      this.$mutation.resetUploadDocumentFieldCount();
      this.$mutation.updateSignerFieldCount(this.getSignerFieldCount());
      for (let i = 0; i < this.pdfFormElement.pageFormElementsList.length; i++) {
        const pageFormElement: PageFormElements = this.pdfFormElement.pageFormElementsList[i];
        const documentProperties: DocumentProperties = this.thumbnailInstance.getDocumentProperties('thumbImageContainer_' + pageFormElement.pageIndex, this.$session.mainData.uploadedDocumentList);
        if (documentProperties !== null) {
          const checkboxCount = this.pdfFormElement.checkboxFieldCount();
          let documentFieldCount: number = pageFormElement.formElements.filter(x => x.elementType !== 'label' && x.elementType !== 'checkbox').length;
          documentFieldCount += checkboxCount.length > 0 ? checkboxCount.filter(x => x.pageIndex === pageFormElement.pageIndex).length : 0;
          this.$mutation.updateUploadDocumentData({ order: documentProperties.order, fieldCount: documentProperties.fieldCount + documentFieldCount });
        }
      }
    },

    saveDraftFormElements (): void {
      if (this.isDocumentLoaded) {
        this.$mutation.updatePrepareFormData({ formElementsData: this.pdfFormElement.draftSave() });
        this.updateFieldCount();
      }
    },

    /* Client Side Events Handling PdfViewer Component - Start */

    drop (args: any): void {
      const context = (this as any);
      this.$data.hasPdfFormFields = false;
      let mixPanelAction: MixPanelAction = MixPanelAction.AddFormFieldsClick;
      let userInsightAction: UserInsightAction = UserInsightAction.AddFormFieldsAction;
      if (this.$data.isEmbedPage) {
        mixPanelAction = MixPanelAction.EmbeddedAddFormFieldsClick;
        userInsightAction = UserInsightAction.EmbeddedAddFormFieldsAction;
      }
      this.$nuxt.$userInsight.track(mixPanelAction, new UserInsight({
        Page: UserInsightPage.PreparePage,
        Action: userInsightAction,
        Origin: UserInsightOrigin.PrepareDocument
      }));
      window.sessionStorage.setItem('isModified', 'True');
      this.$mutation.updateMainData({
        isPageModified: true,
        preventDraftSave: false,
        isDocumentAddedorReplaced: false
      });
      if (args.formElement) {
        this.$data.selectedElementType = this.advanceSettingsInstance.selectedElementType = args.formElement.elementType;
        this.$data.advanceSettingsInstance.isMultiSelect = false;
        this.$data.advanceSettingsInstance.hideAssignOption = false;
        if (!args.formElement.signerId && this.$data.selectedRecipients && args.formElement.elementType !== 'label' && args.formElement.elementType !== 'hyperlink') {
          args.formElement.signerId = this.$data.selectedRecipients;
        }
        if (!this.$data.showThumbContainer) {
          this.showAdvanceSettings(args.formElement.elementType);
        }
        if (!this.$data.isMobileMode) {
          this.advanceSettingsInstance.showAdvance();
        }
        if (this.pdfFormElement.enableFieldEditing && (args.formElement.elementType === 'signature' || args.formElement.elementType === 'initial')) {
          if (!args.formElement.value) {
            this.setSignatureDetailsForSelfSign('signature');
            this.setSignatureDetailsForSelfSign('initial');
            const formElement = args.formElement;
            const selectedSignatureObj = formElement.elementType === 'signature' ? this.lastSavedSignature : this.lastSavedInitial;
            if (!selectedSignatureObj) {
              this.openSignDialog(args.formElement.elementType);
            } else {
              const newFormElement = UtilityMethods.frameFormElementObj(formElement, this.advanceSettingsInstance.selectedAssignee);
              newFormElement.value = selectedSignatureObj.value as string;
              newFormElement.originalImageBounds = selectedSignatureObj.originalImageBounds;
              newFormElement.signData = selectedSignatureObj.signData as string;
              newFormElement.signatureType = selectedSignatureObj.signatureType as string;
              this.pdfFormElement.add(newFormElement);
            }
          } else if (this.pdfFormElement.enableFieldEditing) {
            const pageData: { [key: string]: number } = this.pdfFormElement.moveElementToAbsolutePage(args.formElement);
            this.advanceSettingsInstance.updateFormElement('signerId', this.advanceSettingsInstance.selectedAssignee, { id: args.formElement.id });
            this.thumbnailInstance.updateThumbnailFieldCount(pageData.activePageIndex);
          }
          this.advanceSettingsInstance.enablePreviewPage();
        } else if (this.pdfFormElement.enableFieldEditing && args.formElement.elementType === 'image') {
          if (!args.formElement.value) {
            this.imageInstance.show(this.pdfFormElement.selectedFormElement);
          } else if (this.pdfFormElement.enableFieldEditing) {
            const pageData: { [key: string]: number } = this.pdfFormElement.moveElementToAbsolutePage(args.formElement);
            this.advanceSettingsInstance.updateFormElement('signerId', this.advanceSettingsInstance.selectedAssignee, { id: args.formElement.id });
            this.thumbnailInstance.updateThumbnailFieldCount(pageData.activePageIndex);
          }
          this.advanceSettingsInstance.enablePreviewPage();
        } else if (this.pdfFormElement.enableFieldEditing && args.formElement.elementType === 'editabledate') {
          if (!args.formElement.value) {
            this.$data.datePickerValue = null;
            this.setDatePickerDetails();
          } else if (this.pdfFormElement.enableFieldEditing) {
            const pageData: { [key: string]: number } = this.pdfFormElement.moveElementToAbsolutePage(args.formElement);
            this.advanceSettingsInstance.updateFormElement('signerId', this.advanceSettingsInstance.selectedAssignee);
            this.thumbnailInstance.updateThumbnailFieldCount(pageData.activePageIndex);
          }
          this.advanceSettingsInstance.enablePreviewPage();
        } else if (this.$data.isMobileMode && args.formElement.elementType === 'radiobutton') {
          this.advanceSettingsInstance.updateRadioButtonValues(args.formElement);
        } else {
          const pageData: { [key: string]: number } = this.pdfFormElement.moveElementToAbsolutePage(args.formElement);
          if (this.pdfFormElement.enableFieldEditing && args.formElement.elementType === 'datepicker') {
            const dateTimeFormat: string = UtilityMethods.getDateTimeFormat(args.formElement.label, args.formElement.timeFormat);
            this.advanceSettingsInstance.updateFormElement('value', this.globalize.formatDate(new Date(), { format: dateTimeFormat }), { id: args.formElement.id });
          }
          if (args.formElement.elementType === 'label') {
            this.pdfFormElement.startEdit();
          } else {
            if (args.formElement.elementType === 'textbox') {
              this.advanceSettingsInstance.textFieldLabel = '';
            } else if (args.formElement.elementType === 'dropdown') {
              this.$data.dropdownPlaceholder = this.advanceSettingsInstance.dropdownPlaceholder = context.$t('common.dropdownTxt');
              this.advanceSettingsInstance.textFieldLabel = '';
            }
            this.advanceSettingsInstance.enablePreviewPage();
          }
          this.thumbnailInstance.updateThumbnailFieldCount(pageData.activePageIndex);
        }
      }
      this.advanceSettingsInstance.dataSyncTag = '';
    },

    focusOnUnFilledElement (isIntersecting?: boolean): void {
      let formElement: FormElement;
      const mainData = this.$session.mainData;
      if (UtilityMethods.inEditMode(this) && isIntersecting) {
        formElement = UtilityMethods.getIntersectingFields(this.pdfFormElement);
      } else if (mainData.isIdRequired || mainData.outOfBoundsFieldId) {
        const id = mainData.isIdRequired ? mainData.errorFormElementId : mainData.outOfBoundsFieldId;
        formElement = this.pdfFormElement.getFormElementById(id);
      } else if (mainData.isSelfSign && this.pdfFormElement.pageFormElementsList) {
        for (const pageFormElement of this.pdfFormElement.pageFormElementsList) {
          if (pageFormElement.formElements && this.pdfFormElement.haveUnFilledElement(pageFormElement.formElements)) {
            formElement = this.pdfFormElement.getContinuesNextFormElement();
          }
        }
      }
      if (formElement) {
        this.pdfFormElement.selectedFormElement = formElement;
        this.pdfFormElement.formRendering.svgContext.clearSelector();
        this.pdfFormElement.formRendering.svgContext.drawSelector(formElement, false, this.pdfFormElement.parentGroupNode);
        this.$data.selectedElementType = this.advanceSettingsInstance.selectedElementType = this.pdfFormElement.selectedFormElement.elementType;
        this.advanceSettingsInstance.isMultiSelect = false;
        this.advanceSettingsInstance.hideAssignOption = false;
        this.advanceSettingsInstance.showAdvance();
        const domFormElement = document.getElementById(formElement.id);
        if (domFormElement !== null) {
          this.pdfFormElement.scrollElement(domFormElement);
        }
      }
    },

    selectionChange (args: any): void {
      this.$data.showDropdown = false;
      this.dropdownObjInstance.hidePopup();
      this.contextMenuCloseEvent();
      if (args.type === 'preventMultiSelect') {
        const context = (this as any);
        const toastObj = context.$refs.failureCustomToast;
        toastObj.hide();
        toastObj.show(context.$t('preparePage.multiSelectionWarning'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        return;
      }
      if (args.formElement && args.type === 'insert') {
        this.$nuxt.$userInsight.track(MixPanelAction.FormFieldsSelection, new UserInsight({
          Page: UserInsightPage.PreparePage,
          Action: UserInsightAction.FormFieldsSelectionAction,
          Origin: UserInsightOrigin.PrepareDocument,
          ElementType: this.advanceSettingsInstance.getElementType(args.formElement.elementType)
        }));
        if (!this.$data.showThumbContainer) {
          this.showAdvanceSettings(args.formElement.elementType);
        }
        this.advanceSettingsInstance.isAutoPositionedMultiSelect = false;
        if (UtilityMethods.isAutoPositioned(args.formElement)) {
          this.advanceSettingsInstance.isMultiSelect = false;
          this.advanceSettingsInstance.hideAssignOption = false;
          this.advanceSettingsInstance.isAutoPositionedMultiSelect = true;
          if (!this.$data.isMobileMode) {
            this.advanceSettingsInstance.showAdvance();
          } else {
            this.mobileContextMenuSettings(args);
          }
          if (args.formElement.children[0].elementType === 'hyperlink') {
            this.advanceSettingsInstance.getHyperLinkElementId();
          }
        } else if (args.formElement.id === 'multipleSelection') {
          this.advanceSettingsInstance.preventPropertyChange = true;
          this.advanceSettingsInstance.isMultiSelect = true;
          if (!this.$data.isMobileMode) {
            this.$data.showAdvanceFields = true;
            this.advanceSettingsInstance.showAdvanceForMultiSelect();
          } else {
            this.mobileContextMenuSettings(args);
          }
          this.advanceSettingsInstance.isAnchorTextConfigured = false;
          this.advanceSettingsInstance.hideAssignOption = args.formElement.children.filter(a => a.elementType === 'label' || a.elementType === 'hyperlink').length > 0;
          this.advanceSettingsInstance.selectedElementType = this.$data.selectedElementType = 'multipleSelection';
          this.advanceSettingsInstance.advanceField = (this as any).$t('preparePage.multipleSelection');
          this.advanceSettingsInstance.selectedFields = (this as any).$t('preparePage.selectedFields', [args.formElement.children.length]);
          this.advanceSettingsInstance.selectedAssignee = this.advanceSettingsInstance.assignee.value = null;
          this.advanceSettingsInstance.assignee.dataBind();
          if (this.$data.isMobileMode) {
            this.advanceSettingsInstance.preventPropertyChange = false;
          }
        } else {
          this.advanceSettingsInstance.isMultiSelect = false;
          this.advanceSettingsInstance.hideAssignOption = false;
          if (!this.$data.isMobileMode) {
            this.advanceSettingsInstance.showAdvance();
          } else {
            this.mobileContextMenuSettings(args);
          }
          this.advanceSettingsInstance.selectedElementType = this.$data.selectedElementType = args.formElement.elementType;
          if (this.pdfFormElement.enableFieldEditing && (args.formElement.elementType === 'signature' || args.formElement.elementType === 'initial') &&
              (!args.formElement.value || args.event.which === 1)) {
            this.openSignDialog(args.formElement.elementType);
          }
          if (this.pdfFormElement.enableFieldEditing && args.formElement.elementType === 'image' && args.event.which === 1) {
            this.imageInstance.show(this.pdfFormElement.selectedFormElement);
          } else if (this.pdfFormElement.enableFieldEditing && args.formElement.elementType === 'editabledate' && args.event.which === 1) {
            const selectedElement = this.pdfFormElement.selectedFormElement;
            this.advanceSettingsInstance.updateDatePickerValue(selectedElement.value, selectedElement.label);
            this.setDatePickerDetails();
          } else if (args.formElement.elementType === 'hyperlink') {
            this.advanceSettingsInstance.getHyperLinkElementId();
          }
        }
      } else if (!args.formElement && args.type === 'remove') {
        this.$data.showAdvanceFields = this.advanceSettingsInstance.showAdvanceFields = false;
        this.hideAdvanceSettings();
      }
    },

    positionChange (args: any): void {
      this.$nuxt.$userInsight.track(MixPanelAction.DraggableFormFieldsClick, new UserInsight({
        Page: UserInsightPage.PreparePage,
        Action: UserInsightAction.DraggableFormFieldsAction,
        Origin: UserInsightOrigin.PrepareDocument
      }));
      if (args.formElement && args.formElement.children && args.formElement.elementType !== 'radiobutton') {
        for (const formElement of args.formElement.children) {
          this.moveFormElementToAbsolutePage(formElement);
        }
      } else {
        this.moveFormElementToAbsolutePage(args.formElement);
      }
      if (this.pdfFormElement.isEditDocument && this.pdfFormElement.selectedFormElement) {
        this.pdfFormElement.showValidationForIntersection(this.pdfFormElement.selectedFormElement);
      }
      this.advanceSettingsInstance.updatePositionForFormFields(args.formElement);
      this.$mutation.updateMainData({ isPageModified: true });
    },

    sizeChange (args: any): void {
      if (args.state === 'Started') {
        const signerDetails = this.$session.signerData.signerDetails.find(x => x.id === args.formElement.signerId);
        if (signerDetails) {
          if (args.formElement.elementType === 'signature') {
            args.value = this.pdfFormElement.getImageValue(signerDetails.signerName || 'Sample Signature');
          } else if (args.formElement.elementType === 'initial') {
            args.value = this.pdfFormElement.getImageValue(signerDetails.signerName ? UtilityMethods.getInitial(signerDetails.signerName) : 'IN');
          }
        }
        this.$mutation.updateMainData({ preventDraftSave: true });
      } else {
        this.advanceSettingsInstance.updateMaximumCharacterSpacingResize(this.pdfFormElement.selectedFormElement);
        this.advanceSettingsInstance.updatePositionForFormFields(this.pdfFormElement.selectedFormElement);
        this.$nuxt.$userInsight.track(MixPanelAction.ResizeFormFieldsClick, new UserInsight({
          Page: UserInsightPage.PreparePage,
          Action: UserInsightAction.ResizeFormFieldsAction,
          Origin: UserInsightOrigin.PrepareDocument
        }));
        this.$mutation.updateMainData({ isPageModified: true, preventDraftSave: false });
      }
    },

    formElementDragStart (): void {
      const menuList = (this as any).$refs.pdfFormContextMenu.ej2Instances as any;
      if (menuList && !menuList.isMenusClosed) {
        menuList.close();
      }
      this.$mutation.updateMainData({ preventDraftSave: true });
    },

    formElementDragEnd (args: any): void {
      this.$nuxt.$userInsight.track(MixPanelAction.DraggableFormFieldsClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.DraggableFormFieldsAction, Origin: UserInsightOrigin.PrepareDocument }));
      this.$mutation.updateMainData({ isPageModified: true, preventDraftSave: false });
      if (args.formElement) {
        const elementDetails = this.advanceSettingsInstance.getSelectedFormElement(args.formElement);
        if (elementDetails.isMultiSelect || args.formElement.id !== 'multipleSelection') {
          this.advanceSettingsInstance.isMultiSelect = false;
          this.advanceSettingsInstance.hideAssignOption = false;
          if (!elementDetails.isMultiSelect) {
            this.$data.selectedElementType = this.advanceSettingsInstance.selectedElementType = args.formElement.elementType;
          }
          if (!this.$data.isMobileMode) {
            this.advanceSettingsInstance.showAdvance();
          }
          if (elementDetails.formElement.elementType === 'hyperlink') {
            this.advanceSettingsInstance.getHyperLinkElementId();
          }
        }
        if (!elementDetails.isMultiSelect) {
          if (args.formElement.children && args.formElement.elementType !== 'radiobutton') {
            for (const formElement of args.formElement.children) {
              this.moveFormElementToAbsolutePage(formElement);
            }
          } else {
            this.moveFormElementToAbsolutePage(args.formElement);
          }
        }
        this.advanceSettingsInstance.updatePositionForFormFields(args.formElement);
      }
    },

    collectionChange (args: any): void {
      if (args.allowDelete || args.allowCut) {
        if (this.pdfFormElement.selectedFormElement) {
          const context = (this as any);
          const toastObj = context.$refs.customToast;
          toastObj.hide();
          if (args.allowDelete && !args.isMultiSelect) {
            toastObj.show(context.$t('preparePage.cannotDelete'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
          } else if (args.allowDelete && args.isMultiSelect) {
            toastObj.show(context.$t('preparePage.cannotDeleteFromMultiSelection'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
          } else if (args.allowCut && !args.isMultiSelect) {
            toastObj.show(context.$t('preparePage.cannotCut'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
          } else {
            toastObj.show(context.$t('preparePage.cannotCutFromMultiSelection'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
          }
        }
      } else {
        this.thumbnailInstance.updateThumbnailFieldCount(args.activePageIndex);
        if (args.type === 'Remove' && args.oldPageIndex && args.oldPageIndex !== args.activePageIndex) {
          this.thumbnailInstance.updateThumbnailFieldCount(args.oldPageIndex);
        }
        this.$mutation.updateMainData({ isPageModified: true });
        window.sessionStorage.setItem('isModified', 'True');
        this.advanceSettingsInstance.enablePreviewPage();
        if (args.type === 'Remove') {
          this.closeAdvance();
        } else if (args.type === 'Insert' && args.formElement !== null && !args.isMultipleSelection) {
          this.$data.selectedElementType = args.formElement.elementType;
          if (!this.$data.isMobileMode) {
            this.advanceSettingsInstance.showAdvance();
          }
        }
      }
    },

    textChange (args: any): void {
      this.advanceSettingsInstance.textChange(args);
    },

    fontSizeChangeOnResize (args: any) {
      this.advanceSettingsInstance.fontSizeChangeOnResize(args);
    },

    tabIndexChange (): void {
      this.advanceSettingsInstance.tabIndexChange();
    },

    indexPositionChange (args: any): void {
      this.advanceSettingsInstance.indexPositionChange(args);
    },

    moveFormElementToAbsolutePage (formElement: FormElement): void {
      const pageData: { [key: string]: number } = this.pdfFormElement.moveElementToAbsolutePage(formElement);
      if (pageData.oldPageIndex !== pageData.activePageIndex) {
        this.thumbnailInstance.updateThumbnailFieldCount(pageData.activePageIndex);
        this.thumbnailInstance.updateThumbnailFieldCount(pageData.oldPageIndex);
      }
    },

    documentDoubleClick (evt: MouseEvent): void {
      if (this.pdfFormElement.selectedFormElement) {
        const selectedElement: FormElement = this.pdfFormElement.selectedFormElement;
        if (!selectedElement || selectedElement.id === 'multipleSelection') {
          return;
        }
        if (selectedElement.elementType === 'checkbox') {
          this.$nuxt.$userInsight.track(MixPanelAction.CheckBoxDefaultValueClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.CheckBoxDefaultValueAction, Origin: UserInsightOrigin.PrepareDocument }));
        } else if (selectedElement.elementType === 'radiobutton') {
          this.$nuxt.$userInsight.track(MixPanelAction.RadioButtonDefaultValueClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.RadioButtonDefaultValueAction, Origin: UserInsightOrigin.PrepareDocument }));
        }
        if (!this.pdfFormElement.isEditing && selectedElement && !this.pdfFormElement.isConditionalPage) {
          if (selectedElement.elementType === 'textbox' || selectedElement.elementType === 'label' || (selectedElement.elementType === 'title' && this.$session.mainData.isSelfSign)) {
            const target: any = evt.target;
            if (target && target.parentNode && target.parentNode.className && target.parentNode.className.baseVal === 'pdf-form-element') {
              this.pdfFormElement.startEdit();
            }
          } else if (selectedElement.elementType === 'radiobutton') {
            const radioElement: Element = UtilityMethods.isChildFormElement(evt.target as Element);
            if (radioElement) {
              this.pdfFormElement.updateFormElement({ id: selectedElement.id, children: [{ id: radioElement.id }] });
              if (!this.$session.mainData.isSelfSign) {
                this.advanceSettingsInstance.updateRadioChildCheckboxValue(radioElement.id, selectedElement.children.find(x => x.id === radioElement.id).value === 'on');
                this.$mutation.updateMainData({ isPageModified: true });
              }
              this.advanceSettingsInstance.enablePreviewPage();
            }
          } else if (selectedElement.elementType === 'checkbox') {
            const formElement: Element = UtilityMethods.getFormElement(evt.target as Element);
            if (formElement) {
              this.pdfFormElement.updateFormElement({ id: selectedElement.id, value: selectedElement.value === 'on' ? 'off' : 'on' });
              this.advanceSettingsInstance.updateCheckboxValue(selectedElement.id, selectedElement.value);
              this.$mutation.updateMainData({ isPageModified: true });
              if (selectedElement.dataSyncTag && this.advanceSettingsInstance.dataSyncTagElementIdList.length > 1) {
                this.advanceSettingsInstance.processDataSyncTags();
                this.advanceSettingsInstance.preventPropertyChange = false;
                this.advanceSettingsInstance.showPropertyChangeToast();
              }
              this.advanceSettingsInstance.enablePreviewPage();
            }
          } else if (selectedElement.elementType === 'editabledate' && !this.$session.mainData.isSelfSign) {
            const target: any = evt.target;
            if (target && target.parentNode && target.parentNode.className && target.parentNode.className.baseVal === 'pdf-form-element') {
              this.setDatePickerDetails();
            }
          } else if (selectedElement.elementType === 'image') {
            const target: any = evt.target;
            if (target && target.parentNode && target.parentNode.className && target.parentNode.className.baseVal === 'pdf-form-element') {
              if (this.$session.mainData.isSelfSign) {
                this.imageInstance.show(selectedElement);
              } else {
                this.imageInstance.show(selectedElement, 'PREPARE');
              }
            }
          } else if (selectedElement.elementType === 'dropdown') {
            this.dropdownObjInstance.hidePopup();
            const target: any = evt.target;
            if (target && target.parentNode && target.parentNode.className && target.parentNode.className.baseVal === 'pdf-form-element' && selectedElement.dropdownOptions !== null && selectedElement.dropdownOptions.length > 0) {
              if ((selectedElement.dropdownOptions.length === 1 && selectedElement.dropdownOptions[0]) || selectedElement.dropdownOptions.length > 1) {
                this.pdfFormElement.startSelect();
                const dropdownPopUpBounds = UtilityMethods.getDropdownPopUpBounds(selectedElement);
                this.$data.dropdownPopUpY = dropdownPopUpBounds.dropdownPopUpY;
                this.$data.dropdownPopUpX = dropdownPopUpBounds.dropdownPopUpX;
                this.$data.dropdownWidth = dropdownPopUpBounds.dropdownWidth;
                this.$data.showDropdown = true;
                this.advanceSettingsInstance.updateRelativeFieldConditionalSelector(selectedElement);
                const currentDropDownOption = this.$session.advanceSettings.currentDropdownOptions;
                this.$data.currentDropdownOptions = currentDropDownOption;
                this.$data.dropdownValue = selectedElement.value;
                setTimeout(() => {
                  this.dropdownObjInstance.showPopup();
                }, 0);
              }
            }
          }
        }
      }
    },

    setDatePickerDetails (): void {
      this.getDatePickerBounds();
      setTimeout(() => {
        this.datePickerObjInstance.show();
      }, 100);
    },

    getDatePickerBounds (): void {
      const selectedElement = this.pdfFormElement.selectedFormElement;
      const datePickerHeight = 257;
      const formElement = document.getElementById(selectedElement.id);
      const elementBounds: ClientRect = formElement.getBoundingClientRect();
      this.$data.datePickerPopUpY = elementBounds.top + elementBounds.height;
      this.$data.datePickerPopUpX = elementBounds.left;
      const advanceSettings = this.$session.advanceSettings;
      this.$data.minDate = advanceSettings.minDate;
      this.$data.maxDate = advanceSettings.maxDate;
      this.$data.datePickerValue = advanceSettings.datePickerValue;
      this.$data.dateFormat = advanceSettings.dateFormat;
      if (window.innerHeight < elementBounds.top + elementBounds.height + datePickerHeight) {
        this.$data.datePickerPopUpY = elementBounds.top - datePickerHeight;
      }
    },

    openPdfFormFieldDatePicker (args: PopupObjectArgs): void {
      args.popup.offsetX = this.$data.datePickerPopUpX;
      args.popup.offsetY = this.$data.datePickerPopUpY;
    },

    selectDate (args: any): void {
      this.advanceSettingsInstance.selectDate(args);
    },

    imageBtnClick (): void {
      const elementDetails = UtilityMethods.getCommonFormElement(this.pdfFormElement.selectedFormElement);
      this.imageInstance.show(elementDetails.formElement, 'PREPARE');
    },

    /* Client Side Events Handling PdfViewer Component - End */

    /* Signature Dialog Client Side Events Handling - Start */

    applySignerValue (args: any): void {
      const element: FormElement = this.pdfFormElement.selectedFormElement;
      const signatureType: string = args.signatureType;
      if (signatureType === 'Text') {
        this.signatureDetails = UtilityMethods.updateSignatureDetailText(this.signatureDetails, element.elementType, JSON.parse(args.data));
      }
      const signDetails = this.signatureDetails.find(x => x.elementType === element.elementType);
      if (signDetails && args.data) {
        signDetails.signatureType = signatureType;
        signDetails.signatureValue = args.data;
      }
      if (!element.value && !this.pdfFormElement.getFormElementById(element.id)) {
        const newFormElement: FormElement = {
          id: 'signature_' + UtilityMethods.getUniqueID(),
          elementType: element.elementType,
          value: element.elementType === 'signature' ? args.signatureValue : args.initialValue,
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height,
          signerId: this.advanceSettingsInstance.selectedAssignee,
          signatureType,
          maxHeight: element.height,
          minHeight: 24,
          minWidth: element.elementType === 'signature' ? 56 : 28,
          fontSize: 12,
          signData: args.data,
          fill1: element.fill1,
          fill2: element.fill2,
          linePadding: 17,
          isRequired: false
        };
        this.pdfFormElement.add(newFormElement);
      } else {
        this.pdfFormElement.updateFormElement({ id: element.id, value: element.elementType === 'signature' ? args.signatureValue : args.initialValue, signatureType, signData: args.data });
        this.advanceSettingsInstance.enablePreviewPage();
      }
      if (this.pdfFormElement.selectedFormElement) {
        this.pdfFormElement.selectedFormElement.originalImageBounds = args.signatureBounds;
      }
      const lastSavedValue = {
        value: this.pdfFormElement.selectedFormElement.value,
        originalImageBounds: this.pdfFormElement.selectedFormElement.originalImageBounds,
        signData: this.pdfFormElement.selectedFormElement.signData,
        signatureType: this.pdfFormElement.selectedFormElement.signatureType
      };
      if (element.elementType === 'signature') {
        this.lastSavedSignature = lastSavedValue;
      } else {
        this.lastSavedInitial = lastSavedValue;
      }
      if (args.applyEveryWhere) {
        this.updateAllFieldValues(args, element.elementType);
      }
    },

    updateAllFieldValues (args: any, elementType: string) {
      for (const pageFormElement of this.pdfFormElement.pageFormElementsList) {
        for (const formElement of pageFormElement.formElements) {
          if (formElement.elementType === elementType && formElement.id !== this.pdfFormElement.selectedFormElement.id) {
            this.pdfFormElement.updateFormElement({
              id: formElement.id,
              elementType: formElement.elementType,
              value: elementType === 'signature' ? args.signatureValue : args.initialValue,
              signatureType: args.signatureType,
              signData: args.data
            });
          }
        }
      }
    },

    openSignDialog (elementType: string) {
      if (elementType === 'signature') {
        this.signatureInstance.show(UtilityMethods.getSignatureDetails(this.signatureDetails, elementType), 7);
      } else {
        this.initialInstance.show(UtilityMethods.getSignatureDetails(this.signatureDetails, elementType), 7);
      }
    },

    /* Signature Dialog Client Side Events Handling - End */

    applyImageValue (args: any): void {
      const element: FormElement = this.pdfFormElement.selectedFormElement;
      if (!element.value && !this.pdfFormElement.getFormElementById(element.id)) {
        const newFormElement: FormElement = {
          id: 'image_' + UtilityMethods.getUniqueID(),
          elementType: element.elementType,
          value: args.imageValue,
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height,
          signerId: this.advanceSettingsInstance.selectedAssignee,
          maxHeight: element.height,
          minHeight: 24,
          minWidth: 56,
          fontSize: 12,
          signData: args.data,
          fill1: element.fill1,
          fill2: element.fill2,
          linePadding: 17,
          isRequired: false,
          originalImageBounds: args.imageBounds
        };
        newFormElement.isImageCropped = args.isImageCropped;
        this.pdfFormElement.add(newFormElement);
      } else {
        this.updateImageValue(args, element);
      }
    },

    updateImageValue (args: any, element: FormElement): void {
      this.$mutation.updateMainData({ isPageModified: true });
      this.$nuxt.$userInsight.track(MixPanelAction.UpdateImageValueClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.UpdateImageValueAction, Origin: UserInsightOrigin.PrepareDocument }));
      if (UtilityMethods.isAutoPositioned(element) || this.advanceSettingsInstance.isMultiSelect) {
        for (const formELement of element.children) {
          formELement.paddingLeft = args.imageValue ? 4 : 28;
          element.originalImageBounds = args.imageBounds;
          this.pdfFormElement.updateFormElement({ id: formELement.id, value: args.imageValue, signData: args.data, isImageCropped: args.isImageCropped });
        }
      } else {
        element.paddingLeft = args.imageValue ? 4 : 28;
        element.originalImageBounds = args.imageBounds;
        this.pdfFormElement.updateFormElement({ id: element.id, value: args.imageValue, signData: args.data, isImageCropped: args.isImageCropped });
      }
      if (this.advanceSettingsInstance.dataSyncTagElementIdList.length > 1) {
        this.advanceSettingsInstance.processDataSyncTags();
        this.advanceSettingsInstance.showPropertyChangeToast((this as any).$t('preparePage.imageValuePropertyChange'));
      }
      this.advanceSettingsInstance.enablePreviewPage();
    },

    /* Pdfviewer Control Client Side Events Handling - Start */

    loadPdf (): void {
      const pdfViewer: PdfViewerComponent = this.pdfRenderInstance.pdfViewer;
      const uploadDocumentList: DocumentProperties[] = this.$session.mainData.uploadedDocumentList;
      const removedDocumentList: DocumentProperties[] = this.$session.mainData.removedDocumentList;
      const embedData = this.$session.embedData;
      const canAllowMultipleUpload = embedData.isEmbedPage && uploadDocumentList.length === 1 && uploadDocumentList[0].parentId && removedDocumentList.length === 0;
      if (uploadDocumentList.concat(removedDocumentList).length > 1 || canAllowMultipleUpload) {
        if (this.$session.mainData.enableMultipleUpload) {
          if (embedData.isEmbedPage) {
            this.$nuxt.$api.preparePage.embedMultipleUpload({
              data: uploadDocumentList.concat(removedDocumentList),
              query: {
                documentId: embedData.documentId,
                embedId: embedData.embedId,
                organizationId: embedData.organizationId
              }
            }).then((data) => {
              this.$mutation.updateMainData({ enableMultipleUpload: false });
              this.loadPDFViewer(UtilityMethods.deleteDocumentName(uploadDocumentList));
            }).catch((e: any) => {
            });
          } else {
            this.$nuxt.$api.preparePage.multipleUpload({
              data: uploadDocumentList.concat(removedDocumentList),
              query: {}
            }).then((data) => {
              this.$mutation.updateMainData({ enableMultipleUpload: false });
              this.loadPDFViewer(UtilityMethods.deleteDocumentName(uploadDocumentList));
            }).catch((e: any) => {
            });
          }
        } else {
          this.loadPDFViewer(UtilityMethods.deleteDocumentName(uploadDocumentList));
        }
      } else if (uploadDocumentList.length > 1 || (uploadDocumentList.length === 1 && uploadDocumentList[0].parentId)) {
        this.loadPDFViewer(UtilityMethods.deleteDocumentName(uploadDocumentList));
      } else {
        this.loadPDFViewer(this.$session.mainData.parentDocumentId);
      }
    },

    loadPDFViewer (args: any): void {
      clearInterval(this.lastInterval);
      const pdfViewer: PdfViewerComponent = this.pdfRenderInstance.pdfViewer;
      if (this.$session.mainData.isDocumentAddedorReplaced) {
        this.autoDetectPdfFields();
      }
      this.lastInterval = setInterval((): any => {
        if (this.$session.mainData.isDraftSaved) {
          const mainData = this.$session.mainData;
          this.pdfFormElement.signbuilderType = mainData.signbuilderType;
          this.updateElementsPositionInReplaceDoc();
          pdfViewer.load(args, null);
          clearInterval(this.lastInterval);
        } else if (this.$session.mainData.preventDraftSave) {
          this.$mutation.updateMainData({ preventDraftSave: false });
        }
      }, 1000);
    },

    pdfDocumentLoad (args: any): void {
      const mainData = this.$session.mainData;
      const autoReminderDetail = this.$session.reviewData;
      this.pdfFormElement.initDroppableElement(mainData.parentDocumentId, UtilityMethods.getPageCount(mainData.uploadedDocumentList), args.pageData, autoReminderDetail.enableDocumentID);
      this.$data.isPdfDocLoaded = true;

      const pdfInstance: any = this.pdfFormElement.pdfInstance;
      UtilityMethods.updateZoomProperties(this.$data.isLatestVersion, pdfInstance);
      if (pdfInstance.zoomPercentage !== 100) {
        this.pdfFormElement.scaleFormContainer(pdfInstance.zoomPercentage);
      }
      this.customEvent = new CustomEventHandler(document.getElementById('pdfViewer_parent'), this.pdfFormElement);
      this.customFieldsInterval = setInterval((): any => {
        if (this.$session.prepareData.canloadCustomFieldDesign) {
          this.fieldContainerInstance.loadFieldContainer(this.pdfFormElement, this.customEvent);
          this.loadFormElements();
          clearInterval(this.customFieldsInterval);
        }
      }, 1000);
      // if (UtilityMethods.canEnableAIFieldDetection(this) && mainData.canShowAIFieldDetectionTour) {
      //   this.$mutation.updateMainData({ showIntroDialog: true });
      // } else {
      //   this.$mutation.updateMainData({ showIntroDialog: false });
      // }
    },

    loadFormElements (): void {
      const sessionStorageDatas: any = this.$session;
      if (this.$data.isPdfDocLoaded && this.$data.isFieldsUpdated) {
        if (sessionStorageDatas.prepareData.formElementsData) {
          const formElementsData = JSON.parse(sessionStorageDatas.prepareData.formElementsData);
          for (const pageFormElement of formElementsData.pageFormElementsList) {
            for (const formElement of pageFormElement.formElements) {
              formElement.customFieldId = '';
              if (formElement.elementType === 'radiobutton') {
                let count = 1;
                for (const children of formElement.children) {
                  children.label = children.label ? children.label : 'RadioChild' + count;
                  count++;
                }
              } else if (formElement.elementType === 'title') {
                formElement.value = sessionStorageDatas.mainData.isSelfSign ? formElement.value || sessionStorageDatas.mainData.jobTitle : formElement.value;
              } else if (formElement.elementType === 'company') {
                formElement.value = sessionStorageDatas.mainData.isSelfSign ? sessionStorageDatas.mainData.companyName : formElement.value;
              }
              formElement.isRequired = sessionStorageDatas.mainData.isSelfSign ? false : formElement.isRequired;
            }
          }
          this.hasAIField(JSON.parse(JSON.stringify(formElementsData)));
          this.pdfFormElement.load(JSON.stringify(formElementsData), sessionStorageDatas.mainData.resetStartPosition, this.$data.pageNoList, this.$data.isTemplatePage);
          if (sessionStorageDatas.mainData.resetStartPosition || this.$data.pageNoList.length > 0) {
            this.$mutation.updatePrepareFormData({ formElementsData: this.pdfFormElement.save() });
            this.$mutation.updateMainData({ resetStartPosition: false });
            this.$data.pageNoList = [];
          }
        }
        this.$eventBus.emit('setfooterClass', '');
        this.advanceSettingsInstance.enablePreviewPage();
        this.thumbnailInstance.loadThumbnail(this.pdfFormElement, sessionStorageDatas.mainData.uploadedDocumentList, 'prepare');
        this.fieldContainerInstance.showTooltip();
        this.isDocumentLoaded = true;
      }
    },

    updateValuesForFieldsOnPageLoad (pageFormElements: PageFormElements[]): void {
      const mainData: any = this.$session.mainData;
      const droppedPageFormElements: PageFormElements[] = [];
      for (const pageFormElement of pageFormElements) {
        const droppedFields: FormElement[] = [];
        for (const formElement of pageFormElement.formElements) {
          const clonedFormElement: FormElement = this.pdfFormElement.cloneFormElementForSave(formElement);
          clonedFormElement.visibility = true;
          if (mainData.isSelfSign) {
            ConditionalLogicMethods.revertConditionalLogic(clonedFormElement, true);
          }
          const signerDetails: any = this.$session.signerData.signerDetails.find(x => x.id === clonedFormElement.signerId);
          const allowUpdate = UtilityMethods.canAllowEditing(clonedFormElement, this.pdfFormElement);
          if (allowUpdate && signerDetails !== null) {
            if (clonedFormElement.elementType === 'name') {
              clonedFormElement.value = signerDetails.signType === SignType.Single ? signerDetails.signerName : '';
            } else if (clonedFormElement.elementType === 'email') {
              clonedFormElement.value = signerDetails.signType === SignType.Single ? signerDetails.signerMail : '';
            } else if ((clonedFormElement.elementType === 'title' || clonedFormElement.elementType === 'company') && !this.$session.mainData.isSelfSign && clonedFormElement.value) {
              clonedFormElement.value = '';
            }
          }
          if (formElement.elementType === 'datepicker' && mainData.isSelfSign) {
            const dateFormat = formElement.label || this.$session.reviewData.dateFormat;
            const timeFormat = formElement.timeFormat || this.$session.reviewData.timeFormat;
            const dateTimeFormat: string = UtilityMethods.getDateTimeFormat(dateFormat, timeFormat);
            clonedFormElement.value = this.globalize.formatDate(new Date(), { format: dateTimeFormat });
          }
          droppedFields.push(clonedFormElement);
        }
        if (droppedFields.length > 0) {
          droppedPageFormElements.push({ formElements: droppedFields, pageIndex: pageFormElement.pageIndex });
        }
      }

      this.$mutation.updatePrepareFormData({ formElementsData: JSON.stringify({ pageFormElementsList: droppedPageFormElements }) });
    },

    updateTooltip (): void {
      this.$mutation.updateEmbedData({ showTooltip: false });
      if (this.$data.isDesktopMode) {
        this.fieldContainerInstance.closeTooltip();
      } else {
        this.$data.tooltipDlgVisibility = false;
      }
    },

    closeTooltip (): void {
      const tooltipObj: any = this.$refs.customTooltip;
      tooltipObj.ej2Instances.close();
      tooltipObj.ej2Instances.opensOn = 'Auto';
      tooltipObj.ej2Instances.dataBind();
    },

    getVisibilityOfTooltipDialog (): void {
      const $this = this as any;
      const element = document.getElementById('tooltipDlg');
      const parentElement = element.parentElement;
      parentElement.classList.add('tooltipDlg-parent-container');
      this.$data.tooltipDlgVisibility = true;
    },

    pdfPageChange (args: PageChangeEventArgs): void {
      if (!this.pdfFormElement.isConditionalPage) {
        this.pdfFormElement.selectedPageIndex = args.currentPageNumber;
        this.thumbnailInstance.onPageChangeEvent(args, this.$session.mainData.uploadedDocumentList);
      }
    },
from prepare helper ts
export default defineComponent({
  name: 'PreviewHelper',
  components: {
    'ejs-dropdownlist': DropDownListComponent,
    'ejs-tooltip': TooltipComponent,
    'ejs-textbox': TextBoxComponent,
    'ejs-datepicker': DatePickerComponent,
    PreviewProgressTemplate,
    PDFViewerRenderComponent,
    CustomToast
  },

  data (): any {
    const app = createApp({});
    const iTemplate = app.component('ItemVue', itemVue);
    const pdfFormElement: PdfFormElements = null;
    const pdfRenderInstance: any = null;
    const signerId: string = '';
    const dropdownObjInstance: any = null;
    const dropDownTooltip: Tooltip = null;
    const globalize: Internationalization = new Internationalization();
    const datePickerObjInstance: DatePicker = null;
    const formulaStringInstance: FormulaStringValidation = null;
    const customToastObj: any = null;
    const reviewData: any = this.$session.reviewData;
    const signbuilderType: string = this.$session.mainData.signbuilderType;
    let expiryDate: Date = new Date();
    expiryDate.setDate(expiryDate.getDate() + 60);
    if (reviewData.expiryDate) {
      expiryDate = new Date(reviewData.expiryDate);
    }
    let assigneeTextField: string = 'customSignerName';
    if (signbuilderType === 'createtemplate' || signbuilderType === 'createlink' || signbuilderType === 'usetemplate') {
      assigneeTextField = 'signerRole';
    }
    const signerDetails = this.$session.signerData.signerDetails;
    const canDisplayRecipientAndDocMsgSection = (signbuilderType === 'createlink' && signerDetails.length > 1) || signbuilderType !== 'createlink';
    const datePickerPopUpX: number = 0;
    const datePickerPopUpY: number = 0;
    return {
      pdfFormElement,
      pdfRenderInstance,
      signerId,
      dropdownObjInstance,
      dropDownTooltip,
      globalize,
      datePickerObjInstance,
      formulaStringInstance,
      customToastObj,
      fields: { text: 'text', value: 'value' },
      dateFormat: 'dd-MMM-yyyy',
      date: expiryDate,
      expireWarning: (this as any).$t('documentSettings.expireWarning'),
      assigneeFields: { text: assigneeTextField, value: 'id' },
      signerValues: [],
      isEmbedPage: this.$session.embedData.isEmbedPage,
      embedPageType: this.$session.embedData.embedPageType,
      selectedAssignee: null,
      enableSubjectEditing: this.$session.signerData.enableSubjectEditing,
      titlePlaceHolder: this.$t('signerSettings.titlePlaceHolder'),
      recipientPlaceHolder: this.$t('signerSettings.recipientPlaceHolder'),
      signbuilderType,
      linkLimit: reviewData.linkLimit,
      enableLimit: reviewData.enableLimit,
      prepareProgress: true,
      moreActions: [],
      currentDropdownOptions: [],
      showDropdown: false,
      dropdownFields: {
        text: 'value',
        value: 'value'
      },
      dropdownValue: null,
      dropdownPlaceholder: this.$t('common.dropdownTxt'),
      dropdownPopUpX: 0,
      dropdownPopUpY: 0,
      dropdownWidth: 0,
      responsiveMode: ResponsiveMode,
      responsivePageType: ResponsivePageType,
      canDisplayRecipientAndDocMsgSection,
      iTemplate: function () {
        return {
          template: iTemplate
        };
      },
      deliveryMode: DeliveryMode,
      isLatestVersion: false,
      showTodayButton: false,
      selectedElementType: '',
      isFormulaPresent: false
    };
  },

  mounted (): void {
    useHead({ title: this.$session.signerData.messageTitle + ' - ' + this.$t('metaInfo.previewPageMetaInfo') });
    const context = this as any;
    this.$data.isLatestVersion = UtilityMethods.isLatestVersionedDocument(this.$session.mainData.documentVersion);
    this.defineDropdownValues();
    this.$data.selectedAssignee = context.signerValues[0].id;
    this.pdfRenderInstance = this.$refs.pdfRenderObj;
    this.pdfFormElement = this.pdfRenderInstance.PdfFormElement;
    this.formulaStringInstance = new FormulaStringValidation(this.pdfFormElement);
    this.dropdownObjInstance = this.$refs.dropDownFormFieldObj;
    this.datePickerObjInstance = (this.$refs.datePickerObj as any).ej2Instances;
    this.customToastObj = this.$refs.customToast;
    this.loadPdf();

    // set brand button color and button text color.
    const { buttonColor, buttonTextColor } = this.$session.embedData;
    UtilityMethods.setBrandButton(buttonColor, buttonTextColor);
  },

  unmounted (): void {
    const parentElement: HTMLElement = document.getElementsByClassName('bs-review-page')[0] as HTMLElement;
    parentElement.style.display = 'none';
    if (this.dropDownTooltip) {
      this.dropDownTooltip.destroy();
    }
    // this.$mutation.updatePrepareFormData({ formElementsData: this.pdfFormElement.save() });
  },

  methods: {
    defineDropdownValues () {
      const context = this as any;
      context.$data.signerValues = [{
        customSignerName: context.$t('previewPage.allRecipients'),
        signerName: context.$t('previewPage.allRecipients'),
        id: '0'
      }];
      for (let data = 0; data < this.$session.signerData.signerDetails.length; data++) {
        context.$data.signerValues.push(this.$session.signerData.signerDetails[data]);
      }
    },

    loadPdf (): void {
      debugger
      const pdfViewer: PdfViewerComponent = this.pdfRenderInstance.pdfViewer as PdfViewerComponent;
      const uploadDocumentList: DocumentProperties[] = this.$session.mainData.uploadedDocumentList;
      if (uploadDocumentList.length > 1 || (uploadDocumentList.length === 1 && uploadDocumentList[0].parentId)) {
        pdfViewer.load(UtilityMethods.deleteDocumentName(uploadDocumentList), null);
      } else {
        pdfViewer.load(this.$session.mainData.parentDocumentId, null);
      }
    },

    pdfDocumentLoad (args: any): void {
      debugger
      const pdfInstance: any = this.pdfFormElement.pdfInstance;
      const mainData = this.$session.mainData;
      const autoReminderDetail = this.$session.reviewData;
      UtilityMethods.updateZoomProperties(this.$data.isLatestVersion, pdfInstance);
      this.pdfFormElement.initDroppableElement(mainData.parentDocumentId, UtilityMethods.getPageCount(mainData.uploadedDocumentList), args.pageData, autoReminderDetail.enableDocumentID);

      if (pdfInstance.zoomPercentage !== 100) {
        this.pdfFormElement.scaleFormContainer(pdfInstance.zoomPercentage);
      }
      if (this.$session.prepareData.formElementsData) {
        this.pdfFormElement.load(this.$session.prepareData.formElementsData);
      }
      this.$data.thumbState = ' show-progress';
      this.$data.prepareProgress = false;
      this.$eventBus.emit('setfooterClass', '');

      // loading by default first value of the dropdown//
      const event: CustomEventHandler = new CustomEventHandler(document.getElementById('pdfViewer_parent'), this.pdfFormElement);
      const selectAll = '0';
      this.loadPdfForSigners(selectAll);
      this.$data.isFormulaPresent = UtilityMethods.getAllFormulaElements(this.pdfFormElement.pageFormElementsList).length > 0;
      if (this.$data.isFormulaPresent) {
        this.updateDatePickerValue();
        this.formulaStringInstance.setValueForAllFormulaFields();
      }
    },

    loadPdfForSigners (signerId: any) {
      this.signerId = signerId;
      this.pdfFormElement.pageFormElementsList.forEach((value, index) => {
        value.formElements.forEach((value1) => {
          if (value1.elementType !== 'label') {
            if (value1.signerId !== signerId && signerId !== '0') {
              value1.visibility = false;
            } else {
              value1.visibility = true;
            }
            if (!value1.parentRule) {
              this.pdfFormElement.updateFormElement({
                id: value1.id,
                visibility: value1.visibility
              });
            }
          }
        });
      });

      this.pdfFormElement.setConditionalFieldVisibility(this.pdfFormElement.pageFormElementsList);
      this.updateFieldVisibilityCount(signerId);
    },

    updateFieldVisibilityCount (signerId: any) {
      this.$data.moreActions = [];
      const signerDetails = this.$session.signerData.signerDetails;
      if (signerId === '0') {
        for (let i = 0; i < signerDetails.length; i++) {
          this.$mutation.updateSignerDetailsData({ fieldsVisibilityCount: this.getFieldVisibilityCount(signerDetails[i].id), index: i });
          this.$data.moreActions.push(signerDetails[i]);
        }
      } else {
        const signerDetail = signerDetails.find((x: any) => x.id === signerId);
        this.$mutation.updateSignerDetailsData({ fieldsVisibilityCount: this.getFieldVisibilityCount(signerDetail.id), index: signerDetails.findIndex(x => x.id === signerId) });
        this.$data.moreActions.push(signerDetail);
      }
    },

    getFieldVisibilityCount (signerId: string): number {
      let formFieldVisibilityCount = 0;
      for (const pageFormElements of this.pdfFormElement.pageFormElementsList) {
        const formElements = pageFormElements.formElements.filter(x => x.elementType !== 'checkbox');
        for (const formElement of formElements) {
          if (formElement.signerId === signerId && formElement.visibility) {
            formFieldVisibilityCount++;
          }
        }
      }
      const groupCheckbox = this.pdfFormElement.checkboxFieldCount();
      formFieldVisibilityCount += groupCheckbox.filter(x => x.signerId === signerId).length;
      return formFieldVisibilityCount;
    },

    updateDatePickerValue () {
      this.pdfFormElement.pageFormElementsList.forEach((pageFormElements) => {
        pageFormElements.formElements.forEach((formElement) => {
          if (formElement.elementType === 'datepicker' && !formElement.value && UtilityMethods.fieldUsedInFormula(formElement, this.pdfFormElement.pageFormElementsList)) {
            const dateTimeFormat: string = UtilityMethods.getDateTimeFormat(formElement.label, formElement.timeFormat);
            const dateValue = this.globalize.formatDate(new Date(), { format: dateTimeFormat });
            this.pdfFormElement.updateFormElement({ id: formElement.id, value: dateValue });
          }
        });
      });
    },

    conditionalLogicSelectionChange (args: any): void {
      if (args.formElement.elementType === 'checkbox') {
        this.pdfFormElement.updateFormElement({ id: args.formElement.id, value: args.formElement.value === 'on' ? 'off' : 'on' });
        if (args.formElement.dataSyncTag) {
          const selectedElement = args.formElement;
          const groupedElements = this.pdfFormElement.GetCheckboxGroupByDataSyncTag(selectedElement.dataSyncTag, selectedElement.signerId);
          if (Object.keys(groupedElements).length <= 1) {
            return;
          }
          const selectedGroup = groupedElements[selectedElement.groupName];
          for (const groupName in groupedElements) {
            if (groupName === selectedElement.groupName) {
              continue;
            }
            const targetGroup = groupedElements[groupName];
            if (targetGroup.length === selectedGroup.length) {
              const targetElementToUpdate = targetGroup.find(x => x.label === selectedElement.label);
              if (targetElementToUpdate) {
                this.pdfFormElement.updateFormElement({ id: targetElementToUpdate.id, value: args.formElement.value });
                if (args.formElement.conditionalRules && args.formElement.conditionalRules.length > 0) {
                  // For the elements with same data sync tags handled the conditional logics here
                  this.pdfFormElement.showCheckboxRelativeFields(targetElementToUpdate, targetElementToUpdate.value === 'on');
                }
              }
            }
          }
        }
        // For the current element conditional logic handlings.
        if (args.formElement.conditionalRules && args.formElement.conditionalRules.length > 0) {
          this.pdfFormElement.showCheckboxRelativeFields(args.formElement, args.formElement.value === 'on');
        }
      } else if (args.formElement.elementType === 'dropdown') {
        if (this.$data.isFormulaPresent) {
          this.formulaStringInstance.setValueForAllFormulaFields();
        }
      } else if (args.formElement.elementType === 'dropdown') {
        this.openDropDownPopup(args);
      } else {
        const radioElement: Element = UtilityMethods.isChildFormElement(args.event.target as Element);
        if (radioElement) {
          this.pdfFormElement.updateFormElement({ id: args.formElement.id, children: [{ id: radioElement.id }] });
        }
        this.pdfFormElement.showRadiobuttonRelativeFields(args.formElement);
        if (this.$data.isFormulaPresent) {
          this.formulaStringInstance.setValueForAllFormulaFields();
        }
      }
      this.updateFieldVisibilityCount(this.signerId);
    },

    editAccessForFieldsInFormula (args: any) {
      this.$data.selectedElementType = args.formElement.elementType;
      const selectedFormElement = args.formElement;
      if (this.$data.selectedElementType === 'textbox') {
        this.pdfFormElement.startEdit();
      } else if (this.$data.selectedElementType === 'dropdown') {
        const dropdownOptions = selectedFormElement.dropdownOptions;
        const dropdownHasValue = dropdownOptions !== null && dropdownOptions.length > 0 && ((dropdownOptions.length === 1 && dropdownOptions[0]) || dropdownOptions.length > 1);
        if (dropdownHasValue) {
          this.openDropDownPopup(args);
        }
      } else if (this.$data.selectedElementType === 'editabledate') {
        this.setDatePickerDetails(selectedFormElement);
      }
    },

    openDropDownPopup (args: any) {
      this.$data.showDropdown = false;
      this.dropdownObjInstance.hidePopup();
      this.pdfFormElement.startSelect();
      const dropdownPopUpBounds = UtilityMethods.getDropdownPopUpBounds(args.formElement);
      this.$data.dropdownPopUpY = dropdownPopUpBounds.dropdownPopUpY;
      this.$data.dropdownPopUpX = dropdownPopUpBounds.dropdownPopUpX;
      this.$data.dropdownWidth = dropdownPopUpBounds.dropdownWidth;
      this.$data.showDropdown = true;
      this.$data.currentDropdownOptions = [];
      if (args.formElement.dropdownOptions && args.formElement.dropdownOptions.length > 0) {
        this.$data.currentDropdownOptions = args.formElement.dropdownOptions;
      }
      setTimeout(() => {
        this.dropdownObjInstance.showPopup();
      }, 0);
    },

    textChange (args: any): void {
      this.validateFieldValueAsNumber(args.formElement.value);
      this.formulaStringInstance.setValueForAllFormulaFields(args.formElement.name);
    },

    setDatePickerDetails (formElement: any): void {
      if (formElement.value) {
        this.datePickerObjInstance.value = new Date(this.globalize.parseDate(formElement.value, { format: formElement.label }));
      } else {
        this.datePickerObjInstance.value = null;
      }
      this.getDatePickerBounds();
      this.datePickerObjInstance.dataBind();
      setTimeout(() => {
        this.datePickerObjInstance.show();
      }, 100);
    },

    getDatePickerBounds (): void {
      const selectedElement = this.pdfFormElement.selectedFormElement;
      const datePickerHeight = 257;
      const formElement = document.getElementById(selectedElement.id);
      const elementBounds: ClientRect = formElement.getBoundingClientRect();
      this.$data.datePickerPopUpY = elementBounds.top + elementBounds.height;
      this.$data.datePickerPopUpX = elementBounds.left;
      if (window.innerHeight < elementBounds.top + elementBounds.height + datePickerHeight) {
        this.$data.datePickerPopUpY = elementBounds.top - datePickerHeight;
      }
    },

    openPdfFormFieldDatePicker (args: PopupObjectArgs): void {
      args.popup.offsetX = this.$data.datePickerPopUpX;
      args.popup.offsetY = this.$data.datePickerPopUpY;
    },

    selectDate (args: any): void {
      if (args.event) {
        const formElement = this.pdfFormElement.selectedFormElement;
        const dateValue = args.value ? this.globalize.formatDate(args.value, { format: formElement.label }) : null;
        this.pdfFormElement.updateFormElement({ id: formElement.id, value: dateValue });
        this.formulaStringInstance.setValueForAllFormulaFields(formElement.name);
      }
    },

    editNewPage (evt: MouseEvent): void {
      const target: HTMLElement = evt.target as HTMLElement;
      if (target.id === 'messageEdit') {
        this.$mutation.updateMainData({ focusItem: 'message' });
      } else if (target.id === 'signersEdit') {
        this.$mutation.updateMainData({ focusItem: 'signer' });
      }
    },

    assigneeChange (args: any): void {
      const context = this as any;
      if (args.itemData !== null && args.itemData.fields === 0) {
        args.itemData.fields = this.$session.signerData.signerDetails.find((x: any) => x.id === args.itemData.id).fields;
      }
      this.$nuxt.$userInsight.track(MixPanelAction.ViewFieldsForSignerSelect, new UserInsight({ Page: UserInsightPage.PreviewPage, Action: UserInsightAction.ViewFieldsForSignerAction, Origin: UserInsightOrigin.PreviewDocument }));
      this.loadPdfForSigners(args.itemData === null ? 0 : args.itemData.id);
    },

    updateSignerData (args: any): void {
      window.sessionStorage.setItem('isNewPageModified', 'True');
      this.$mutation.updateMainData({ isPageModified: true });
      const id: string = args.event.target.id || args.event.target.name;
      if (id === 'msgTitlePreview') {
        this.$mutation.updateSignerMainData({ messageTitle: args.value });
      } else if (id === 'msgDescriptionPreview') {
        this.$mutation.updateSignerMainData({ messageDescription: args.value });
      }
    },

    mouseleave (args: any): void {
      if (args.target.id === 'msgTitlePreview') {
        if (!this.$session.signerData.messageTitle) {
          this.$mutation.updateSignerMainData({ messageTitle: args.target.defaultValue });
        } else {
          this.$mutation.updateSignerMainData({ messageTitle: this.$session.signerData.messageTitle });
        }
        this.$nuxt.$userInsight.track(MixPanelAction.PreviewDocumentTitleChange, new UserInsight({ Page: UserInsightPage.PreviewPage, Action: UserInsightAction.PreviewDocumentTitleChangeAction, Origin: UserInsightOrigin.PreviewDocument }));
      }
    },

    routeNavigation () {
      const embedData = this.$session.embedData;
      if (this.$data.isEmbedPage) {
        const locale = UtilityMethods.getLocale(this.$session, 'embedNewPage');
        if (this.$data.embedPageType === EmbedPageType.EmbedDocument) {
          return { path: '/embed/?documentId=' + embedData.documentId + embedData.embedId + ';' + embedData.organizationId + locale };
        } else if (this.$data.embedPageType === EmbedPageType.EmbedTemplate) {
          return { path: '/embed/?templateId=' + embedData.documentId + embedData.embedId + ';' + embedData.organizationId + locale };
        }
      } else {
        const mainData = this.$session.mainData;
        if (mainData.parentDocumentId && mainData.signbuilderType === 'signing') {
          if (mainData.isEditDocument && mainData.editDocumentId) {
            return { path: '/new?documentId=' + mainData.editDocumentId + '&isEditDocument=true' };
          }
          return { path: '/new?documentId=' + mainData.parentDocumentId };
        } else if (mainData.parentDocumentId && mainData.signbuilderType === 'createlink') {
          const baseFormUrl = 'new?bulk-link=true&documentId=';
          if (mainData.isEditBulklink && mainData.editBulklinkId) {
            return { path: baseFormUrl + mainData.editBulklinkId + '&isEditBulklink=true' };
          } else {
            return { path: '/new?bulk-link=true&documentId=' + mainData.parentDocumentId };
          }
        } else if (mainData.parentDocumentId && mainData.signbuilderType === 'createtemplate') {
          if (mainData.isEditCreatedTemplate && mainData.editTemplateDocumentId) {
            return { path: '/new?template=true&documentId=' + mainData.editTemplateDocumentId + '&isEditTemplate=true' };
          } else {
            return { path: '/new?template=true&documentId=' + mainData.parentDocumentId + '&isDraftTemplate=true' };
          }
        } else if (mainData.useTemplateDocumentId && mainData.signbuilderType === 'usetemplate') {
          return { path: '/new/?usetemplate=' + mainData.useTemplateDocumentId + '&isUseTemplate=true' };
        } else {
          return { path: '/new' };
        }
      }
    },

    setDefaultOption (args: any) {
      this.$data.showDropdown = false;
      this.dropdownObjInstance.hidePopup();
      this.pdfFormElement.setDropdownDefaultOptions(args.itemData.value);
      this.updateFieldVisibilityCount(this.signerId);
      if (this.$data.isFormulaPresent) {
        if (UtilityMethods.fieldUsedInFormula(this.pdfFormElement.selectedFormElement, this.pdfFormElement.pageFormElementsList)) {
          this.validateFieldValueAsNumber(args.itemData.value);
        }
        this.formulaStringInstance.setValueForAllFormulaFields();
      }
    },

    onDropdownCreate (args): void {
      const context = this as any;
      if (!this.dropDownTooltip) {
        this.dropDownTooltip = new Tooltip({
          content: context.$t('common.loadTextWithDots'),
          target: '.e-list-item',
          position: 'TopCenter',
          beforeRender: this.onBeforeRender
        });
        this.dropDownTooltip.appendTo('body');
      }
    },

    onBeforeRender (args: any): void {
      if (this.pdfFormElement.selectedFormElement && this.pdfFormElement.selectedFormElement.elementType === 'dropdown') {
        UtilityMethods.onBeforeRender(args, this.dropDownTooltip);
      } else {
        args.cancel = true;
      }
    },

    dropdownFieldFocusOut (): void {
      this.dropDownTooltip.close();
      this.$data.showDropdown = false;
      this.pdfFormElement.endSelect();
    },

    dropdownFocusOut (): void {
      this.$data.showDropdown = false;
      this.dropdownObjInstance.hidePopup();
    },

    getSignerIndex (signerDetail) {
      const signerDetails = this.$session.signerData.signerDetails;
      return UtilityMethods.getSignerFieldIndex(signerDetail.id, signerDetails);
    }, from preview ts

<template>
  <div id="pdfViewer_parent" tabindex="0" style="height: 100%; position: relative; float: left; cursor: move;">
    <ejs-pdfviewer
      id="pdfviewer"
      ref="pdfObj"
      :serviceUrl="serviceUrl"
      :documentLoad="pdfDocumentLoad"
      :zoomChange="pdfZoomChange"
      :pageChange="pdfPageChange"
      :tileRenderingSettings="tileRenderingSettings"
      :ajaxRequestSettings="ajaxRequestSettings"
      :ajaxRequestInitiate="ajaxRequestInitiate"
      :ajaxRequestSuccess="ajaxRequestSuccess"
      :ajaxRequestFailed="ajaxRequestFailed"
      :showNotificationDialog="false"
      :restrictZoomRequest="false"
    />
    <ejs-tooltip v-if="showZoomOption && isDesktopMode" ref="zoomTooltipObj" :beforeRender="onZoomTooltipOpen" position="RightCenter" target="span">
      <div class="bs-pdf-zoom-style">
        <span id="zoomIn" class="sf-icon-Zoomin" @click="zoomIn" ></span>
        <span id="zoomOut" class="sf-icon-Zoomout" @click="zoomOut" ></span>
        <span id="fullScreen" class="sf-icon-Fit" @click="fullScreen" ></span>
      </div>
    </ejs-tooltip>
    <PDFViewerFailedDialog ref="pdfViewerFailedDialogObj" :isFromDefaultPage="false" />
  </div>
</template>
<script lang="ts">
import { defineComponent, PropType } from 'vue';
import { TooltipComponent } from '@syncfusion/ej2-vue-popups';
import { PdfViewerComponent, Magnification, Navigation, PageChangeEventArgs, ZoomChangeEventArgs, PdfViewer } from '@syncfusion/ej2-vue-pdfviewer';
import { decode } from '@msgpack/msgpack';
import { UtilityMethods } from '../types/util';
import { PageType, ResponsiveMode } from '../types/interface';
import { PdfFormElements } from '../types/pdfFormElements';
import PDFViewerFailedDialog from '../components/pdfviewer-fail-dialog.vue';
import { UserInsight, UserInsightAction, UserInsightOrigin, UserInsightPage, MixPanelAction } from '../models/UserInsight';

export default defineComponent({
  name: 'PdfViewerRenderComponent',
  components: {
    'ejs-pdfviewer': PdfViewerComponent,
    PDFViewerFailedDialog,
    'ejs-tooltip': TooltipComponent
  },

  provide: {
    PdfViewer: [Magnification, Navigation]
  },
  props: {
    pageType: {
      type: String as PropType<PageType>,
      required: true
    },
    isPreviewPage: Boolean,
    isPreviewTemplatePage: Boolean,
    showZoomOption: Boolean,
    isSigningPage: Boolean,
    isLatestVersion: Boolean
  },

  emits: [
    'drop',
    'keydown',
    'selectionChange',
    'tabIndexChange',
    'dropdownFocusOut',
    'indexPositionChange',
    'showSignatureInstance',
    'formElementDragStart',
    'formElementDragEnd',
    'textChange',
    'collectionChange',
    'positionChange',
    'sizeChange',
    'formElementMouseOver',
    'formElementMouseLeave',
    'conditionalLogicSelectionChange',
    'editAccessForFieldsInFormula',
    'pdfDocumentLoad',
    'pdfZoomChange',
    'pdfPageChange',
    'editFormElementsOnEnter',
    'formElementInputChange',
    'fontSizeChangeOnResize'
  ],

  data () {
    // PdfViewer.Inject(Magnification, Navigation);
    let serviceUrl = '/api/pdfviewer';
    if (this.$session.embedData.isEmbedPage) {
      serviceUrl = '/api/embeddedRequest';
    } else if (this.$route.path.indexOf('configure-custom-field') > 0) {
      const embeddedBrandDetails = UtilityMethods.getCustomFieldBrandAndEmbedIds(this.$route.query.brandId.toString());
      if (embeddedBrandDetails.embedId) {
        this.$mutation.updateCustomFieldData({ embeddedCustomFieldId: embeddedBrandDetails.embedId });
        serviceUrl = '/api/embeddedCustomField';
      } else {
        serviceUrl = '/api/customField';
      }
    }
    const canDisplayAIIcon = UtilityMethods.canEnableAIFieldDetection(this);
    const PdfFormElement: PdfFormElements = new PdfFormElements(this.pageType, this.isPreviewPage, canDisplayAIIcon);
    return {
      isInit: false,
      pdfViewerFailedDialogInstance: null,
      PdfFormElement,
      pdfViewer: PdfViewerComponent,
      zoomFactor: 1.5,
      serviceUrl,
      tileRenderingSettings: { enableTileRendering: false },
      ajaxRequestSettings: { ajaxHeaders: [{ headerName: 'x-xsrf-token', headerValue: this.$main.xsrfToken }] },
      secretId: '',
      isDesktopMode: this.$session.responsiveLayout.responsiveMode === ResponsiveMode.DesktopMode
    };
  },

  mounted () {
    this.$data.pdfViewerFailedDialogInstance = this.$refs.pdfViewerFailedDialogObj;
    if (this.$refs.pdfObj) {
      this.$data.PdfFormElement.pdfInstance = this.$refs.pdfObj.ej2Instances;
      this.$data.PdfFormElement.drop = this.drop.bind(this);
      this.$data.PdfFormElement.selectionChange = this.selectionChange.bind(this);
      this.$data.PdfFormElement.tabIndexChange = this.tabIndexChange.bind(this);
      this.$data.PdfFormElement.indexPositionChange = this.indexPositionChange.bind(this);
      this.$data.PdfFormElement.dragStart = this.formElementDragStart.bind(this);
      this.$data.PdfFormElement.dragEnd = this.formElementDragEnd.bind(this);
      this.$data.PdfFormElement.dropdownFocusOut = this.dropdownFocusOut.bind(this);
      this.$data.PdfFormElement.collectionChange = this.collectionChange.bind(this);
      this.$data.PdfFormElement.positionChange = this.positionChange.bind(this);
      this.$data.PdfFormElement.sizeChange = this.sizeChange.bind(this);
      this.$data.PdfFormElement.textChange = this.textChange.bind(this);
      this.$data.PdfFormElement.mouseover = this.formElementMouseOver.bind(this);
      this.$data.PdfFormElement.mouseleave = this.formElementMouseLeave.bind(this);
      this.$data.PdfFormElement.conditionalLogicSelectionChange = this.conditionalLogicSelectionChange.bind(this);
      this.$data.PdfFormElement.showSignatureInstance = this.showSignatureInstance.bind(this);
      this.$data.PdfFormElement.keydown = this.keydown.bind(this);
      this.$data.PdfFormElement.editFormElementsOnEnter = this.editFormElementsOnEnter.bind(this);
      this.$data.PdfFormElement.formElementInputChange = this.formElementInputChange.bind(this);
      this.$data.PdfFormElement.editAccessForFieldsInFormula = this.editAccessForFieldsInFormula.bind(this);
      this.$data.PdfFormElement.fontSizeChangeOnResize = this.fontSizeChangeOnResize.bind(this);
    }
    window.onresize = this.windowResize.bind(this);
    this.pdfViewer = this.$refs.pdfObj as PdfViewerComponent;
    if (this.pdfViewer) {
      this.$data.pdfViewer.ej2Instances.scrollSettings = { delayPageRequestTimeOnScroll: 500 };
      this.$data.pdfViewer.ej2Instances.beforeRenderPdfPage = this.pageRenderInitiate.bind(this);
    }
  },

  methods: {
    drop (args: any): void {
      this.$emit('drop', args);
    },

    keydown (args: any): void {
      this.$emit('keydown', args);
    },

    selectionChange (args: any): void {
      this.$emit('selectionChange', args);
    },

    tabIndexChange (): void {
      this.$emit('tabIndexChange');
    },

    dropdownFocusOut (args: any): void {
      this.$emit('dropdownFocusOut', args);
    },

    indexPositionChange (args: any): void {
      this.$emit('indexPositionChange', args);
    },

    showSignatureInstance (): void {
      this.$emit('showSignatureInstance');
    },

    formElementDragStart (): void {
      this.$emit('formElementDragStart');
    },

    formElementDragEnd (args: any): void {
      this.$emit('formElementDragEnd', args);
    },

    textChange (args: any): void {
      this.$emit('textChange', args);
    },

    fontSizeChangeOnResize (args: any) {
      this.$emit('fontSizeChangeOnResize', args);
    },

    collectionChange (args: any): void {
      this.$emit('collectionChange', args);
    },

    positionChange (args: any): void {
      this.$emit('positionChange', args);
    },

    sizeChange (args: any): void {
      this.$emit('sizeChange', args);
    },

    formElementMouseOver (args: any): void {
      this.$emit('formElementMouseOver', args);
    },

    formElementMouseLeave (): void {
      this.$emit('formElementMouseLeave');
    },

    conditionalLogicSelectionChange (args: any): void {
      this.$emit('conditionalLogicSelectionChange', args);
    },

    editAccessForFieldsInFormula (args: any): void {
      this.$emit('editAccessForFieldsInFormula', args);
    },

    pdfDocumentLoad (args: any): void {
      this.isInit = true;
      this.$emit('pdfDocumentLoad', args);
    },

    ajaxRequestSuccess (args: any) {
      if (args.data && args.data.secretId) {
        this.$data.secretId = args.data.secretId;
        this.$mutation.updateMainData({ secretId: this.$data.secretId });
      }
    },

    pdfZoomChange (args: ZoomChangeEventArgs): void {
      if (this.isInit) {
        this.PdfFormElement.scaleFormContainer(args.zoomValue);
      }
      this.$emit('pdfZoomChange');
    },

    pdfPageChange (args: PageChangeEventArgs): void {
      this.$emit('pdfPageChange', args);
    },

    editFormElementsOnEnter (args: any): void {
      this.$emit('editFormElementsOnEnter', args);
    },

    formElementInputChange (args: any): void {
      this.$emit('formElementInputChange', args);
    },

    ajaxRequestInitiate (args: any): void {
      this.pdfViewer.ej2Instances.ajaxRequestSettings.ajaxHeaders[0].headerValue = this.$main.xsrfToken;
      this.pdfViewer.ej2Instances.httpResponseType = null;
      const embedData: any = this.$session.embedData;
      const mainData: any = this.$session.mainData;
      if (args.JsonData.action === 'RenderPdfPages' || args.JsonData.action === 'Load' || args.JsonData.action === 'VirtualLoad' || args.JsonData.action === 'RenderTaggedContent') {
        if (embedData.isEmbedPage) {
          args.JsonData.signerId = embedData.embedId;
          args.JsonData.documentIdData = embedData.documentId;
          args.JsonData.embedId = embedData.embedId;
          args.JsonData.organizationId = embedData.organizationId;
        } else {
          args.JsonData.signerId = mainData.currentUserId ? mainData.currentUserId : mainData.currentSignerId;
        }
        if (this.$session.mainData.signbuilderType === 'usetemplate') {
          args.JsonData.templateId = this.$session.mainData.useTemplateDocumentId;
        }
        if (mainData.isEditCreatedTemplate) {
          args.JsonData.templateId = mainData.editTemplateDocumentId;
        }
        if (this.isPreviewTemplatePage && this.$route.query.templateId) {
          args.JsonData.templateId = this.$route.query.templateId.toString();
        }
        if (this.$session.mainData.signbuilderType === 'bulksend') {
          args.JsonData.templateId = this.$session.bulkSendData.templateId;
        }
        if (this.$session.mainData.signbuilderType === 'createlink' || this.$session.mainData.isViewBulkLinkPage) {
          args.JsonData.isLinkForms = true;
          args.JsonData.linkId = mainData.editBulklinkId;
        }
        if (UtilityMethods.inEditMode(this) && !mainData.anySignerCompleted) {
          args.JsonData.editDocumentId = mainData.editDocumentId;
        }
      }
      if (args.JsonData.action === 'RenderPdfPages') {
        if (this.isLatestVersion) {
          args.JsonData.zoomFactor = this.$data.zoomFactor;
        }
        args.JsonData.secretId = this.$data.secretId;
        this.pdfViewer.ej2Instances.httpResponseType = 'arraybuffer';
        if (args.JsonData.zoomFactor === this.PdfFormElement.currentZoom) {
          // this.updateFieldDisplay(args.JsonData.pageNumber, 'none');
        }
      }
      if (args.JsonData.action === 'RenderTaggedContent') {
        args.JsonData.secretId = this.$data.secretId;
      }
      if (this.pageType === 'EDIT') {
        args.JsonData.isPrintSignDocument = true;
        this.pdfViewer.setJsonData(args.JsonData);
      }
    },

    pageRenderInitiate (args) {
      const buffer = args.JsonData;
      const obj = decode(buffer) as any;
      obj.image = 'data:image/png;base64,' + this.arrayBufferToBase64(obj.image);
      args.JsonData = obj;
      args.JsonData.transformationMatrix = {
        Elements: [1, 0, 0, 1, 0, 0],
        OffsetX: 0,
        OffsetY: 0,
        IsInvertible: true,
        IsIdentity: true
      };
      // this.updateFieldDisplay(args.JsonData.pageNumber, 'block');
      this.pdfViewer.ej2Instances.renderPdfPages(args.JsonData);
    },

    arrayBufferToBase64 (buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    },

    updateFieldDisplay (pageNumber: number, display: string) {
      // if (this.pdfFormElement.pageFormElementsList && this.pdfFormElement.pageFormElementsList.length) {
      //    let pageFormElement: PageFormElements = this.pdfFormElement.getPageFormElementsByIndex(pageNumber + 1);
      //    if (pageFormElement && pageFormElement.formElements) {
      //      let formElement: FormElement[] = pageFormElement.formElements.filter(x => x.visibility == true);
      //      if (formElement && formElement.length > 0) {
      //        for (var i = 0; i < pageFormElement.formElements.length; i++) {
      //          let domFormElement: HTMLElement = document.getElementById(pageFormElement.formElements[i].id);
      //          domFormElement.style.display = display;
      //          if (this.pageType === 'SIGN' && this.pdfFormElement.selectedFormElement && display === 'block' &&
      //              pageFormElement.formElements[i].id === this.pdfFormElement.selectedFormElement.id) {
      //            this.$emit('renderSelectionTooltip', { elementType: this.pdfFormElement.selectedFormElement.elementType, element: domFormElement });
      //          }
      //        }
      //      }
      //    }
      //  }
    },

    zoomIn (): void {
      this.$nuxt.$userInsight.track(MixPanelAction.ZoominClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.ZoominAction, Origin: UserInsightOrigin.PrepareDocument }));
      this.PdfFormElement.pdfInstance.magnification.zoomIn();
    },

    fullScreen (): void {
      this.$nuxt.$userInsight.track(MixPanelAction.FitScreenClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.FitScreenAction, Origin: UserInsightOrigin.PrepareDocument }));
      this.PdfFormElement.pdfInstance.magnification.fitToAuto();
    },

    zoomOut (): void {
      this.$nuxt.$userInsight.track(MixPanelAction.ZoomOutClick, new UserInsight({ Page: UserInsightPage.PreparePage, Action: UserInsightAction.ZoomOutAction, Origin: UserInsightOrigin.PrepareDocument }));
      this.PdfFormElement.pdfInstance.magnification.zoomOut();
    },

    ajaxRequestFailed (args: any): void {
      console.log(args.action);
      if (args.action !== "Unload") {
        this.pdfViewerFailedDialogInstance.show(this.isSigningPage ? this.PdfFormElement : '');
      }
    },

    onZoomTooltipOpen (args: any): void {
      UtilityMethods.showZoomOptionTooltip(args.event.target, this.$refs.zoomTooltipObj, this as any);
    },

    windowResize (): void {
      this.PdfFormElement.scaleFormContainer(this.PdfFormElement.pdfInstance.zoomPercentage);
    }
  }

});
</script>
frompdfviewer render component vue

   <div class="bs-signer-view-content" :style="{ width: '100%', border: 'none' }">
      <PDFViewerRenderComponent
        ref="pdfRenderObj"
        pageType="VIEW"
        :showZoomOption="true"
        :style="{ width: showThumbContainer ? 'calc(100% - 250px)' : '100%' }"
        :isLatestVersion="isLatestVersion"
        @pdfDocumentLoad="pdfDocumentLoad"
        @pdfPageChange="pdfPageChange"
        @selectionChange="selectionChange"
        @formElementMouseOver="formElementMouseOver"
        @formElementMouseLeave="formElementMouseLeave"
      />
      <ThumbnailComponent id="bs-thumbnail-view" ref="thumbnailObj" @showThumb="showThumb" />
    </div>
    <HyperlinkWarning ref="hyperLinkWarningObj" pageType="VIEW" />

    <ejs-dialog
      id="revokeDialog"
      :closeOnEscape="closeOnEscape"
      cssClass="bs-dialog-style bs-responsive-mobile"
      :width="dialogWidth"
      :showCloseIcon="true"
      :isModal="signModal"
      :close="dialogClose"
      :animationSettings="animationSettings"
      :visible="revokeDialogVisible"
      :target="target"
      :buttons="revokeButtons"
    >
      <div style="padding: 0 0 16px 0px;">
        <div style="float:left; line-height: 30px;">
          <img src="../static/info-alert.svg" :alt="trulliAltText" width="24" height="24"/>
        </div>
        <div style="line-height: 34px; font-size: 20px; letter-spacing: 0.32px; margin-left: 40px;font-weight: 500;">
          Revoke document
        </div>
      </div>
      <div class="bs-decline-content" style="width: 100%; min-height: 138px">
        <span style="height: 20px; padding: 5px">{{ $t('signPage.revokeWarningMessgae') }}</span>
        <ejs-textbox v-model="revokeMessage" :multiline="true" :placeholder="revokeReasonPlaceholder" :value="revokeMessage" />
        <span class="bs-revoke-validation-text" :style="{ display: isInvalidRevokedMessage ? 'block' : 'none' }">{{ $t('signPage.revokeReasonRequired') }}</span>
        <span class="bs-note-style" style="margin-top: 15px;">{{ $t('signPage.revokeDialogNotes') }}</span>
      </div>
    </ejs-dialog>
    <MoreInfoComponent ref="moreInfoObj" />
    <ejs-dialog
      id="deleteDialog"
      :closeOnEscape="closeOnEscape"
      :width="dialogWidth"
      :showCloseIcon="true"
      :close="dialogClose"
      cssClass="bs-responsive-mobile"
      :isModal="signModal"
      :animationSettings="animationSettings"
      :visible="deleteDialogVisible"
      :target="target"
      header="Delete document"
      :buttons="deleteButtons"
    >
      <div class="bs-delete-content">
        <span>{{ $t('viewPage.deleteWarningMessgae') }}</span>
      </div>
    </ejs-dialog>
    <custom-modal
      ref="this.deleteConfirmDialog"
      :show.sync="showDeleteConfirmationDialog"
      :styles="{ width: '450px' }"
      :showButtons="true"
      :primaryButton="$t('viewPage.yesDelete')"
      :secondaryButton="$t('viewPage.cancel')"
      cssClass="confirm-delete-dialog custom_del_col"
      @primaryClick="permanentDeleteYesClick"
      @secondaryClick="showDeleteConfirmationDialog = false"
    >
      <div class="flex-items">
        <div class="warning-gradient-bg" ></div>
        <div class="text-content-style">
          {{ $t('viewPage.confirmPermanentDelete') }}
        </div>
      </div>
    </custom-modal>
    <ejs-dialog
      id="reloadDocumentDialog"
      :closeOnEscape="reloadDocumentEscape"
      :width="reloadDocumentDialogWidth"
      :showCloseIcon="reloadDocumentCloseIcon"
      :isModal="signModal"
      :animationSettings="animationSettings"
      :target="target"
      :visible="reloadDocumentDialogVisible"
      :buttons="reloadDocumentDialogButtons"
      cssClass="bs-responsive-mobile"
    >
      <div style="width: 100%; padding:24px;">
        <div style="float:left; margin-right:16px;">
          <img src="../static/warning-1.svg" width="24" height="24"/>
        </div>
        <span class="bs-reloadDocument-text-style" style="margin-top:2px; display:block; margin-left: 42px;">{{ $t('signPage.reloadDocumentDialogText') }}</span>
      </div>
    </ejs-dialog>
    <ejs-dialog
      id="signerIdExpiredDialog"
      width="400px"
      :showCloseIcon="false"
      :isModal="signModal"
      :animationSettings="animationSettings"
      :target="target"
      :visible="singerIdExpiredVisible"
      :closeOnEscape="false"
    >
      <div style="width:100%; padding:0px 8px; height: auto;">
        <div style="float:left; margin-right:16px;">
          <img src="../static/warning.svg" width="40" height="40"/>
        </div>
        <div style="float:left; height:40px; width: calc(100% - 56px); display:table">
          <span style="font-size:14px; font-weight:400;display:table-cell;vertical-align:middle">{{ $t('signPage.signLinkExpiredMessage', { pageName: 'view' }) }}</span>
        </div>
        <div v-if="isClickOnce && !isResendClicked" class="bs-link-add-info-container" style="float:left; height:30px;">
          <span class="bs-link-add-info">{{ $t('signPage.dialogResendLinkText') }}</span>
          <span class="bs-link-add-info bs-hyperlink-resend-style" style="font-weight:500" @click="resendViewLink">{{ $t('signPage.resendLinkText') }}</span>
        </div>
        <div v-if="!isClickOnce" class="bs-link-add-info-container" style="float:left; height:30px;">
          <span class="bs-link-add-info bs-hyperlink-resend-style" @click="generateNewLink" style="font-weight:500">{{$t('signPage.generateLinkText')}}</span>
        </div>
      </div>
    </ejs-dialog>
    <CustomToast ref="successCustomToast" @onCustomToastClose="onToastClose" />
    <CustomToast ref="failureCustomToast" />
    <CustomToast ref="attachmentToast" />
    <div id="viewProgress" class="sb-content-overlay" :style="{ display: showProgress ? 'block' : 'none' }">
      <img src="../static/loader.svg" :alt="trulliAltText" width="48" height="48" style="position: absolute;top: calc(50% - 24px);left: calc(50% - 24px);"/>
    </div>
    <div id="prepareProgress" class="v-sb-content-overlay">
      <SignEnterTemplate />
    </div>
    <div class="access-content-overlay" :style="{ display: accessDenied ? 'block' : 'none' }">
      <AccessDocumentDeniedTemplate :accessDeniedInfo="accessDeniedInfo" :accessDeniedHeader="accessDeniedHeader" />
    </div>
    <div v-show="documentEditInitiated" class="access-content-overlay">
      <SigningRestrictedPage />
    </div>
    <identity-verification ref="identityVerification" :authenticator="getAuthenticator('IdVerification')" />
    <invalid-previous-session ref="invalidPreviousSession" />
    <verification-in-progress ref="verificationInProgress" />
    <id-verification-session-expired ref="idVerificationSessionExpired" />
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';
import { PdfViewerComponent, PageChangeEventArgs, PdfViewer } from '@syncfusion/ej2-vue-pdfviewer';
import { DialogComponent, TooltipComponent } from '@syncfusion/ej2-vue-popups';
import { TextBoxComponent } from '@syncfusion/ej2-vue-inputs';
import { DropDownButtonComponent, ItemModel } from '@syncfusion/ej2-vue-splitbuttons';
import { saveAs } from 'file-saver';
import { isMobile } from 'mobile-device-detect';
import { useHead } from 'nuxt/app';
import ThumbnailComponent from '../components/thumbnail-component.vue';
import MoreInfoComponent from '../components/moreInfo-component.vue';
import PDFViewerRenderComponent from '../components/pdfviewer-render-component.vue';
import SignEnterTemplate from '../components/sign-enter-template.vue';
import AccessDocumentDeniedTemplate from '../components/access-denied-document-template.vue';
import { FormElement, PageFormElements, DocumentProperties, AttachmentDetails, SignerType } from '../types/interface';
import { PdfFormElements } from '../types/pdfFormElements';
import { UtilityMethods } from '../types/util';
import CustomToast from '../components/custom-toast.vue';
import { CustomEventHandler } from '../types/interaction';
import HyperlinkWarning from '../components/hyperlink-warning.vue';
import IdentityVerification from '../components/signer-authentication/identity-verification.vue';
import { SignerAuthenticator, IdVerificationAuthenticator } from '../models/signer-authentication/signerAuthenticator';
import InvalidPreviousSession from '../components/signer-authentication/invalid-previous-session.vue';
import VerificationInProgress from '../components/signer-authentication/verification-in-progress.vue';
import IdVerificationSessionExpired from '../components/signer-authentication/id-verification-session-expired.vue';
import CustomModal from '../components/custom-modal.vue';
import SigningRestrictedPage from '../components/templates/signing-restricted-page.vue';
import BoldsignBySyncfusion from '@/static/boldsign-by-syncfusion.svg';
import BoldSignBoldLogo from '@/static/BoldSign_boldLogo.svg';
import {
  UserInsight,
  UserInsightAction,
  UserInsightOrigin,
  UserInsightPage,
  MixPanelAction
} from '../models/UserInsight';

export default defineComponent({
  name: 'ViewPage',
  components: {
    'ejs-dialog': DialogComponent,
    'ejs-textbox': TextBoxComponent,
    'ejs-dropdownbutton': DropDownButtonComponent,
    'ejs-tooltip': TooltipComponent,
    ThumbnailComponent,
    MoreInfoComponent,
    SignEnterTemplate,
    AccessDocumentDeniedTemplate,
    CustomToast,
    PDFViewerRenderComponent,
    HyperlinkWarning,
    IdentityVerification,
    InvalidPreviousSession,
    VerificationInProgress,
    IdVerificationSessionExpired,
    CustomModal,
    SigningRestrictedPage
  },

  data () {
    const isInit = false;
    const thumbnailInstance = null;
    const pdfRenderInstance: any = null;
    const moreInfoInstance: any = null;
    const hyperLinkWaningInstance: any = null;
    let jsonDocumentContent: any;
    const isPageRedirect: boolean = true;
    let sessionAuthInterval: NodeJS.Timeout;
    const extendSessionCount = 1200;
    let trackingSession: NodeJS.Timeout;
    let currentSigner: any;
    let documentId: string = '';
    let signerId: string = '';
    let dialogWidth = '425px'; let toastWidth = '400px';
    let reloadDocumentDialogWidth = '520px';
    let resendDialogWidth = '732px';
    let moreActionContent = this.$t('preparePage.moreActionContent');
    let renderingMode: string = 'bs-normal-mode';
    let isDesktopMode: boolean = true;
    let brandUrl: string = BoldSignBoldLogo;
    if (isMobile) {
      moreActionContent = '';
      isDesktopMode = false;
      renderingMode = 'bs-mobile-mode';
      brandUrl = '';
      if (screen.width <= 500) {
        dialogWidth = reloadDocumentDialogWidth = resendDialogWidth = '100%';
        toastWidth = '100%';
      }
    }
    documentId = this.$route.query.documentId;
    if (documentId.includes(';')) {
      const id1 = documentId.split(';');
      documentId = id1[0];
    }
    const tempSignerId: string = documentId.substring(documentId.length - 7, documentId.length);
    if (tempSignerId.startsWith('s_')) {
      documentId = documentId.substring(0, documentId.length - 7);
      signerId = tempSignerId;
      this.$nuxt.$mutation.updateMainData({ currentSignerId: signerId });
    }
    this.isLoggedUser();
    return {
      pdfFormElement: PdfFormElements,
      isInit,
      thumbnailInstance,
      pdfRenderInstance,
      moreInfoInstance,
      hyperLinkWaningInstance,
      isPageRedirect,
      store: this.$nuxt.$session,
      jsonDocumentContent,
      documentId,
      signerId,
      trulliAltText: this.$t('common.trulliAltText'),
      renderingMode,
      moreActions: [],
      sessionAuthIntervalOn: false,
      isLatestVersion: false,
      moreOptionIcon: 'sf-icon-Setting',
      closeOnEscape: true,
      dialogWidth,
      signModal: true,
      animationSettings: { effect: 'None' },
      target: document.body,
      isModal: true,
      showDeleteConfirmationDialog: false,
      revokeButtons: [
        { buttonModel: { content: this.$t('common.no'), cssClass: 'e-flat' }, click: this.revokeNoClick.bind(this) },
        { buttonModel: { content: this.$t('common.revokeYes'), cssClass: 'e-flat', isPrimary: true }, click: this.revokeYesClick.bind(this) }
      ],
      deleteButtons: [
        { buttonModel: { content: this.$t('common.no'), cssClass: 'e-flat' }, click: this.deleteNoClick.bind(this) },
        { buttonModel: { content: this.$t('common.yes'), cssClass: 'e-flat', isPrimary: true }, click: this.deleteYesClick.bind(this) }
      ],
      reloadDocumentDialogButtons: [
        { buttonModel: { content: this.$t('signPage.reloadDocument'), cssClass: 'sf-icon-Rotate bs-reload-button', isPrimary: true }, click: this.reloadDocumentClick.bind(this) }
      ],
      revokeMessage: '',
      position: { X: 'Right', Y: 'Bottom' },
      revokeDialogVisible: false,
      accessDenied: false,
      isInvalidRevokedMessage: '',
      defaultBrandUrl: '',
      deleteDialogVisible: false,
      reloadDocumentDialogWidth,
      reloadDocumentCloseIcon: false,
      reloadDocumentEscape: false,
      reloadDocumentDialogVisible: false,
      accessDeniedInfo: this.$t('accessDeniedPage.accessInfo'),
      accessDeniedHeader: this.$t('accessDeniedPage.accessdenied'),
      downloadContent: this.$t('common.downloadDocument'),
      homePage: this.$t('uploadSettings.bsIconDialogHomeBtn'),
      messageTitle: this.$t('common.loadTextWithDots'),
      documentStatus: '',
      pageTitleName: '',
      showThumbContainer: true,
      moreActionContent,
      closeActionTooltip: this.$t('common.closeAction'),
      revokeReasonPlaceholder: this.$t('signPage.revokeReasonPlaceholder'),
      isDesktopMode,
      showProgress: false,
      brandUrl,
      isLogInUser: false,
      singerIdExpiredVisible: false,
      isClickOnce: false,
      isResendClicked: false,
      enableWaterMark: false,
      resendDialogWidth,
      boldSignWithSyncLogo: BoldsignBySyncfusion,
      idVerificationSessionInterval: 1200,
      isIdVerificationTrackingReq: false,
      isExtendAPITriggered: false,
      documentEditInitiated: false,
      sessionAuthInterval,
      extendSessionCount,
      trackingSession,
      currentSigner
    };
  },

  watch: {
    pageTitleName (newTitle) {
      useHead({ title: newTitle === this.$t('metaInfo.viewDocumentMetaInfo') ? newTitle : `${newTitle} - ${this.$t('metaInfo.viewDocumentMetaInfo')}` });
    }
  },

  beforeUnmount () {
    this.$eventBus.off('getDocumentAndSignatureDetails', this.getDocumentAndSignatureDetails);
    this.$eventBus.off('showDocumentLockedAccessDeniedPage', this.showDocumentLockedAccessDeniedPage);
    document.body.removeEventListener('click', this.documentClickListener);
    document.body.removeEventListener('keydown', this.documentKeyEventListener);
    document.body.removeEventListener('mousemove', this.documentKeyEventListener);
    window.removeEventListener('touchstart', this.documentKeyEventListener);
  },

  mounted (): void {
    debugger
    this.$data.pageTitleName = this.$t('metaInfo.viewDocumentMetaInfo');
    this.$eventBus.on('getDocumentAndSignatureDetails', this.getDocumentAndSignatureDetails);
    this.$eventBus.on('showDocumentLockedAccessDeniedPage', this.showDocumentLockedAccessDeniedPage);
    document.body.addEventListener('click', this.documentClickListener);
    document.body.addEventListener('keydown', this.documentKeyEventListener);
    document.body.addEventListener('mousemove', this.documentKeyEventListener);
    window.addEventListener('touchstart', this.documentKeyEventListener);
    this.$data.thumbnailInstance = this.$refs.thumbnailObj;
    this.$data.pdfRenderInstance = this.$refs.pdfRenderObj;
    this.$data.moreInfoInstance = this.$refs.moreInfoObj;
    this.$data.pdfFormElement = this.$data.pdfRenderInstance.PdfFormElement;
    this.$data.hyperLinkWaningInstance = this.$refs.hyperLinkWarningObj;
  },

  methods: {
    documentClickListener (args: any): void {
      // Below listener used to extend the identity verification session
      this.documentKeyEventListener();
      if (!(args.target as any).closest('.e-toast-container')) {
        const $this = (this as any);
        const failureCustomToastObj = $this.$refs.failureCustomToast;
        failureCustomToastObj.hide();
      }
    },
    pdfDocumentLoad (args: any): void {
      const documentProperties: DocumentProperties[] = this.jsonDocumentContent.documentDetails.documentProperties;
      this.$data.pdfFormElement.initDroppableElement(this.$data.documentId, UtilityMethods.getPageCount(documentProperties), args.pageData, this.$data.enableDocumentID, this.$data.enableWaterMark);
      UtilityMethods.updateZoomProperties(this.$data.isLatestVersion, this.$data.pdfFormElement.pdfInstance);
      this.isInit = true;
      this.loadDocumentFields();
    },
    documentKeyEventListener (): void {
    // For ID verification, extend the session only for last 5 min interval.
      if (this.$data.sessionAuthIntervalOn && this.extendSessionCount < 300 && this.extendSessionCount > 0 && !this.$data.isExtendAPITriggered) {
        this.extendSessionAPICall();
      }
    },

    isLoggedUser (): void {
      this.$nuxt.$api.signPage.isLoggedUser({}).then((data) => {
        if (data && data.userId) {
          this.$mutation.updateMainData({ currentUserId: data.userId });
        }
        if (data && data.authenticateState === true) {
          this.$data.isLogInUser = true;
        }
        this.getDocumentAndSignatureDetails();
      }).catch((e: any) => {
        this.isLoggedUser();
      });
    },

    extendSessionAPICall () {
      this.$data.isExtendAPITriggered = true;
      this.$nuxt.$api.signerAuthentication.extendSession(this.$route.query.documentId as string)
        .then(() => {
          this.extendSessionCount = this.$data.idVerificationSessionInterval;
          this.$data.isExtendAPITriggered = false;
        }).catch(() => {
          this.$data.isExtendAPITriggered = false;
        });
    },

    extendSessionInterval (): void {
      this.$data.sessionAuthIntervalOn = true;
      this.sessionAuthInterval = setInterval((): any => {
        this.extendSessionCount--;

        // If the session is expired, show the session expired dialog.
        if (this.extendSessionCount === 0) {
          this.turnoffSessionAuthInterval(true);
        }
      }, 1000);
    },

    turnoffSessionAuthInterval (canShowdialog: boolean): void {
      if (this.sessionAuthInterval) {
        this.$data.sessionAuthIntervalOn = false;
        clearInterval(this.sessionAuthInterval);
        clearInterval(this.trackingSession);
        this.sessionAuthInterval = null;
        if (canShowdialog) {
          const sessionExpired = this.$refs.idVerificationSessionExpired as any;
          sessionExpired.brandLogoUrl = this.$data.defaultBrandUrl ? this.$data.defaultBrandUrl : this.$data.boldSignWithSyncLogo;
          sessionExpired.showDialog();
        }
      }
    },

    checkIsValidSession (): void {
      this.trackingSession = setInterval((): any => {
        this.$nuxt.this.$api.signerAuthentication
          .isValidSession(this.$route.query.documentId as string)
          .then((data: any) => {
            if (data) { return; }
            clearInterval(this.trackingSession);
            clearInterval(this.sessionAuthInterval);
            this.trackingSession = null;
            const invalidSessionDlg = this.$refs.invalidPreviousSession as any;
            invalidSessionDlg.brandLogoUrl = this.$data.defaultBrandUrl ? this.$data.defaultBrandUrl : this.$data.boldSignWithSyncLogo;
            invalidSessionDlg.showDialog();
          });
      }, 10000);
    },

    showDocumentLockedAccessDeniedPage (isNameError: boolean): void {
      this.$data.accessDenied = true;
      this.$data.accessDeniedInfo = isNameError
        ? this.$t('viewPage.idVerificationNameFailedInfo')
        : this.$t('viewPage.idVerificationFailedInfo');
      this.$data.accessDeniedHeader = this.$t('accessDeniedPage.authFailedDocumentLockedHeader');
    },

    dialogClose (args: any): void {
      if (args.element) {
        switch (args.element.id) {
          case 'deleteDialog':
            this.$data.deleteDialogVisible = false;
            break;
          case 'revokeDialog':
            this.$data.revokeDialogVisible = false;
            break;
          case 'permanentDeleteDialog':
            this.$data.showDeleteConfirmationDialog = false;
            break;
        }
      }
    },

    closeButtonClick (args: any): void {
      if (((args.keyCode && args.keyCode === 13) || !args.keyCode) && !this.$data.signerId) {
        this.$router.back();
      } else {
        window.location.href = window.location.origin + '/dashboard';
      }
    },

    showThumb (value: boolean): void {
      this.$data.showThumbContainer = value;
      setTimeout((): void => {
        window.dispatchEvent(new Event('resize'));
        this.$data.pdfFormElement.scaleFormContainer(this.pdfFormElement.pdfInstance.zoomPercentage);
      }, 0);
    },

    generateNewLink (): void {
      this.$data.isClickOnce = true;
      this.$data.showProgress = true;
      this.sendViewLink();
    },

    resendViewLink (): void {
      this.$data.isResendClicked = true;
      this.$data.showProgress = true;
      this.sendViewLink();
    },

    sendViewLink (): void {
      const context = (this as any);
      const toastObj = this.getFailureCustomToast();
      this.$nuxt.$api.signPage.resendSignOrViewLink({
        query: {
          documentId: this.$route.query.documentId.toString(),
          signerId: this.$data.signerId
        }
      }).then((data) => {
        this.$data.showProgress = false;
        if (data.isResendLink) {
          toastObj.show(context.$t('signPage.resendLinkSuccessMessage', { pageName: 'viewing' }), 'bs_toast_success', 'sf-icon-Completed');
        } else {
          this.$data.isResendClicked = false;
          toastObj.show(context.$t('signPage.resendLinkError', { pageName: 'viewing' }), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        }
      }).catch((e: any) => {
        this.$data.showProgress = false;
        this.$data.isResendClicked = false;
        toastObj.show(context.$t('signPage.resendLinkError', { pageName: 'viewing' }), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
      });
    },

    revokeNoClick (): void {
      this.$data.revokeDialogVisible = false;
    },

    reloadDocumentClick (): void {
      this.$data.reloadDocumentDialogVisible = false;
      window.location.reload();
    },

    revokeYesClick (): void {
      const context = (this as any);
      if (!this.$data.revokeMessage.trim()) {
        this.$data.isInvalidRevokedMessage = true;
        return;
      }
      this.$userInsight.track(MixPanelAction.RevokeConfirmDocumentClick, new UserInsight({ Page: UserInsightPage.ViewPage, Action: UserInsightAction.RevokeConfirmDocumentAction, Origin: UserInsightOrigin.ViewDocument }), this.currentSigner);
      const successToastObj = this.getSuccessCustomToast();
      const failureToastObj = this.getFailureCustomToast();
      this.$data.revokeDialogVisible = false;
      this.$data.showProgress = true;
      this.$nuxt.$api.common.revokeDocument(this.$data.revokeMessage, this.$route.query.documentId.toString(), this.jsonDocumentContent.azureETag).then((data) => {
        if (data.isPreconditionFailed) {
          this.$data.reloadDocumentDialogVisible = true;
        } else if (data.isRevokeDocument) {
          successToastObj.show(this.$t('signPage.revokeSuccessMessage') + this.jsonDocumentContent.documentDetails.messageTitle, 'bs_toast_success', 'sf-icon-Remove');
        } else {
          failureToastObj.show(this.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        }
        this.$data.showProgress = false;
      }).catch((e: any) => {
        if (e.response !== undefined && e.response.status === 403) {
          this.$data.reloadDocumentDialogVisible = true;
        } else if (e.response !== undefined && e.response.status === 422) {
          failureToastObj.show(this.$t('common.modelValidationErrorInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        } else {
          failureToastObj.show(this.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
          this.isPageRedirect = this.$data.showProgress = false;
        }
      });
    },

    deleteNoClick (): void {
      this.$data.deleteDialogVisible = false;
    },

    deleteYesClick (): void {
      const context = (this as any);
      this.$userInsight.track(MixPanelAction.DeleteConfirmDocumentclick, new UserInsight({ Page: UserInsightPage.ViewPage, Action: UserInsightAction.DeleteConfirmDocumentAction, Origin: UserInsightOrigin.ViewDocument }), this.currentSigner);
      const successToastObj = this.getSuccessCustomToast();
      const failureToastObj = this.getFailureCustomToast();
      this.$data.deleteDialogVisible = false;
      this.$data.showProgress = true;
      this.$nuxt.$api.viewPage.deleteDocument(this.$route.query.documentId.toString()).then((data) => {
        const successMsg: string = this.$t('viewPage.deleteAddInfo1') + this.jsonDocumentContent.documentDetails.messageTitle;
        successToastObj.show(successMsg, 'bs_toast_success', 'sf-icon-Completed');
      }).catch((e: any) => {
        failureToastObj.show(this.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        this.isPageRedirect = this.$data.showProgress = false;
      });
    },

    permanentDeleteYesClick (): void {
      const context = (this as any);
      this.$userInsight.track(MixPanelAction.PermanentDeleteConfirmDocumentclick, new UserInsight({ Page: UserInsightPage.ViewPage, Action: UserInsightAction.PermanentDeleteConfirmDocumentAction, Origin: UserInsightOrigin.ViewDocument }), this.currentSigner);
      const successToastObj = this.getSuccessCustomToast();
      const failureToastObj = this.getFailureCustomToast();
      this.$data.showDeleteConfirmationDialog = false;
      this.$data.showProgress = true;
      this.$nuxt.$api.viewPage.deleteDocumentForever(this.jsonDocumentContent.id).then((data) => {
        const successMsg: string = this.$t('viewPage.deleteAddInfo1') + this.jsonDocumentContent.documentDetails.messageTitle;
        successToastObj.show(successMsg, 'bs_toast_success', 'sf-icon-Completed');
      }).catch((e: any) => {
        failureToastObj.show(this.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        this.isPageRedirect = this.$data.showProgress = false;
      });
    },

    moreOptionSelect (args: any): void {
      let userAction;
      let mixpanelAction;
      let isDownloadAction = false;
      if (args.item.id === 'ddl_revoke_option') {
        userAction = UserInsightAction.RevokeDocumentAction;
        mixpanelAction = MixPanelAction.RevokeDocumentClick;
        this.$data.revokeDialogVisible = true;
      } else if (args.item.id === 'ddl_delete_option') {
        userAction = UserInsightAction.DeleteDocumentAction;
        mixpanelAction = MixPanelAction.DeleteDocumentClick;
        this.$data.deleteDialogVisible = true;
      } else if (args.item.id === 'ddl_permanent_delete_option') {
        userAction = UserInsightAction.PermanentDeleteDocumentAction;
        mixpanelAction = MixPanelAction.PermanentDeleteDocumentClick;
        this.$data.showDeleteConfirmationDialog = true;
      } else if (args.item.id === 'ddl_moreInfo_option') {
        userAction = UserInsightAction.MoreInfoAction;
        mixpanelAction = MixPanelAction.MoreInfoClick;
        this.moreInfoInstance.show();
      } else if (args.item.id === 'ddl_download_attachment_option') {
        userAction = UserInsightAction.DownloadAttachmentAction;
        mixpanelAction = MixPanelAction.DownloadAttachmentClick;
        this.downloadAttachment();
      } else {
        isDownloadAction = true;
        this.downloadDocument(args.item.id !== 'ddl_download_option');
      }
      if (!isDownloadAction) {
        this.$userInsight.track(mixpanelAction, new UserInsight({ Page: UserInsightPage.ViewPage, Action: userAction, Origin: UserInsightOrigin.ViewDocument }), this.currentSigner);
      }
    },

    downloadAttachment (): void {
      const context = (this as any);
      const attachmentToast = this.$refs.attachmentToast;
      attachmentToast.hide();
      attachmentToast.show(this.$t('signPage.downloadAttachment'), 'bs_toast_success', 'sf-icon-Download', null, 0, true);
      this.$nuxt.$api.common.downloadAttachment(this.$route.query.documentId.toString()).then((data) => {
        const file = new Blob([data], { type: 'application/zip' });
        const fileName: string = this.$data.messageTitle + '.zip';
        saveAs(file, fileName);
        attachmentToast.hide();
      }).catch((error) => {
        attachmentToast.hide();
        if (error.response && error.response.status === 401) {
          attachmentToast.show(this.$t('common.sessionExpired'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
          window.location.href = '/Account/Login/?returnUrl=' + window.location.href;
        } else {
          attachmentToast.show(this.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
        }
      });
    },

    getSuccessCustomToast (): any {
      const context = (this as any);
      const successToastObj = this.$refs.successCustomToast;
      successToastObj.hide();
      return successToastObj;
    },

    getFailureCustomToast (): any {
      const context = (this as any);
      const failureToastObj = this.$refs.failureCustomToast;
      failureToastObj.hide();
      return failureToastObj;
    },

    downloadDocument (isAuditTrail: boolean): void {
      let userAction;
      let mixpanelAction;
      if (isAuditTrail) {
        userAction = UserInsightAction.DownloadAuditLogAction;
        mixpanelAction = MixPanelAction.DownloadAuditLogClick;
      } else {
        userAction = UserInsightAction.DownloadDocumentAction;
        mixpanelAction = MixPanelAction.DownloadDocumentClick;
      }
      this.$userInsight.track(mixpanelAction, new UserInsight({ Page: UserInsightPage.ViewPage, Action: userAction, Origin: UserInsightOrigin.ViewDocument }), this.currentSigner);
      const context = (this as any);
      const successToastObj = this.getSuccessCustomToast();
      const failureToastObj = this.getFailureCustomToast();
      successToastObj.show(context.$t('signPage.downloadInfo'), 'bs_toast_success', 'sf-icon-Download', null, 0);
      this.$nuxt.$api.common.downloadDocument(this.$data.documentId, this.$data.signerId, !isAuditTrail).then((res) => {
        context.isPageRedirect = false;
        const file = new Blob([res.data], { type: res.data.type });
        saveAs(file, UtilityMethods.getFileNameFromContentHeaders(res.headers));
        successToastObj.hide();
      }).catch(() => {
        this.isPageRedirect = false;
        successToastObj.hide();
        failureToastObj.show(this.$t('common.failureInfo'), 'bs_toast_failure', 'sf-icon-Circle_Close', null, 0, true);
      });
    },

    pdfPageChange (args: PageChangeEventArgs): void {
      this.$data.pdfFormElement.selectedPageIndex = args.currentPageNumber;
      this.$data.thumbnailInstance.onPageChangeEvent(args, this.jsonDocumentContent.documentDetails.documentProperties);
    },

    loadDocumentFields (): void {
      if (this.jsonDocumentContent && this.isInit) {
        const context: any = this as any;
        const moreActions: ItemModel[] = [];
        if (this.jsonDocumentContent.allowDownloadAuditTrail) {
          moreActions.push({ text: this.$t('common.viewAuditLog'), id: 'ddl_viewlog_option', iconCss: 'bs-download2' });
        }
        if (this.jsonDocumentContent.allowDownloadDocument) {
          moreActions.push({ text: this.$t('common.downloadDocument'), id: 'ddl_download_option', iconCss: 'bs-download1' });
        }
        if (this.jsonDocumentContent.allowDownloadAttachment) {
          if (moreActions.length > 0) {
            moreActions.push({ separator: true });
          }
          moreActions.push({ text: this.$t('common.downloadAttachment'), id: 'ddl_download_attachment_option', iconCss: 'sf-icon-Attachment' });
        }
        if (this.jsonDocumentContent.allowRevoke) {
          if (moreActions.length > 0) {
            moreActions.push({ separator: true });
          }
          moreActions.push({ text: this.$t('common.revokeYes'), id: 'ddl_revoke_option', iconCss: 'bs-revoke-document' });
        }
        if (this.jsonDocumentContent.allowDelete) {
          if (moreActions.length > 0) {
            moreActions.push({ separator: true });
          }
          moreActions.push({ text: this.$t('common.delete'), id: 'ddl_delete_option', iconCss: 'bs_doc_delete' });
        }
        if (this.jsonDocumentContent.allowPermanentDelete) {
          if (moreActions.length > 0) {
            moreActions.push({ separator: true });
          }
          moreActions.push({ text: this.$t('common.deleteForever'), id: 'ddl_permanent_delete_option', iconCss: 'bs_doc_delete' });
        }
        moreActions.push({ text: this.$t('common.moreInfo'), id: 'ddl_moreInfo_option', iconCss: 'sf-icon-Information' });
        this.$data.moreActions = moreActions;
        const event: CustomEventHandler = new CustomEventHandler(document.getElementById('pdfViewer_parent'), this.pdfFormElement);
        const documentElementDetails: any = this.jsonDocumentContent.documentElementDetails;
        const pageFormElements: PageFormElements[] = documentElementDetails.pageFormElements;
        if (pageFormElements) {
          for (let i: number = 0; i < pageFormElements.length; i++) {
            const formElements: FormElement[] = pageFormElements[i].formElements;
            if (formElements) {
              for (let j: number = 0; j < formElements.length; j++) {
                const formElement: any = formElements[j];
                if (formElement.elementType === 'label' || formElement.elementType === 'hyperlink' || formElement.elementType === 'formula') {
                  formElement.fill1 = formElement.fill2 = 'transparent';
                  formElement.stroke1 = formElement.stroke2 = 'transparent';
                }
              }
            }
          }
        }
        this.pdfFormElement.load(JSON.stringify({
          allowEdit: true,
          pageFormElementsList: documentElementDetails.pageFormElements,
          pageHeight: documentElementDetails.pageHeight,
          pageMargin: documentElementDetails.pageMargin,
          currentZoom: documentElementDetails.scaleFactor
        }));
        const pdfInstance: PdfViewer = this.pdfFormElement.pdfInstance;
        if (pdfInstance && pdfInstance.zoomPercentage < 100) {
          this.pdfFormElement.scaleFormContainer(pdfInstance.zoomPercentage);
        }
        document.getElementById('prepareProgress').style.display = 'none';
        this.thumbnailInstance.loadThumbnail(this.pdfFormElement, this.jsonDocumentContent.documentDetails.documentProperties, 'view');
        this.createViewAuditLog();
      }
    },

    selectionChange (args: any): void {
      if (args.formElement && args.formElement.elementType === 'hyperlink') {
        this.hyperLinkWaningInstance.show(args.formElement.value);
      }
    },

    getAuthenticator (type: 'IdVerification' | 'KBA' | 'SMS'): SignerAuthenticator {
      switch (type) {
        case 'IdVerification':
          return new SignerAuthenticator(this, new IdVerificationAuthenticator());
        default:
          return null;
      }
    },

    setReturnPage (returnPage: string, idVerificationNameError: boolean): void {
      let authDialog = null;
      if (returnPage === 'DocumentLocked') {
        this.showDocumentLockedAccessDeniedPage(idVerificationNameError);
      } else if (returnPage === 'InvalidSession') {
        authDialog = this.$refs.invalidPreviousSession;
        authDialog.brandLogoUrl = this.$data.defaultBrandUrl ? this.$data.defaultBrandUrl : this.$data.boldSignWithSyncLogo;
        authDialog.showDialog();
      } else if (returnPage === 'Verification') {
        authDialog = this.$refs.identityVerification;
        authDialog.brandLogoUrl = this.$data.defaultBrandUrl ? this.$data.defaultBrandUrl : this.$data.boldSignWithSyncLogo;
        authDialog.showDialog();
      }
    },

    getDocumentAndSignatureDetails (): void {
      const documentId = this.$route.query.documentId.toString();
      if (!documentId) {
        this.$data.accessDenied = true;
      } else {
        this.$nuxt.$api.viewPage.getDocumentDetails(documentId).then((data) => {
          if (data === 'authenticationFailed') {
            this.$data.accessDenied = true;
            this.$data.accessDeniedInfo = (this as any).this.$t('signPage.authFailedInfo');
          } else if (data.returnPage) {
            this.$data.defaultBrandUrl = data.brandLogoImage;
            this.setReturnPage(data.returnPage, data.idVerificationNameError);
          } else if (data && data.preventDocumentViewing) {
            if (data.inEditingMode) {
              this.$data.documentEditInitiated = true;
            } else {
              this.$data.accessDenied = true;
              this.$data.accessDeniedInfo = (this as any).this.$t('viewPage.canViewDocumentInfo');
              if (data.isRevoked) {
                this.$data.accessDeniedInfo = (this as any).this.$t('signPage.documentRevokeInfo');
              }
            }
          } else if (data.isLinkExpired) {
            this.$data.singerIdExpiredVisible = true;
          } else {
            const viewDocumentContent = this.jsonDocumentContent = data.viewDocumentContent;
            this.$data.isLatestVersion = UtilityMethods.isLatestVersionedDocument(this.jsonDocumentContent.documentDetails.documentVersion);
            this.currentSigner = viewDocumentContent.currentSigner;
            if (viewDocumentContent.enableToast) {
              const toastObj = this.getFailureCustomToast();
              let headerText = '';
              if (this.currentSigner) {
                if (this.currentSigner.signerName) {
                  headerText = this.currentSigner.signerName;
                } else {
                  headerText = this.currentSigner.signerType === 2 ? this.$t('viewPage.alreadyReviewed') : this.$t('viewPage.alreadySigned');
                }
              }
              if (viewDocumentContent.documentStatus === 'Declined' && (!viewDocumentContent.declinerName || viewDocumentContent.declinerName === 'You')) {
                headerText = this.$t('viewPage.alreadyDecline');
              } else if (viewDocumentContent.documentStatus === 'Revoked' && viewDocumentContent.declinerName) {
                headerText = this.$t('viewPage.alreadyRevoked', { signerName: viewDocumentContent.declinerName });
              } else if (viewDocumentContent.documentStatus === 'Declined' && viewDocumentContent.declinerName) {
                headerText = this.$t('viewPage.alreadyDeclineByOthers', { signerName: viewDocumentContent.declinerName });
              } else if (viewDocumentContent.documentStatus === 'Expired') {
                headerText = this.$t('viewPage.documentExpired', { signerName: viewDocumentContent.declinerName });
              }
              toastObj.show(headerText, 'bs_toast_success', 'sf-icon-Information', null, 0, true);
            }
            this.$data.enableDocumentID = this.jsonDocumentContent.enableDocumentID;
            this.$data.enableWaterMark = this.jsonDocumentContent.enableWaterMark;
            this.$data.messageTitle = this.$data.pageTitleName = this.jsonDocumentContent.documentDetails.messageTitle;
            const brandImageUrl = this.jsonDocumentContent.brandLogoImage;
            if (brandImageUrl) {
              this.$data.defaultBrandUrl = brandImageUrl;
            } else {
              this.$data.defaultBrandUrl = this.$data.brandUrl;
            }
            const documentStatus: string = this.jsonDocumentContent.documentDetails.status;
            this.$data.documentStatus = documentStatus === 'InProgress' ? this.$t('viewPage.inProgressDocStatus') : documentStatus;
            if (!this.$data.signerId && this.currentSigner) {
              this.$data.signerId = this.currentSigner.signerId;
            }
            // this.$userInsight.identifyAndCapturePosthog(this.currentSigner, this.$data.isLogInUser);
            if (this.jsonDocumentContent.allowSigning && this.jsonDocumentContent.isAuthorizedSigner) {
              this.$data.authenticationVisible = true;
              document.getElementById('prepareProgress').style.display = 'none';
            } else {
              this.$data.isIdVerificationTrackingReq = data.isTrackingRequired;
              this.extendSessionCount = this.$data.idVerificationSessionInterval = data.idVerificationSessionInterval - 10;
from view vue
