  public class CustomRateLimitMiddleware : ClientRateLimitProcessor
    {
        private const string BurstLimitHeaderLimit = "X-Burst-MethodName-Limit";
        private const string BurstLimitHeaderRemaining = "X-Burst-MethodName-Remaining";
        private const string BurstLimitHeaderReset = "X-Burst-MethodName-Reset";
        private const string RateLimitHeaderLimit = "X-Rate-Limit-Limit";
        private const string RateLimitHeaderRemaining = "X-Rate-Limit-Remaining";
        private const string RateLimitHeaderReset = "X-Rate-Limit-Reset";
        private readonly RequestDelegate next;
        private readonly IRateLimitConfiguration config;
        private readonly ClientRateLimitOptions options;
        private readonly IRateLimitCounterStore counterStore;
        private readonly ICounterKeyBuilder counterKeyBuilder;
        private readonly ImmutableOrderedDictionary<string, string> responseHeaders = new();

        /// <summary>
        /// Initializes a new instance of the <see cref="CustomRateLimitMiddleware"/> class.
        /// </summary>
        /// <param name="next">Request Delegate.</param>
        /// <param name="config">The Rate Limit Configuration.</param>
        /// <param name="options">The Client RateLimit Options.</param>
        /// <param name="counterStore">The Rate Limit Counter Store.</param>
        /// <param name="clientPolicyStore">The client policy store.</param>
        /// <param name="processingStrategy">The processing strategy.</param>
        public CustomRateLimitMiddleware(
            RequestDelegate next,
            IRateLimitConfiguration config,
            IOptions<ClientRateLimitOptions> options,
            IRateLimitCounterStore counterStore,
            IClientPolicyStore clientPolicyStore,
            IProcessingStrategy processingStrategy)
            : base(options.Value, clientPolicyStore, processingStrategy)
        {
            this.next = next;
            this.config = config;
            this.options = options.Value;
            this.counterStore = counterStore;
            this.counterKeyBuilder = new ClientCounterKeyBuilder(options.Value);
        }

        /// <summary>
        /// Invokes the middleware.
        /// </summary>
        /// <param name="context">The context.</param>
        /// <returns>A <see cref="Task"/> representing the result of the asynchronous operation.</returns>
        public async Task Invoke(HttpContext context)
        {
            try
            {
                this.options.DisableRateLimitHeaders = true;
                var identity = await this.ResolveIdentityAsync(context).ConfigureAwait(false);
                await this.ApplyRulesAsync(context, identity, true).ConfigureAwait(false);

                // Apply shared hourly rules
                var hourlyId = identity.ClientId.Split('_');
                await this.ApplyRulesAsync(
                        context,
                        new ClientRequestIdentity
                        {
                            ClientId = hourlyId[0],
                            ClientIp = identity.ClientIp,
                            Path = "*",
                            HttpVerb = "*",
                        },
                        false).ConfigureAwait(false);

                foreach (var header in this.responseHeaders.GetItems())
                {
                    context.Response.Headers[header.Key] = header.Value;
                }

                await this.next(context).ConfigureAwait(false);
            }
            catch (RateLimitReachedException)
            {
                context.Response.StatusCode = StatusCodes.Status429TooManyRequests;
                await context.Response.WriteAsync("Rate limit exceeded").ConfigureAwait(false);
            }
            catch (Exception)
            {
                context.Response.StatusCode = StatusCodes.Status500InternalServerError;
                await context.Response.WriteAsync("An error occurred while processing your request").ConfigureAwait(false);
            }
        }

        private async Task ApplyRulesAsync(HttpContext context, ClientRequestIdentity identity, bool isBurstLimit)
        {
            var rules = await this.GetMatchingRulesAsync(identity, context.RequestAborted).ConfigureAwait(false);
            if (rules.Any())
            {
                foreach (var rule in rules)
                {
                    await this.ApplyRateLimit(context, identity, rule, isBurstLimit).ConfigureAwait(false);
                }
            }
        }

        private async Task ApplyRateLimit(HttpContext context, ClientRequestIdentity identity, RateLimitRule rule, bool isBurstLimit)
        {
            if (!isBurstLimit)
            {
                await this.ProcessRequestAsync(identity, rule, context.RequestAborted).ConfigureAwait(false);
            }

            var counterId = this.BuildCounterKey(identity, rule);
            var counter = await this.counterStore.GetAsync(counterId, context.RequestAborted).ConfigureAwait(false);
            if (counter.HasValue && counter.Value.Count > rule.Limit)
            {
                throw new RateLimitReachedException(rule);
            }

            var headers = this.GetRateLimitHeaders(counter, rule, context.RequestAborted);

            var methodEndpoint = RateLimitHelper.GetMethodTypeFromAttribute(context);
            var headerLimit = isBurstLimit ? BurstLimitHeaderLimit.Replace("MethodName", methodEndpoint) : RateLimitHeaderLimit;
            var headerRemaining = isBurstLimit ? BurstLimitHeaderRemaining.Replace("MethodName", methodEndpoint) : RateLimitHeaderRemaining;
            var headerReset = isBurstLimit ? BurstLimitHeaderReset.Replace("MethodName", methodEndpoint) : RateLimitHeaderReset;

            this.AddHeader(headerLimit, headers.Limit);
            this.AddHeader(headerRemaining, headers.Remaining);
            this.AddHeader(headerReset, headers.Reset);
        }

        private async Task<ClientRequestIdentity> ResolveIdentityAsync(HttpContext context)
        {
            string clientId = "anon";
            if (this.config.ClientResolvers?.Any() == true)
            {
                var clientIdTasks = this.config.ClientResolvers.Select(resolver => resolver.ResolveClientAsync(context));
                var clientIds = await Task.WhenAll(clientIdTasks).ConfigureAwait(false);
                clientId = clientIds.FirstOrDefault(id => !string.IsNullOrEmpty(id)) ?? "anon";
            }

            var methodEndpoint = RateLimitHelper.GetMethodTypeFromAttribute(context);

            return new ClientRequestIdentity
            {
                ClientId = clientId,
                ClientIp = "anon",
                Path = methodEndpoint,
                HttpVerb = context.Request.Method.ToLowerInvariant(),
            };
        }

        private string BuildCounterKey(ClientRequestIdentity requestIdentity, RateLimitRule rule)
        {
            var key = this.counterKeyBuilder.Build(requestIdentity, rule);

            if (this.options.EnableEndpointRateLimiting && this.config.EndpointCounterKeyBuilder != null)
            {
                key += this.config.EndpointCounterKeyBuilder.Build(requestIdentity, rule);
            }

#pragma warning disable SCS0006 // Weak hashing function
            using var sha1 = SHA1.Create();
#pragma warning restore SCS0006 // Weak hashing function
            var hashBytes = sha1.ComputeHash(Encoding.UTF8.GetBytes(key));
            return Convert.ToBase64String(hashBytes);
        }

        private void AddHeader(string key, string value)
        {
            this.responseHeaders.Add(key, value);
        }

  [Authorize]
    public class IdentityResolveContributor : IClientResolveContributor
    {
        /// <inheritdoc/>
        [Authorize]
        public Task<string> ResolveClientAsync(HttpContext httpContext)
        {
            var userDataService = new UserDataService(httpContext);
            var subId = userDataService.SubscriptionId;
            if (userDataService.OAuthAppOrgId.IsValidGuid() && userDataService.OAuthAppSubId.IsValidGuid())
            {
                Console.WriteLine(
                    $"OAuth-Billing: Set OAuth App creator subId - {userDataService.OAuthAppSubId} for the user" +
                    $" with subId - {userDataService.SubscriptionId} in order to charge creator.");
                subId = userDataService.OAuthAppSubId;
            }

            if (userDataService.ClientId.IsSalesForceClientId())
            {
                httpContext.AddEnvironment(false);
            }

            var clientId = GetClientId(userDataService.Environment == ApplicationEnvironment.Test, subId);

            // Determine the method-specific key for 1-minute limits
            var methodType = RateLimitHelper.GetMethodTypeFromAttribute(httpContext);

            var methodSpecificKey = $"{clientId}_{methodType}";

            return Task.FromResult(methodSpecificKey);
        }

      public static class RateLimitHelper
    {
        /// <summary>
        /// Get the burst rate limit method type.
        /// </summary>
        /// <param name="httpContext">The httpcontext.</param>
        /// <returns>A string.</returns>
        public static string GetMethodTypeFromAttribute(HttpContext httpContext)
        {
            var endpoint = httpContext.GetEndpoint();
            var attribute = endpoint?.Metadata.GetMetadata<RateLimitMethodAttribute>();
            return attribute?.MethodType.ToString().ToLowerInvariant();
        }
public class ImmutableOrderedDictionary<TKey, TValue>
{
    private ImmutableList<KeyValuePair<TKey, TValue>> items = ImmutableList<KeyValuePair<TKey, TValue>>.Empty;

    /// <summary>
    /// Adds a key-value pair to the dictionary.
    /// </summary>
    /// <param name="key">The key of the element to add.</param>
    /// <param name="value">The value of the element to add.</param>
    public void Add(TKey key, TValue value)
    {
        ImmutableInterlocked.Update(ref this.items, (list) => list.Add(new KeyValuePair<TKey, TValue>(key, value)));
    }
// <copyright file="RateLimitAttribute.cs" company="Syncfusion Inc">
// Copyright (c) Syncfusion Inc. All rights reserved.
// </copyright>

namespace BoldSign.ApiManagement.Service
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net.Http;
    using System.Security.Claims;
    using System.Threading;
    using System.Threading.Tasks;
    using System.Web.Http.Controllers;
    using System.Web.Http.Filters;
    using AspNetCoreRateLimit;
    using AutoMapper;
    using BoldSign.ApiManagement.Helper;
    using BoldSign.ApiManagement.Models;
    using BoldSign.ApiManagement.ViewModel;
    using BoldSign.Base;
    using BoldSign.Base.Database;
    using BoldSign.Base.Extensions;
    using BoldSign.Base.Models;
    using BoldSign.Base.Models.RateLimit;
    using BoldSign.Base.Serializer;
    using BoldSign.Payment.Interfaces.DataServices;
    using Microsoft.AspNetCore.Http;
    using Microsoft.AspNetCore.Mvc.Filters;
    using Microsoft.EntityFrameworkCore;
    using Microsoft.Extensions.Options;
    using ActionFilterAttribute = Microsoft.AspNetCore.Mvc.Filters.ActionFilterAttribute;

    /// <summary>
    /// RateLimitAttribute.
    /// </summary>
    public class RateLimitAttribute : IAsyncActionFilter, IRateLimitAttribute
    {
        private const string OneMinutePeriod = "1m";
        private readonly ClientRateLimitOptions options;
        private readonly IClientPolicyStore clientPolicyStore;
        private readonly DataBaseContext dataBaseContext;
        private readonly IMapper mapper;
        private readonly IRateLimitingService rateLimitingService;

        /// <summary>
        /// Initializes a new instance of the <see cref="RateLimitAttribute"/> class.
        /// </summary>
        /// <param name="optionsAccessor">optionsAccessor.</param>
        /// <param name="clientPolicyStore">clientPolicyStore.</param>
        /// <param name="dataBaseContext">dataBaseContext.</param>
        /// <param name="mapper">mapper.</param>
        /// <param name="rateLimitingService">rateLimitingService.</param>
        public RateLimitAttribute(IOptions<ClientRateLimitOptions> optionsAccessor, IClientPolicyStore clientPolicyStore, DataBaseContext dataBaseContext, IMapper mapper, IRateLimitingService rateLimitingService)
        {
            this.options = optionsAccessor.Value;
            this.clientPolicyStore = clientPolicyStore;
            this.dataBaseContext = dataBaseContext;
            this.mapper = mapper;
            this.rateLimitingService = rateLimitingService;
        }

        /// <inheritdoc/>
        public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
        {
            var httpContext = context.HttpContext;
            HandleEnvironmentClaim(context);
            var userDataService = new UserDataService(httpContext);
            var mode = userDataService.Environment == ApplicationEnvironment.Test ? Mode.Test : Mode.Live;
            var endpoint = RateLimitHelper.GetMethodTypeFromAttribute(httpContext);
            var cacheKey = GetCacheKey(userDataService, mode);
            var key = cacheKey + "_" + endpoint;
            var cacheExists = await this.ExistRateLimitCacheAsync(key).ConfigureAwait(false);

            if (cacheExists)
            {
                var limit = await this.clientPolicyStore.GetAsync($"{this.options.ClientPolicyPrefix}_{key}").ConfigureAwait(false);
                await this.clientPolicyStore.RemoveAsync($"{this.options.ClientPolicyPrefix}_{key}").ConfigureAwait(false);
                cacheExists = false;
                if (limit?.Rules != null)
                {
                    var oneMinuteRules = limit.Rules.Where(x => x.Period == OneMinutePeriod).ToList();

                    if (!oneMinuteRules.Any())
                    {
                        await this.clientPolicyStore.RemoveAsync($"{this.options.ClientPolicyPrefix}_{key}").ConfigureAwait(false);
                        cacheExists = false;
                    }
                }
            }

            if (!cacheExists)
            {
                List<RateLimitRules> rules = await this.FetchRulesAsync(userDataService.SubscriptionId, mode).ConfigureAwait(false);
                if (rules != null && rules.Any())
                {
                    var rule = rules.FirstOrDefault();
                    var ratelimitRules = new List<RateLimitRules>
                    {
                        new RateLimitRules
                        {
                            Endpoint = "*",
                            Id = rule.Id,
                            IsWhiteList = rule.IsWhiteList,
                            Limit = await this.rateLimitingService.GetBurstRateLimitAsync(userDataService.SubscriptionId.ToGuid(), mode, BurstRateLimitMethod.Read).ConfigureAwait(false),
                            Mode = rule.Mode,
                            Period = "1m",
                            SubscriptionId = rule.SubscriptionId,
                            BurstMethod = BurstRateLimitMethod.Read,
                        },
                        new RateLimitRules
                        {
                            Endpoint = "*",
                            Id = rule.Id,
                            IsWhiteList = rule.IsWhiteList,
                            Limit = await this.rateLimitingService.GetBurstRateLimitAsync(userDataService.SubscriptionId.ToGuid(), mode, BurstRateLimitMethod.Write).ConfigureAwait(false),
                            Mode = rule.Mode,
                            Period = "1m",
                            SubscriptionId = rule.SubscriptionId,
                            BurstMethod = BurstRateLimitMethod.Write,
                        },

                        new RateLimitRules
                        {
                            Endpoint = "*",
                            Id = rule.Id,
                            IsWhiteList = rule.IsWhiteList,
                            Limit = await this.rateLimitingService.GetBurstRateLimitAsync(userDataService.SubscriptionId.ToGuid(), mode, BurstRateLimitMethod.Create).ConfigureAwait(false),
                            Mode = rule.Mode,
                            Period = "1m",
                            SubscriptionId = rule.SubscriptionId,
                            BurstMethod = BurstRateLimitMethod.Create,
                        },

                        new RateLimitRules
                        {
                            Endpoint = "*",
                            Id = rule.Id,
                            IsWhiteList = rule.IsWhiteList,
                            Limit = await this.rateLimitingService.GetBurstRateLimitAsync(userDataService.SubscriptionId.ToGuid(), mode, BurstRateLimitMethod.Delete).ConfigureAwait(false),
                            Mode = rule.Mode,
                            Period = "1m",
                            SubscriptionId = rule.SubscriptionId,
                            BurstMethod = BurstRateLimitMethod.Delete,
                        },

                        new RateLimitRules
                        {
                            Endpoint = "*",
                            Id = rule.Id,
                            IsWhiteList = rule.IsWhiteList,
                            Limit = await this.rateLimitingService.GetHourlyRateLimitAsync(userDataService.SubscriptionId.ToGuid(), mode).ConfigureAwait(false),
                            Mode = rule.Mode,
                            Period = "1h",
                            SubscriptionId = rule.SubscriptionId,
                        },
                    };

                    await this.ProcessRulesAsync(ratelimitRules, cacheKey).ConfigureAwait(false);
                }
                else
                {
                    List<RateLimitRule> defaultRules = this.GetDefaultRulesForCurrentEnvironment(userDataService);
                    await this.UpdateRateLimitRules(cacheKey, defaultRules).ConfigureAwait(false);
                }
            }

            await next().ConfigureAwait(false);
        }

        private static void HandleEnvironmentClaim(ActionExecutingContext context)
        {
            var sendForSignFromTemplate =
                context.ActionArguments.SingleOrDefault(p => p.Value is SendForSignFromTemplate);
            var sendForSign =
                context.ActionArguments.SingleOrDefault(p => p.Value is SendForSign);
            var userDataService = new UserDataService(context.HttpContext);

            if (userDataService.ClientId.IsSalesForceClientId())
            {
                context.HttpContext.AddEnvironment(false);
            }

            if (sendForSignFromTemplate.Value is SendForSignFromTemplate { IsSandbox: not null } sendForSignFromTemplateRequest)
            {
                context.HttpContext.AddEnvironment(sendForSignFromTemplateRequest.IsSandbox.Value);
            }
            else if (sendForSign.Value is SendForSign { IsSandbox: not null } sendForSignRequest)
            {
                context.HttpContext.AddEnvironment(sendForSignRequest.IsSandbox.Value);
            }
        }

        private static string GetCacheKey(UserDataService userDataService, Mode mode)
        {
            var subscriptionId = userDataService.SubscriptionId;

            if (userDataService.OAuthAppOrgId.IsValidGuid() && userDataService.OAuthAppSubId.IsValidGuid())
            {
                Console.WriteLine(
                    $"OAuth-Billing: Set OAuth App creator subId - {userDataService.OAuthAppSubId} for the user" +
                    $" with subId - {userDataService.SubscriptionId} in order to charge creator.");
                subscriptionId = userDataService.OAuthAppSubId;
            }

            return $"{mode.ToString()}{subscriptionId}";
        }

        private async Task<List<RateLimitRules>> FetchRulesAsync(string subscriptionId, Mode mode)
        {
            return await this.dataBaseContext.RateLimitRules
                .Where(x => x.SubscriptionId == subscriptionId && x.Mode == mode)
                .ToListAsync().ConfigureAwait(false);
        }

        private List<RateLimitRule> GetDefaultRulesForCurrentEnvironment(UserDataService userDataService)
        {
            DefaultRateLimitRules defaultRules = GetDefaultRulesFromEnv();
            return userDataService.Environment == ApplicationEnvironment.Test ?
                defaultRules.SandboxRateLimit : defaultRules.ProductionRateLimit;
        }

        /// <summary>
        /// Gets the default rules from enviornment variable.
        /// </summary>
        /// <returns>A DefaultRateLimitRules.</returns>
        private static DefaultRateLimitRules GetDefaultRulesFromEnv()
        {
            return BinarySerializer.FromJson<DefaultRateLimitRules>(BoldSignBase.EnvironmentVariables.DefaultRateLimitRule);
        }

        /// <summary>
        /// RemoveClientWhiteList.
        /// </summary>
        /// <param name="id">id.</param>
        private void RemoveClientWhiteList(string id)
        {
            this.options.ClientWhitelist?.Remove(id);
        }

        private async Task UpdateRateLimitRules(string id, List<RateLimitRule> rateLimitRules)
        {
            this.RemoveClientWhiteList(id);
            await this.SetRateLimtCacheAsync(id, rateLimitRules).ConfigureAwait(false);
        }

        /// <summary>
        /// SetRateLimtCacheAsync.
        /// </summary>
        /// <param name="id">id.</param>
        /// <param name="rateLimitRules">rateLimitRules.</param>
        /// <returns>A Task.</returns>
        private async Task SetRateLimtCacheAsync(string id, List<RateLimitRule> rateLimitRules)
        {
            await this.clientPolicyStore.SetAsync($"{this.options.ClientPolicyPrefix}_{id}", new ClientRateLimitPolicy { ClientId = id, Rules = rateLimitRules }).ConfigureAwait(false);
        }

        /// <summary>
        /// ExistRateLimitCacheAsync.
        /// </summary>
        /// <param name="id">id.</param>
        /// <returns>A Task.</returns>
        private async Task<bool> ExistRateLimitCacheAsync(string id)
        {
            return await this.clientPolicyStore.ExistsAsync($"{this.options.ClientPolicyPrefix}_{id}").ConfigureAwait(false);
        }

        private async Task ProcessRulesAsync(List<RateLimitRules> rules, string cacheKey)
        {
            this.options.DisableRateLimitHeaders = true;

            var cacheKeySuffixes = new Dictionary<BurstRateLimitMethod, string>
            {
                { BurstRateLimitMethod.Read, "_read" },
                { BurstRateLimitMethod.Write, "_write" },
                { BurstRateLimitMethod.Create, "_create" },
                { BurstRateLimitMethod.Delete, "_delete" },
            };

            foreach (var rule in rules)
            {
                if (rule.IsWhiteList)
                {
                    this.AddToWhitelist(cacheKey);
                    continue;
                }

                var rateLimitRule = this.mapper.Map<RateLimitRule>(rule);
                var result = new List<RateLimitRule> { rateLimitRule };

                var suffix = rule.BurstMethod.HasValue && cacheKeySuffixes.TryGetValue((BurstRateLimitMethod)rule.BurstMethod, out var specificSuffix)
                                ? specificSuffix
                                : string.Empty;

                await this.UpdateRateLimitRules(cacheKey + suffix, result).ConfigureAwait(false);
            }
        }

        private void AddToWhitelist(string cacheKey)
        {
            this.options.ClientWhitelist ??= new List<string>();
            if (!this.options.ClientWhitelist.Contains(cacheKey))
            {
                this.options.ClientWhitelist.Add(cacheKey);
            }
        }
    }
}
