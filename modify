 [HttpDelete]
    [Authorize(Policy = TemplateAuthorizationOption.CanDeleteTemplate)]
    public async Task<ActionResult> DeleteTemplates([Guid(ErrorMessage = ValidationMessages.ValidDocumentId)][Required(ErrorMessage = ValidationMessages.Required)]string templateId)
    {
      
      if (string.IsNullOrEmpty(templateId))
      {
        return this.BadRequest("Failure");
      }

      foreach(var templateId1 in templateId){

      string baseUrl = this.requestDetailsService.HostedDomain;

      dynamic[] procParams = new dynamic[] { templateId };

      // isAccessTid is set to false. since, we need to delete both the shared and original template types.
      var accessRightsList = await this.templateService.GetTemplatesByDocumentId(this.userDataService, templateId, false).ConfigureAwait(false);
      if (accessRightsList.Count > 0)
      {
        var clearContainerTask = this.documentService.ClearContainers(templateId, this.userDataService.OrganizationId);
        await this.templateService.DeleteTemplatesByDocumentIdAsync(this.userDataService.OrganizationId, templateId).ConfigureAwait(false);
        await clearContainerTask.ConfigureAwait(false);
        await this.documentService.NotifyDeletedTemplateUsers(accessRightsList, new Uri(baseUrl), this.hubContext, this.teamManagement).ConfigureAwait(false);
        _ = this.templateService.LogDeleteUserActivityAsync(accessRightsList, this.orgActivityService).ConfigureAwait(false);
        return this.Content("Success");
      }

      return this.BadRequest("Failure");
    }
    }
