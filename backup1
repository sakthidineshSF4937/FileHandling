    public async Task<UploadResponse> UploadAsync(bool embeddedSend, UploadRequest request)
    {
      this.logger.LogInformation($"queue-upload: Received request to upload document {request?.DocumentId}");

      var documents = await this.GetDocumentUploadDetailsListAsync(request).ConfigureAwait(false);

      string documentVersion = "v1";
      ITextTag sendForSign = null;
      if (request.PayloadType != DocumentQueueBase.SendTemplate && request.PayloadType != DocumentQueueBase.MergeAndSend)
      {
        sendForSign = request.PayloadType == DocumentQueueBase.Template
          ? JsonConvert.DeserializeObject<CreateTemplateRequest>(request.SendForSign)
          : JsonConvert.DeserializeObject<SendForSign>(request.SendForSign) as ITextTag;
      }
      else if (request.PayloadType == DocumentQueueBase.MergeAndSend)
      {
        sendForSign = JsonConvert.DeserializeObject<MergeAndSendForSign>(request.SendForSign);
      }

      var orgId = this.userDataService?.OrganizationId;

      string businessProfileDateFormat = null;
      string businessProfileTimeFormat = null;

      if (!string.IsNullOrEmpty(orgId))
      {
        var businessProfile = await this.queryCacheProvider.BusinessProfile
          .GetBusinessProfileSettingForTemplateSendAsync(orgId.ToGuid());

        businessProfileDateFormat = businessProfile?.DateFieldDateFormat;
        businessProfileTimeFormat = businessProfile?.DateFieldTimeFormat;
        var canEnableQualityRendering = await this.queryCacheProvider.Organization
          .GetEnableQualityRenderingAsync(orgId.ToGuid());
        if (canEnableQualityRendering)
        {
          documentVersion = "v2";
          if (request.PayloadType == DocumentQueueBase.SendTemplate)
          {
            var sendTemplateDetails = JsonConvert.DeserializeObject<SendForSignFromTemplate>(request.SendForSign);
            DocumentDetails documentDetails = await this.documentManipulatorService.GetDocumentDetailsForTemplate(sendTemplateDetails.DocumentId);
            if (documentDetails != null)
            {
              documentVersion = documentDetails.DocumentVersion;
            }
          }
        }
      }

      if (request.PayloadType != DocumentQueueBase.SendTemplate && sendForSign?.UseTextTags == true)
      {
        TextTagMapper.MapTextTagsToFields(sendForSign, documents, this.documentManipulatorService, businessProfileDateFormat, businessProfileTimeFormat);
      }

      var files = request.Files.ToList();

      var pageCount = new List<int>();
      var documentIds = new List<string>();
      var currentUploadIndex = 0;
      var parentDocumentId = request.DocumentId;
      var isTaggedPdf = new List<bool>();

      if (documents.Count == 0)
      {
        var mainContainer = await this.cloudStorage.GetContainer(parentDocumentId, orgId).ConfigureAwait(false);
        var thumbnailContainer = await this.cloudStorage
          .GetContainer($"{parentDocumentId}-{DbConstants.Thumbnails}", orgId).ConfigureAwait(false);

        await mainContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
        await thumbnailContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
      }

      void ResponseInterceptor(string message)
      {
        if (message.Contains(Constants.PageCount, StringComparison.InvariantCultureIgnoreCase))
        {
          var pageCountString = message.Split(Constants.PageCount + " : ")[1]
            .Split('\n')[0]
            .Trim();
          pageCount.Add(Convert.ToInt32(pageCountString, CultureInfo.InvariantCulture));
        }
        else if (embeddedSend && message.Contains(Constants.Percentage, StringComparison.OrdinalIgnoreCase))
        {
          var percent = Convert.ToDouble(message.Split(PercentageStr)[1].Trim(), CultureInfo.InvariantCulture);
          var uploadPercent = GetUploadPercent(percent, currentUploadIndex, files.Count);
          this.UpdateEmbeddedProgressAsync(parentDocumentId, uploadPercent);
        }

        if (message.Contains(Constants.IsTaggedPdf, StringComparison.InvariantCultureIgnoreCase))
        {
          var isTaggedPdfString = message.Split(Constants.IsTaggedPdf + " : ")[1]
            .Trim();
          isTaggedPdf.Add(Convert.ToBoolean(isTaggedPdfString, CultureInfo.InvariantCulture));
        }
      }

      var responseWriter = new ResponseWriter<IServerStreamWriter<UploadResponse>>(null, ResponseInterceptor);
      if (request.PayloadType == DocumentQueueBase.SendTemplate || request.PayloadType == DocumentQueueBase.MergeAndSend)
      {
        BlobContainerClient cloudBlobContainer = null;
        BlobContainerClient thumbnailCloudBlobContainer = null;
        cloudBlobContainer = await this.cloudStorage.GetContainer(parentDocumentId, orgId).ConfigureAwait(false);
        thumbnailCloudBlobContainer = await this.cloudStorage
          .GetContainer($"{parentDocumentId}-{DbConstants.Thumbnails}", orgId).ConfigureAwait(false);
        await cloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
        await thumbnailCloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
      }

      for (var i = 0; i < documents.Count; i++)
      {
        currentUploadIndex = i;
        await responseWriter.WriteAsync($"index : {i}").ConfigureAwait(false);
        if (request.PayloadType == DocumentQueueBase.SendTemplate || request.PayloadType == DocumentQueueBase.MergeAndSend)
        {
          documents[i].ParentDocumentId = parentDocumentId;
        }
        else
        {
          documents[i].ParentDocumentId = i > 0 ? parentDocumentId : string.Empty;
        }

        documents[i].DocumentVersion = documentVersion;
        documents[i].OrganizationId = orgId;
        var preDefinedDocumentId = files[i].FileDocumentId;

        this.httpContext.Items.Remove(DocumentManipulatorService.UploadProgressOptionsKey);
        if (request.PayloadType == DocumentQueueBase.Template)
        {
          documents[i].UploadRequestType = UploadRequestType.Template;
        }

        var documentId = await this.documentManipulatorService.UploadAsync(
            documents[i],
            false,
            responseWriter,
            preDefinedDocumentId)
          .ConfigureAwait(false);
        documentIds.Add(documentId);

        // update final percent as 99%, since if we update as 100 then draft for embedded sending will not created yet
        // so, update here as 99% and once the draft document is created we can update 100% from document queue.
        var uploadPercent = GetUploadPercent(99, currentUploadIndex, files.Count);

        if (embeddedSend)
        {
          await this.UpdateEmbeddedProgressAsync(parentDocumentId, uploadPercent).ConfigureAwait(false);
        }
      }

      if (documents.Count > 1)
      {
        var documentProperties = new List<DocumentProperties>();

        for (var i = 0; i < files.Count(); i++)
        {
          documentProperties.Add(
            new DocumentProperties()
            {
              DocumentClientId = files[i].DocumentClientId,
              DocumentId = documentIds[i],
              DocumentName = files[i].FileName,
              FileSize = files[i].FileSize,
              FileType = ImageUtilityService.GetUploadFileType(files[i].ContentType),
              Order = i,
              ParentId = request.PayloadType == DocumentQueueBase.SendTemplate || request.PayloadType == DocumentQueueBase.MergeAndSend || i > 0
                  ? parentDocumentId
                  : string.Empty,
              UploadType = UploadType.Local,
              PageCount = pageCount[i],
              UploadRequestType = request.PayloadType == DocumentQueueBase.Template ? UploadRequestType.Template
                : UploadRequestType.Document,
            });
        }

        await this.documentManipulatorService.MultipleUploadAsync(documentProperties.ToArray(), orgId, default)
          .ConfigureAwait(false);
      }

      var uploadDocumentReply = new UploadResponse()
      {
        FileMessages = new List<FileMessage>(),
        SendForSign = JsonConvert.SerializeObject(sendForSign),
      };

      for (var i = 0; i < files.Count; i++)
      {
        uploadDocumentReply.FileMessages.Add(
          new FileMessage()
          {
            DocumentId = documentIds[i],
            DocumentClientId = files[i].DocumentClientId,
            FileName = files[i].FileName,
            FileType = files[i].ContentType,
            PageCount = pageCount[i],
            StreamLength = files[i].FileSize,
            IsTaggedPdf = isTaggedPdf.Count > i && isTaggedPdf[i],
          });
      }

      this.logger.LogInformation($"queue-upload: Upload completed for {request?.DocumentId}");

      return uploadDocumentReply;
    }

     public static void MapTextTagsToFields(
      ITextTag signRequestDetails,
      List<DocumentUploadDetails> documentUploadDetails,
      IDocumentManipulatorService documentManipulatorService,
      string businessProfileDateFormat,
      string businessProfileTimeFormat)
    {
      if (documentUploadDetails == null || documentUploadDetails.Count == 0)
      {
        return;
      }

      List<TextTagDefinition> combinedTags = new List<TextTagDefinition>();
      int pageIndex = 1;
      foreach (var documentUploadDetail in documentUploadDetails)
      {
        var contentType = DocumentContentType.GetDocumentType(documentUploadDetail.ContentType, documentUploadDetail.DocumentName);
        if (contentType == ContentType.Images)
        {
          pageIndex += 1;
          continue;
        }

        if (contentType == ContentType.Word)
        {
          using var stream = new MemoryStream(documentUploadDetail.DocumentArray);
          documentUploadDetail.DocumentArray = documentManipulatorService.ConvertWordToPdf(stream, null);
          documentUploadDetail.ContentType = "application/pdf";
        }

        if (contentType == ContentType.Excel)
        {
          using var stream = new MemoryStream(documentUploadDetail.DocumentArray);
          documentUploadDetail.DocumentArray = documentManipulatorService.ConvertExcelToPdf(stream, null);
          documentUploadDetail.ContentType = "application/pdf";
        }

        using DocumentTextExtractor documentTextExtractor = new DocumentTextExtractor(documentUploadDetail.DocumentArray);
        var documentTags = documentTextExtractor.ExtractTextTags(signRequestDetails.TextTagDefinitions, ref pageIndex);
        combinedTags.AddRange(documentTags);
      }

      if (signRequestDetails is SendForSign sendForSign)
      {
        MapTagsToSignerFields(sendForSign, combinedTags, businessProfileDateFormat, businessProfileTimeFormat);
        new TextTagDocumentValidator(sendForSign).Validate();
      }
      else if (signRequestDetails is CreateTemplateRequest createTemplate)
      {
        MapTagsToSignerFields(createTemplate, combinedTags, businessProfileDateFormat, businessProfileTimeFormat);
        new TextTagTemplateValidator(createTemplate).Validate();
      }
      else if (signRequestDetails is MergeAndSendForSign mergeTemplate)
      {
        MapTagsToSignerFields(mergeTemplate, combinedTags, businessProfileDateFormat, businessProfileTimeFormat);
        new MergeAndSendTextTagValidator(mergeTemplate).Validate();
      }
    }

    private static void MapTagsToSignerFields(SendForSign sendForSign, List<TextTagDefinition> combinedTags, string businessProfileDateFormat, string businessProfileTimeFormat)
    {
      int index = 1;

      if (sendForSign.Signers == null)
      {
        return;
      }

      foreach (var signer in sendForSign.Signers)
      {
        var signerTags = combinedTags.Where(x => x.SignerIndex == index).ToList();
        var fields = (signer.FormFields ?? new List<FormField>()).ToList();

        fields.AddRange(GetEquivalentFormFields(signerTags, businessProfileDateFormat, businessProfileTimeFormat));
        signer.FormFields = fields;

        index++;
      }
    }

    private static void MapTagsToSignerFields(CreateTemplateRequest createTemplate, List<TextTagDefinition> combinedTags, string businessProfileDateFormat, string businessProfileTimeFormat)
    {
      int index = 1;

      if (createTemplate.Roles == null)
      {
        return;
      }

      foreach (var role in createTemplate.Roles)
      {
        var signerTags = combinedTags.Where(x => x.SignerIndex == index).ToList();
        var fields = (role.FormFields ?? new List<FormField>()).ToList();

        fields.AddRange(GetEquivalentFormFields(signerTags, businessProfileDateFormat, businessProfileTimeFormat));
        role.FormFields = fields;

        index++;
      }
    }

    private static void MapTagsToSignerFields(MergeAndSendForSign mergeTemplate, List<TextTagDefinition> combinedTags, string businessProfileDateFormat, string businessProfileTimeFormat)
    {
      string prefix = "Text";
      string suffix = "Tag";
      if (combinedTags != null && combinedTags.Any())
      {
        foreach (var tag in combinedTags)
        {
          if (tag.FieldId == null)
          {
            tag.FieldId = $"{prefix}_definitions_{suffix}";
          }
          else
          {
            tag.FieldId = $"{tag.FieldId}{prefix}_definitions_{suffix}";
          }
        }

        var distinctSignerIndexes = combinedTags.Select(tag => tag.SignerIndex).Distinct().ToList();
        foreach (var signerIndex in distinctSignerIndexes)
        {
          Role role = null;
          if (mergeTemplate.Roles != null && mergeTemplate.Roles.Any())
          {
            role = mergeTemplate.Roles.FirstOrDefault(x => x.RoleIndex == signerIndex);
          }

          if (role == null)
          {
            if (mergeTemplate.Roles == null)
            {
              mergeTemplate.Roles = new List<Role>();
            }

            role = new Role { RoleIndex = signerIndex };
            mergeTemplate.Roles.Add(role);
          }

          if (role != null)
          {
            var signerTags = combinedTags.Where(x => x.SignerIndex == role.RoleIndex).ToList();
            var fields = (role.FormFields ?? new List<FormField>()).ToList();
            fields.AddRange(GetEquivalentFormFields(signerTags, businessProfileDateFormat, businessProfileTimeFormat));
            role.FormFields = fields;
          }
        }
      }
    }

    private static IEnumerable<FormField> GetEquivalentFormFields(List<TextTagDefinition> textTags, string businessProfileDateFormat, string businessProfileTimeFormat)
    {
      List<FormField> formFields = new List<FormField>();

      foreach (var tag in textTags)
      {
        var formField = new FormField
        {
          Id = tag.FieldId,
          Type = tag.Type.Value,
          PageNumber = tag.PageNumber,
          PlaceHolder = tag.Placeholder,
          Bounds = tag.Bounds,
          DateFormat = tag.DateFormat,
          TimeFormat = tag.TimeFormat,
          IsRequired = tag.IsRequired,
          GroupName = tag.RadioGroupName,
          DropdownOptions = tag.DropdownOptions,
          HyperlinkText = tag.HyperlinkText,
          ImageInfo = tag.ImageInfo,
          AttachmentInfo = tag.AttachmentInfo,
          IsReadOnly = tag.IsReadOnly,
          Label = tag.Label,
          TabIndex = tag.TabIndex,
          FormulaFieldSettings = tag.FormulaFieldSettings,
          DataSyncTag = tag.DataSyncTag,
          TextAlign = tag.TextAlign,
          TextDirection = tag.TextDirection,
          CharacterSpacing = tag.CharacterSpacing,
          CharacterLimit = tag.CharacterLimit,
          ResizeOption = tag.ResizeOption,
          AllowMultiline = tag.AllowMultiline,
        };

        if (formField.Type == FieldType.TextBox || formField.Type == FieldType.Label || formField.Type == FieldType.Dropdown || formField.Type == FieldType.Hyperlink || formField.Type == FieldType.Title || formField.Type == FieldType.Company || formField.Type == FieldType.CheckBox || formField.Type == FieldType.Image || formField.Type == FieldType.EditableDate || formField.Type == FieldType.RadioButton)
        {
          formField.Value = tag.Value;
          formField.BackgroundHexColor = formField.Type == FieldType.Label ? tag.BackgroundHexColor : null;
        }

        if (formField.Type == FieldType.EditableDate)
        {
          // Assigning default Editable Date Format "yyyy,MMM dd", if editable date field settings as null.
          if (tag.EditableDateFieldSettings == null)
          {
            tag.EditableDateFieldSettings = new EditableDateFieldSettings
            {
              DateFormat = !string.IsNullOrEmpty(businessProfileDateFormat) ? businessProfileDateFormat : DefaultEditableDateFormat,
            };
          }

          formField.EditableDateFieldSettings = tag.EditableDateFieldSettings;
        }

        if (formField.Type == FieldType.CheckBox && !string.IsNullOrEmpty(tag.GroupName))
        {
          formField.GroupName = tag.GroupName;
        }

        if (formField.Type == FieldType.DateSigned)
        {
          if (tag.DateFormat == null)
          {
            formField.DateFormat = businessProfileDateFormat;
          }

          if (tag.TimeFormat == null)
          {
            formField.TimeFormat = !string.IsNullOrEmpty(businessProfileTimeFormat) ? businessProfileTimeFormat : DefaultTimeFormat;
          }
        }

        if (tag.Validation != null)
        {
          formField.ValidationType = tag.Validation.Type switch
          {
            ValidationType.Currency => ApiManagement.Models.ValidationType.Currency,
            ValidationType.Email => ApiManagement.Models.ValidationType.EmailAddress,
            ValidationType.Regex => ApiManagement.Models.ValidationType.CustomRegex,
            ValidationType.NumberOnly => ApiManagement.Models.ValidationType.NumbersOnly,
            _ => ApiManagement.Models.ValidationType.None,
          };
          formField.ValidationCustomRegex = tag.Validation.Regex;
          formField.ValidationCustomRegexMessage = tag.Validation.RegexMessage;
        }

        if (tag.Font != null)
        {
          formField.Font = tag.Font.Name.Value;
          formField.LineHeight = tag.Font.LineHeight;
          formField.FontSize = tag.Font.Size;
          formField.FontHexColor = tag.Font.Color;
#pragma warning disable CS0618 // Type or member is obsolete
          formField.IsBoldFont = (tag.Font.Style != null && (tag.Font.Style.Value & FontStyle.Bold) == FontStyle.Bold) || tag.Font.IsBoldFont;
          formField.IsItalicFont = (tag.Font.Style != null && (tag.Font.Style.Value & FontStyle.Italic) == FontStyle.Italic) || tag.Font.IsItalicFont;
          formField.IsUnderLineFont = (tag.Font.Style != null && (tag.Font.Style.Value & FontStyle.Underline) == FontStyle.Underline) || tag.Font.IsUnderLineFont;
#pragma warning restore CS0618 // Type or member is obsolete
        }

        formFields.Add(formField);
      }

      return formFields;
    }

    -------
       public List<TextTagDefinition> ExtractTextTags(List<TextTagDefinition> definitionTags, ref int pageIndex)
    {
      List<TextTagDefinition> tags = new List<TextTagDefinition>();

      for (int i = 0; i < this.pdfLoadedDocument.Pages.Count; i++)
      {
        TextLineCollection textLineCollection = null;
        this.pdfLoadedDocument.Pages[i].ExtractText(out textLineCollection);

        foreach (var textLine in textLineCollection.TextLine)
        {
          definitionTags = definitionTags == null ? new List<TextTagDefinition>() : definitionTags;
          TextTagParser textParser = new TextTagParser(new List<string>() { textLine.Text }, definitionTags);
          var parsedTags = textParser.Parse();
          Syncfusion.Drawing.SizeF pageSize = this.pdfLoadedDocument.Pages[i].Size;
          this.SetBounds(textLine, parsedTags, pageSize);
          int index = pageIndex;
          parsedTags = parsedTags.Select(
              c =>
              {
                c.PageNumber = index;

                return c;
              })
            .ToList();
          tags.AddRange(parsedTags);
        }

        pageIndex++;
      }

      return tags;
    }
private List<TextTagDefinition> SetBounds(TextLine textLine, List<TextTagDefinition> parsedTags, Syncfusion.Drawing.SizeF pageSize)
    {
      var indexWord = 0;
      var path = new PdfPath();

      foreach (var tag in parsedTags)
      {
        var tagSpan = tag.TextTagContent.AsSpan();
        var braceStarted = false;
        var textBounds = default(Syncfusion.Drawing.RectangleF);

        for (; indexWord < textLine.WordCollection.Count && !tagSpan.IsEmpty; indexWord++)
        {
          var textWord = textLine.WordCollection[indexWord];
          var wordSpan = textWord.Text.AsSpan();

          if (!ProcessWord(ref tagSpan, ref braceStarted, wordSpan, textWord, path))
          {
            continue;
          }

          if (!tagSpan.IsEmpty)
          {
            throw new TextTagException(CommonResource.ErrorWhileProcessingTextTagDocument);
          }

          var finalBounds = path.GetBounds() == textBounds ? textBounds : path.GetBounds();
          this.SetBoundsToTextTags(tag, textWord, finalBounds, pageSize);
          path = new PdfPath();
          indexWord++;
          break;
        }
      }

      return parsedTags;
    }

    private static bool ProcessWord(ref ReadOnlySpan<char> tagSpan, ref bool braceStarted, ReadOnlySpan<char> wordSpan, TextWord textWord, PdfPath path)
    {
      if (tagSpan.Equals(wordSpan, StringComparison.OrdinalIgnoreCase))
      {
        path.AddRectangle(textWord.Bounds);
        tagSpan = ReadOnlySpan<char>.Empty;
        return true;
      }

      var indexOfStartBrace = wordSpan.IndexOf("{{", StringComparison.Ordinal);
      var indexOfEndBrace = wordSpan.IndexOf("}}", StringComparison.Ordinal);

      switch (indexOfStartBrace)
      {
        case >= 0 when
          indexOfEndBrace > indexOfStartBrace:
          AddGlyphsToPath(textWord, indexOfStartBrace, indexOfEndBrace + 2, path);
          tagSpan = ReadOnlySpan<char>.Empty;
          braceStarted = false;
          return true;
        case >= 0:
        {
          braceStarted = true;
          AddGlyphsToPath(textWord, indexOfStartBrace, textWord.Glyphs.Count, path);
          var charsToRemove = wordSpan.Length - indexOfStartBrace;
          tagSpan = tagSpan[charsToRemove..];
          return false;
        }
      }

      if (braceStarted && indexOfEndBrace >= 0)
      {
        AddGlyphsToPath(textWord, 0, indexOfEndBrace + 2, path);
        var charsToRemove = indexOfEndBrace + 2;
        tagSpan = tagSpan[charsToRemove..];
        braceStarted = false;
        return tagSpan.IsEmpty;
      }

      if (!tagSpan.StartsWith(wordSpan, StringComparison.OrdinalIgnoreCase))
      {
        return false;
      }

      AddGlyphsToPath(textWord, 0, textWord.Glyphs.Count, path);
      tagSpan = tagSpan[wordSpan.Length..];
      return tagSpan.IsEmpty;
        }

    private static void AddGlyphsToPath(TextWord textWord, int startIndex, int endIndex, PdfPath path)
    {
      for (var i = startIndex; i < endIndex && i < textWord.Glyphs.Count; i++)
      {
        var glyph = textWord.Glyphs[i];
        path.AddRectangle(glyph.Bounds);
      }
    }

    private void SetBoundsToTextTags(
      TextTagDefinition textTag,
      TextWord textWord,
      Syncfusion.Drawing.RectangleF totalBounds,
      Syncfusion.Drawing.SizeF pageSize)
    {
      var x = totalBounds.X + (float)(textTag.Offset?.OffsetX ?? 0);
      var y = totalBounds.Y + (float)(textTag.Offset?.OffsetY ?? 0);

      ValidateOffset(
        x,
        y,
        textTag,
        pageSize);

      totalBounds.X = x;
      totalBounds.Y = y;

      var textBoundsPixel = this.converter.ConvertToPixels(totalBounds, PdfGraphicsUnit.Point);

      if (textTag.Size != null)
      {
        textBoundsPixel.Width = textTag.Size.Width;
        textBoundsPixel.Height = textTag.Size.Height;
      }

      textTag.Bounds = new Rectangle()
      {
        X = textBoundsPixel.X,
        Y = textBoundsPixel.Y,
        Width = textBoundsPixel.Width,
        Height = textBoundsPixel.Height,
      };

      if (IsFontSupportedFieldType(textTag.Type))
      {
        InitializeFont(textTag, textWord);
      }
    }

    private static void ValidateOffset(
      float x,
      float y,
      TextTagDefinition textTag,
      Syncfusion.Drawing.SizeF pageSize)
    {
      var isXOutOfBounds = x < 0 || x > pageSize.Width;
      var isYOutOfBounds = y < 0 || y > pageSize.Height;

      if (!isXOutOfBounds && !isYOutOfBounds)
      {
        return;
      }

      var xMessage = isXOutOfBounds ? $"along the X-axis by {ComputeDifference(x, pageSize.Width)}" : string.Empty;
      var yMessage = isYOutOfBounds ? $"along the Y-axis by {ComputeDifference(y, pageSize.Height)}" : string.Empty;
      var combinedMessage = isXOutOfBounds && isYOutOfBounds ? $"{xMessage} and {yMessage}" : (xMessage + yMessage).Trim();

      var message = $"The text tag offset for {textTag.DefinitionId} of type {textTag.Type} exceeds the page bounds {combinedMessage}. "
        + $"Please check your offset values to ensure they stay within the page dimensions of (0, 0) and ({pageSize.Width}, {pageSize.Height}).";

      throw new TextTagException(message);
    }

    private static float ComputeDifference(float value, float limit)
    {
      return value < 0 ? value : value - limit;
    }

    private static bool IsFontSupportedFieldType(FieldType? fieldType)
    {
      return fieldType is FieldType.TextBox or FieldType.DateSigned or FieldType.Dropdown or FieldType.Hyperlink or FieldType.Title or FieldType.Company;
    }

    private static void InitializeFont(TextTagDefinition textTag, TextWord textWord)
    {
      textTag.Font ??= new Font
      {
        LineHeight = (int)textTag.Bounds.Height,
        Name = FontFamily.Helvetica,
        Size = textWord.FontSize,
#pragma warning disable CS0618 // Type or member is obsolete
        Style = null,
#pragma warning restore CS0618 // Type or member is obsolete
        IsBoldFont = false,
        IsItalicFont = false,
        IsUnderLineFont = false,
      };

      textTag.Font.Size = Math.Max(textTag.Font.Size, textWord.FontSize);
      textTag.Font.LineHeight = Math.Max(textTag.Font.LineHeight, (int)textTag.Bounds.Height);
      textTag.Font.Name ??= FontFamily.Helvetica;
    }
