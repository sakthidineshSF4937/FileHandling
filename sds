   private List<TextTagDefinition> SetBounds(TextLine textLine, List<TextTagDefinition> parsedTags, Syncfusion.Drawing.SizeF pageSize)
    {
      var indexWord = 0;
      var path = new PdfPath();

      foreach (var tag in parsedTags)
      {
        var tagSpan = tag.TextTagContent.AsSpan();
        var braceStarted = false;
        var textBounds = default(Syncfusion.Drawing.RectangleF);

        for (; indexWord < textLine.WordCollection.Count && !tagSpan.IsEmpty; indexWord++)
        {
          var textWord = textLine.WordCollection[indexWord];
          var wordSpan = textWord.Text.AsSpan();

          if (!ProcessWord(ref tagSpan, ref braceStarted, wordSpan, textWord, path))
          {
            continue;
          }

          if (!tagSpan.IsEmpty)
          {
            throw new TextTagException(CommonResource.ErrorWhileProcessingTextTagDocument);
          }

          var finalBounds = path.GetBounds() == textBounds ? textBounds : path.GetBounds();
          this.SetBoundsToTextTags(tag, textWord, finalBounds, pageSize);
          path = new PdfPath();
          indexWord++;
          break;
        }
      }

      return parsedTags;
    }

    private static bool ProcessWord(ref ReadOnlySpan<char> tagSpan, ref bool braceStarted, ReadOnlySpan<char> wordSpan, TextWord textWord, PdfPath path)
    {
      if (tagSpan.Equals(wordSpan, StringComparison.OrdinalIgnoreCase))
      {
        path.AddRectangle(textWord.Bounds);
        tagSpan = ReadOnlySpan<char>.Empty;
        return true;
      }

      var indexOfStartBrace = wordSpan.IndexOf("{{", StringComparison.Ordinal);
      var indexOfEndBrace = wordSpan.IndexOf("}}", StringComparison.Ordinal);

      switch (indexOfStartBrace)
      {
        case >= 0 when
          indexOfEndBrace > indexOfStartBrace:
          AddGlyphsToPath(textWord, indexOfStartBrace, indexOfEndBrace + 2, path);
          tagSpan = ReadOnlySpan<char>.Empty;
          braceStarted = false;
          return true;
        case >= 0:
        {
          braceStarted = true;
          AddGlyphsToPath(textWord, indexOfStartBrace, textWord.Glyphs.Count, path);
          var charsToRemove = wordSpan.Length - indexOfStartBrace;
          tagSpan = tagSpan[charsToRemove..];
          return false;
        }
      }

      if (braceStarted && indexOfEndBrace >= 0)
      {
        AddGlyphsToPath(textWord, 0, indexOfEndBrace + 2, path);
        var charsToRemove = indexOfEndBrace + 2;
        tagSpan = tagSpan[charsToRemove..];
        braceStarted = false;
        return tagSpan.IsEmpty;
      }

      if (!tagSpan.StartsWith(wordSpan, StringComparison.OrdinalIgnoreCase))
      {
        return false;
      }

      AddGlyphsToPath(textWord, 0, textWord.Glyphs.Count, path);
      tagSpan = tagSpan[wordSpan.Length..];
      return tagSpan.IsEmpty;
        }

    private static void AddGlyphsToPath(TextWord textWord, int startIndex, int endIndex, PdfPath path)
    {
      for (var i = startIndex; i < endIndex && i < textWord.Glyphs.Count; i++)
      {
        var glyph = textWord.Glyphs[i];
        path.AddRectangle(glyph.Bounds);
      }
    }

    private void SetBoundsToTextTags(
      TextTagDefinition textTag,
      TextWord textWord,
      Syncfusion.Drawing.RectangleF totalBounds,
      Syncfusion.Drawing.SizeF pageSize)
    {
      var x = totalBounds.X + (float)(textTag.Offset?.OffsetX ?? 0);
      var y = totalBounds.Y + (float)(textTag.Offset?.OffsetY ?? 0);

      ValidateOffset(
        x,
        y,
        textTag,
        pageSize);

      totalBounds.X = x;
      totalBounds.Y = y;

      var textBoundsPixel = this.converter.ConvertToPixels(totalBounds, PdfGraphicsUnit.Point);

      if (textTag.Size != null)
      {
        textBoundsPixel.Width = textTag.Size.Width;
        textBoundsPixel.Height = textTag.Size.Height;
      }

      textTag.Bounds = new Rectangle()
      {
        X = textBoundsPixel.X,
        Y = textBoundsPixel.Y,
        Width = textBoundsPixel.Width,
        Height = textBoundsPixel.Height,
      };
