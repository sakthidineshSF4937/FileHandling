    private async Task UploadAndManipulateDocument(string parentId, string uniqueId, string childId, bool isPrintSignDocument, IDocumentUploadDetails documentUploadDetails, IResponseWriter responseWriter, CancellationToken cancellationToken)
    {
      string message = CommonResource.DocumentClientId + $" : {documentUploadDetails.DocumentClientId}\n" + CommonResource.DocumentId + $" : {uniqueId}";

      await this.UpdateUploadProgress(message, false).ConfigureAwait(false);

      string scannedBlobName = string.Empty;
      DocumentDetails documentDetails = null;
      BlobContainerClient cloudBlobContainer = null;
      BlobContainerClient thumbnailCloudBlobContainer = null;
      var userID = new UserDataService(this.httpContext).Id;

      if (isPrintSignDocument)
      {
        uniqueId = documentUploadDetails.PrintSignDocumentId;
        parentId = documentUploadDetails.PrintSignDocumentId;
        childId = string.Empty;
        scannedBlobName = $"{DbConstants.ScannedDocument}/";
      }

      cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, documentUploadDetails.OrganizationId)
        .ConfigureAwait(false);
      thumbnailCloudBlobContainer = await this.CloudStorage
        .GetContainer($"{parentId}-{DbConstants.Thumbnails}", documentUploadDetails.OrganizationId)
        .ConfigureAwait(false);

      if (string.IsNullOrEmpty(childId) && string.IsNullOrEmpty(documentUploadDetails.PrintSignDocumentId))
      {
        await cloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
        await thumbnailCloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
      }

      ValidateCorruptedPDFDocument(documentUploadDetails);
      async Task ProgressCallback(string msg) => await this.UpdateUploadProgress(msg, false).ConfigureAwait(false);

      var documentProgress = new DocumentProgress(4, ProgressCallback);
      using Stream documentStream = await this.GetPdfDocumentStream(documentUploadDetails, cloudBlobContainer, thumbnailCloudBlobContainer, childId, documentProgress).ConfigureAwait(false);
      PdfDocument.EnableCache = false;
      using var pdfLoadedDocument = new PdfLoadedDocument(documentUploadDetails.DocumentArray);
      if (pdfLoadedDocument.IsXFAForm && pdfLoadedDocument.Form.Fields.Count == 0)
      {
        throw new InvalidDataException(CommonResource.DynamicXFAErrorMessage);
      }

      var contentType = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType);
      if (contentType != ContentType.Images)
      {
        try
        {
          var tasks = new List<Task>();
          tasks.Add(this.ProcessAndExtractPdfFormFields(pdfLoadedDocument, parentId, childId, documentUploadDetails.OrganizationId));
          tasks.Add(this.ExtractAndStoreTextTagFormFields(pdfLoadedDocument, parentId, childId, documentUploadDetails));
          await Task.WhenAll(tasks).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
          this.logger.LogError(ex, CommonResource.ExtractfieldError);
        }
      }

      try
      {
        if (contentType != ContentType.Images
            && (documentUploadDetails.UploadRequestType == UploadRequestType.Template || documentUploadDetails.UploadRequestType == UploadRequestType.UseTemplate))
        {
          var blobClientDocumentText = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentText}");
          await this.GetDocumentText(pdfLoadedDocument, blobClientDocumentText).ConfigureAwait(false);
        }
      }
      catch (Exception e)
      {
        this.logger.LogError(e, "Unable to extract document text for template auto positioning");
      }

      // we are writing the document id in response initially then we will only write in SignalR, hence we disable response write after we have written the document id
      if (responseWriter is ResponseWriter<HttpResponse> res)
      {
        var docIdResponse = new { documentId = uniqueId, documentClientId = documentUploadDetails.DocumentClientId, pageCount = pdfLoadedDocument.PageCount, isTaggedPdf = pdfLoadedDocument.FileStructure?.TaggedPdf ?? false };
        await res.WriteAsync(docIdResponse.ToJson()).ConfigureAwait(false);
        responseWriter = null;
      }

      pdfLoadedDocument.EnableMemoryOptimization = true;

      var conetntType = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType, documentUploadDetails.DocumentName);

      if (isPrintSignDocument)
      {
        documentDetails = await this.GetPrintSignDocumentDetails(this.httpContext, pdfLoadedDocument.PageCount, documentUploadDetails).ConfigureAwait(false);
        documentUploadDetails.DocumentVersion = documentDetails.DocumentVersion;
      }

      if (string.IsNullOrEmpty(documentUploadDetails.IsEditTemplate) || !(bool.TryParse(documentUploadDetails.IsEditTemplate, out bool isEditTemplate) && isEditTemplate))
      {
        await this.ValidateDocument(documentUploadDetails, pdfLoadedDocument, cloudBlobContainer).ConfigureAwait(false);
      }

      MemoryStream manipulatedDocumentStream = null;
      Task documentCLientUploadTask = null;
      try
      {
        var blobClientDocument = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.DocumentClient}");
        documentStream.Position = 0;
        documentCLientUploadTask = this.CloudStorage.UploadFromStreamAsync(blobClientDocument, documentStream, true);
        manipulatedDocumentStream = await this.ManipulatePDF(pdfLoadedDocument, documentProgress, parentId, conetntType, uniqueId, documentUploadDetails.OrganizationId).ConfigureAwait(false);

        if (manipulatedDocumentStream == null)
        {
          throw new NullReferenceException(CommonResource.EmptyManipulatedDocumentStream);
        }
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);

        throw;
      }

      documentProgress.Reset();
      var documentUploadProgress = new Progress<long>();
      var documentLength = manipulatedDocumentStream.Length;

      async void UploadDocumentHandler(object sender, long bytesUploaded)
      {
        await (documentProgress?.UpdateUploadProgress(bytesUploaded, documentLength)).ConfigureAwait(false);
      }

      documentUploadProgress.ProgressChanged += UploadDocumentHandler;

      var blobClient = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Document}");
      try
      {
        manipulatedDocumentStream.Position = 0;

        // Upload the manipulated PDF document.
        await this.CloudStorage.UploadFromStreamAsync(blobClient, manipulatedDocumentStream, true, documentUploadProgress, cancellationToken).ConfigureAwait(false);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);
      }

      await documentCLientUploadTask.ConfigureAwait(false);
      manipulatedDocumentStream.Position = 0;
      float zoomFactor = GetZoomFactor(documentUploadDetails?.DocumentVersion);
      try
      {
        // Images will be uploaded directly so no need of uploading it by converting PDF to image
        if (conetntType != ContentType.Images)
        {
          // Upload PDF viewer objects like page count, page size, images and thumbnail.
          blobClient = await this.UploadPdfViewerObjects(
            childId,
            documentUploadDetails.OrganizationId,
            documentProgress,
            manipulatedDocumentStream,
            cloudBlobContainer,
            parentId,
            scannedBlobName,
            documentDetails,
            zoomFactor,
            cancellationToken).ConfigureAwait(false);
        }

        await this.UpdateUploadProgress(string.Format(CultureInfo.InvariantCulture, "Completed"), false).ConfigureAwait(false);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);

        throw;
      }
      finally
      {
        documentStream.Dispose();
        manipulatedDocumentStream?.Dispose();
        documentUploadProgress.ProgressChanged -= UploadDocumentHandler;

        // Release all the fonts which are cached
        PdfDocument.ClearFontCache();
      }
    }

 private async Task<MemoryStream> ManipulatePDF(PdfLoadedDocument loadedDocument, DocumentProgress documentProgress, string documentId, ContentType contentType, string subDocumentId, string organizationId, bool isCloneProcess = false, bool canDrawDocId = false)
    {
      MemoryStream manipulatedDocumentStream = null;
      loadedDocument.FileStructure.IncrementalUpdate = false;
      if (loadedDocument.IsPortfolio)
      {
        throw new PdfException(string.Format(CultureInfo.InvariantCulture, Constants.Portfolio));
      }

      if (loadedDocument.Form != null && loadedDocument.Form.Fields.Count > 0)
      {
        loadedDocument.Form.Flatten = true;
      }

      if (loadedDocument.IsEncrypted)
      {
        loadedDocument.Security.OwnerPassword = string.Empty;
        loadedDocument.Security.Permissions = PdfPermissionsFlags.Default;
      }

      loadedDocument.DocumentInformation.Title = string.Empty;
      loadedDocument.DocumentInformation.Creator =
        Constants.SyncfusionPdfLibrary + " - " + Constants.PdfLibraryLink;
      loadedDocument.DocumentInformation.Producer = Constants.SyncfusionPdfLibrary;
      loadedDocument.DocumentInformation.AddCustomMetaDataInfo(CommonResource.DocumentIdMetaData, documentId);

      if (loadedDocument.Layers != null)
      {
        var layerCount = loadedDocument.Layers.Count;
        for (var i = layerCount - 1; i >= 0; i--)
        {
          loadedDocument.Layers.Remove(loadedDocument.Layers[i], false);
        }
      }

      int loadedPageCount = loadedDocument.Pages.Count;
      if (contentType != ContentType.Images)
      {
        string pageCountPattern = string.Format(CultureInfo.InvariantCulture, $"\n{Constants.PageCount} : {loadedPageCount.ToString(CultureInfo.InvariantCulture)}\n {Constants.IsTaggedPdf} : {loadedDocument.FileStructure?.TaggedPdf}");
        if (!isCloneProcess)
        {
          await this.UpdateUploadProgress(pageCountPattern, false).ConfigureAwait(false);
        }
      }

      string docIdText = string.Empty;

      if (canDrawDocId)
      {
        docIdText = CommonResource.DocumentIdText + documentId;
      }

      var uploadTasks = new List<Task>();
      for (var i = 0; i < loadedPageCount; i++)
      {
        var loadedPage = loadedDocument.Pages[i];
        loadedPage.Annotations.Flatten = true;

        if (canDrawDocId)
        {
          DrawDocumentId(loadedPage, docIdText);
        }

        if (!isCloneProcess && loadedDocument.FileStructure.TaggedPdf)
        {
          uploadTasks.Add(this.UploadTaggedPdfContent(loadedDocument, documentId, subDocumentId, i, organizationId));
        }
      }

      await Task.WhenAll(uploadTasks).ConfigureAwait(false);
      void PdfHandler(object sender, ProgressEventArgs arguments)
      {
        if (documentProgress != null)
        {
          _ = documentProgress.UpdateOverallProgress(arguments.Progress * 100);
        }
      }

      if (!isCloneProcess)
      {
        loadedDocument.SaveProgress += PdfHandler;
      }

      manipulatedDocumentStream = new MemoryStream();
      loadedDocument.Save(manipulatedDocumentStream);
      loadedDocument.SaveProgress -= PdfHandler;
      return manipulatedDocumentStream;
    }
//Create an instance of PdfDocument
using (PdfLoadedDocument loadedDocument = new PdfLoadedDocument("Data/Input.pdf"))
{
 //Remove the first page in the PDF document

 loadedDocument.Pages.RemoveAt(0);

 //Save and close the document
 loadedDocument.Save("Output.pdf");
}

