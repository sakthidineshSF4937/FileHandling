    private async Task UploadAndManipulateDocument(string parentId, string uniqueId, string childId, bool isPrintSignDocument, IDocumentUploadDetails documentUploadDetails, IResponseWriter responseWriter, CancellationToken cancellationToken)
    {
      string message = CommonResource.DocumentClientId + $" : {documentUploadDetails.DocumentClientId}\n" + CommonResource.DocumentId + $" : {uniqueId}";

      await this.UpdateUploadProgress(message, false).ConfigureAwait(false);

      string scannedBlobName = string.Empty;
      DocumentDetails documentDetails = null;
      BlobContainerClient cloudBlobContainer = null;
      BlobContainerClient thumbnailCloudBlobContainer = null;
      var userID = new UserDataService(this.httpContext).Id;

      if (isPrintSignDocument)
      {
        uniqueId = documentUploadDetails.PrintSignDocumentId;
        parentId = documentUploadDetails.PrintSignDocumentId;
        childId = string.Empty;
        scannedBlobName = $"{DbConstants.ScannedDocument}/";
      }

      cloudBlobContainer = await this.CloudStorage.GetContainer(parentId, documentUploadDetails.OrganizationId)
        .ConfigureAwait(false);
      thumbnailCloudBlobContainer = await this.CloudStorage
        .GetContainer($"{parentId}-{DbConstants.Thumbnails}", documentUploadDetails.OrganizationId)
        .ConfigureAwait(false);

      if (string.IsNullOrEmpty(childId) && string.IsNullOrEmpty(documentUploadDetails.PrintSignDocumentId))
      {
        await cloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
        await thumbnailCloudBlobContainer.CreateIfNotExistsAsync().ConfigureAwait(false);
      }

      ValidateCorruptedPDFDocument(documentUploadDetails);
      async Task ProgressCallback(string msg) => await this.UpdateUploadProgress(msg, false).ConfigureAwait(false);

      var documentProgress = new DocumentProgress(4, ProgressCallback);
      using Stream documentStream = await this.GetPdfDocumentStream(documentUploadDetails, cloudBlobContainer, thumbnailCloudBlobContainer, childId, documentProgress).ConfigureAwait(false);
      PdfDocument.EnableCache = false;
      using var pdfLoadedDocument = new PdfLoadedDocument(documentUploadDetails.DocumentArray);
      if (pdfLoadedDocument.IsXFAForm && pdfLoadedDocument.Form.Fields.Count == 0)
      {
        throw new InvalidDataException(CommonResource.DynamicXFAErrorMessage);
      }

      var contentType = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType);
      if (contentType != ContentType.Images)
      {
        try
        {
          var tasks = new List<Task>();
          tasks.Add(this.ProcessAndExtractPdfFormFields(pdfLoadedDocument, parentId, childId, documentUploadDetails.OrganizationId));
          tasks.Add(this.ExtractAndStoreTextTagFormFields(pdfLoadedDocument, parentId, childId, documentUploadDetails));
          await Task.WhenAll(tasks).ConfigureAwait(false);
        }
        catch (Exception ex)
        {
          this.logger.LogError(ex, CommonResource.ExtractfieldError);
        }
      }

      try
      {
        if (contentType != ContentType.Images
            && (documentUploadDetails.UploadRequestType == UploadRequestType.Template || documentUploadDetails.UploadRequestType == UploadRequestType.UseTemplate))
        {
          var blobClientDocumentText = cloudBlobContainer.GetBlobClient($"{childId}{DbConstants.DocumentText}");
          await this.GetDocumentText(pdfLoadedDocument, blobClientDocumentText).ConfigureAwait(false);
        }
      }
      catch (Exception e)
      {
        this.logger.LogError(e, "Unable to extract document text for template auto positioning");
      }

      // we are writing the document id in response initially then we will only write in SignalR, hence we disable response write after we have written the document id
      if (responseWriter is ResponseWriter<HttpResponse> res)
      {
        var docIdResponse = new { documentId = uniqueId, documentClientId = documentUploadDetails.DocumentClientId, pageCount = pdfLoadedDocument.PageCount, isTaggedPdf = pdfLoadedDocument.FileStructure?.TaggedPdf ?? false };
        await res.WriteAsync(docIdResponse.ToJson()).ConfigureAwait(false);
        responseWriter = null;
      }

      pdfLoadedDocument.EnableMemoryOptimization = true;

      var conetntType = DocumentContentType.GetDocumentType(documentUploadDetails.ContentType, documentUploadDetails.DocumentName);

      if (isPrintSignDocument)
      {
        documentDetails = await this.GetPrintSignDocumentDetails(this.httpContext, pdfLoadedDocument.PageCount, documentUploadDetails).ConfigureAwait(false);
        documentUploadDetails.DocumentVersion = documentDetails.DocumentVersion;
      }

      if (string.IsNullOrEmpty(documentUploadDetails.IsEditTemplate) || !(bool.TryParse(documentUploadDetails.IsEditTemplate, out bool isEditTemplate) && isEditTemplate))
      {
        await this.ValidateDocument(documentUploadDetails, pdfLoadedDocument, cloudBlobContainer).ConfigureAwait(false);
      }

      MemoryStream manipulatedDocumentStream = null;
      Task documentCLientUploadTask = null;
      try
      {
        var blobClientDocument = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.DocumentClient}");
        documentStream.Position = 0;
        documentCLientUploadTask = this.CloudStorage.UploadFromStreamAsync(blobClientDocument, documentStream, true);
        manipulatedDocumentStream = await this.ManipulatePDF(pdfLoadedDocument, documentProgress, parentId, conetntType, uniqueId, documentUploadDetails.OrganizationId).ConfigureAwait(false);

        if (manipulatedDocumentStream == null)
        {
          throw new NullReferenceException(CommonResource.EmptyManipulatedDocumentStream);
        }
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);

        throw;
      }

      documentProgress.Reset();
      var documentUploadProgress = new Progress<long>();
      var documentLength = manipulatedDocumentStream.Length;

      async void UploadDocumentHandler(object sender, long bytesUploaded)
      {
        await (documentProgress?.UpdateUploadProgress(bytesUploaded, documentLength)).ConfigureAwait(false);
      }

      documentUploadProgress.ProgressChanged += UploadDocumentHandler;

      var blobClient = cloudBlobContainer.GetBlobClient($"{scannedBlobName}{childId}{DbConstants.Document}");
      try
      {
        manipulatedDocumentStream.Position = 0;

        // Upload the manipulated PDF document.
        await this.CloudStorage.UploadFromStreamAsync(blobClient, manipulatedDocumentStream, true, documentUploadProgress, cancellationToken).ConfigureAwait(false);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);
      }

      await documentCLientUploadTask.ConfigureAwait(false);
      manipulatedDocumentStream.Position = 0;
      float zoomFactor = GetZoomFactor(documentUploadDetails?.DocumentVersion);
      try
      {
        // Images will be uploaded directly so no need of uploading it by converting PDF to image
        if (conetntType != ContentType.Images)
        {
          // Upload PDF viewer objects like page count, page size, images and thumbnail.
          blobClient = await this.UploadPdfViewerObjects(
            childId,
            documentUploadDetails.OrganizationId,
            documentProgress,
            manipulatedDocumentStream,
            cloudBlobContainer,
            parentId,
            scannedBlobName,
            documentDetails,
            zoomFactor,
            cancellationToken).ConfigureAwait(false);
        }

        await this.UpdateUploadProgress(string.Format(CultureInfo.InvariantCulture, "Completed"), false).ConfigureAwait(false);
      }
      catch (Exception ex)
      {
        this.logger.LogError(ex, CommonResource.ErrorWhileUploading);

        throw;
      }
      finally
      {
        documentStream.Dispose();
        manipulatedDocumentStream?.Dispose();
        documentUploadProgress.ProgressChanged -= UploadDocumentHandler;

        // Release all the fonts which are cached
        PdfDocument.ClearFontCache();
      }
    }

 private async Task<MemoryStream> ManipulatePDF(PdfLoadedDocument loadedDocument, DocumentProgress documentProgress, string documentId, ContentType contentType, string subDocumentId, string organizationId, bool isCloneProcess = false, bool canDrawDocId = false)
    {
      MemoryStream manipulatedDocumentStream = null;
      loadedDocument.FileStructure.IncrementalUpdate = false;
      if (loadedDocument.IsPortfolio)
      {
        throw new PdfException(string.Format(CultureInfo.InvariantCulture, Constants.Portfolio));
      }

      if (loadedDocument.Form != null && loadedDocument.Form.Fields.Count > 0)
      {
        loadedDocument.Form.Flatten = true;
      }

      if (loadedDocument.IsEncrypted)
      {
        loadedDocument.Security.OwnerPassword = string.Empty;
        loadedDocument.Security.Permissions = PdfPermissionsFlags.Default;
      }

      loadedDocument.DocumentInformation.Title = string.Empty;
      loadedDocument.DocumentInformation.Creator =
        Constants.SyncfusionPdfLibrary + " - " + Constants.PdfLibraryLink;
      loadedDocument.DocumentInformation.Producer = Constants.SyncfusionPdfLibrary;
      loadedDocument.DocumentInformation.AddCustomMetaDataInfo(CommonResource.DocumentIdMetaData, documentId);

      if (loadedDocument.Layers != null)
      {
        var layerCount = loadedDocument.Layers.Count;
        for (var i = layerCount - 1; i >= 0; i--)
        {
          loadedDocument.Layers.Remove(loadedDocument.Layers[i], false);
        }
      }

      int loadedPageCount = loadedDocument.Pages.Count;
      if (contentType != ContentType.Images)
      {
        string pageCountPattern = string.Format(CultureInfo.InvariantCulture, $"\n{Constants.PageCount} : {loadedPageCount.ToString(CultureInfo.InvariantCulture)}\n {Constants.IsTaggedPdf} : {loadedDocument.FileStructure?.TaggedPdf}");
        if (!isCloneProcess)
        {
          await this.UpdateUploadProgress(pageCountPattern, false).ConfigureAwait(false);
        }
      }

      string docIdText = string.Empty;

      if (canDrawDocId)
      {
        docIdText = CommonResource.DocumentIdText + documentId;
      }

      var uploadTasks = new List<Task>();
      for (var i = 0; i < loadedPageCount; i++)
      {
        var loadedPage = loadedDocument.Pages[i];
        loadedPage.Annotations.Flatten = true;

        if (canDrawDocId)
        {
          DrawDocumentId(loadedPage, docIdText);
        }

        if (!isCloneProcess && loadedDocument.FileStructure.TaggedPdf)
        {
          uploadTasks.Add(this.UploadTaggedPdfContent(loadedDocument, documentId, subDocumentId, i, organizationId));
        }
      }

      await Task.WhenAll(uploadTasks).ConfigureAwait(false);
      void PdfHandler(object sender, ProgressEventArgs arguments)
      {
        if (documentProgress != null)
        {
          _ = documentProgress.UpdateOverallProgress(arguments.Progress * 100);
        }
      }

      if (!isCloneProcess)
      {
        loadedDocument.SaveProgress += PdfHandler;
      }

      manipulatedDocumentStream = new MemoryStream();
      loadedDocument.Save(manipulatedDocumentStream);
      loadedDocument.SaveProgress -= PdfHandler;
      return manipulatedDocumentStream;
    }
public async Task<bool> DeletePage(DeletePageDetails deletePageDetails, CancellationToken token)
{
    try
    {
        var organizationId = this.userDataService?.OrganizationId;
        BlobContainerClient container = await this.CloudStorage
            .GetContainer(deletePageDetails.DocumentId, organizationId)
            .ConfigureAwait(false);

        var documentBlob = container.GetBlobClient(DbConstants.Document);
        using var documentStream = new MemoryStream();
        await this.CloudStorage.DownloadToStreamAsync(documentBlob, documentStream, true, token)
            .ConfigureAwait(false);

        using (var loadedDocument = new PdfLoadedDocument(documentStream))
        {
            loadedDocument.Pages.RemoveAt(deletePageDetails.SelectedPageNo - 1);

            using var modifiedStream = new MemoryStream();
            loadedDocument.Save(modifiedStream);
            modifiedStream.Position = 0;

            await this.CloudStorage.UploadFromStreamAsync(documentBlob, modifiedStream, true)
                .ConfigureAwait(false);

            string parentId = string.Empty;
            string baseContainerName = string.IsNullOrEmpty(parentId)
                ? $"{deletePageDetails.DocumentId}-{DbConstants.Thumbnails}"
                : $"{parentId}-{DbConstants.Thumbnails}";

            BlobContainerClient blobThumbnailContainer = await this.CloudStorage
                .GetContainer(baseContainerName, organizationId).ConfigureAwait(false);

            await this.DeleteThumbnail(deletePageDetails, blobThumbnailContainer, deletePageDetails.SelectedPageNo, parentId, token);

            await this.DeleteAllPageCaches(container,deletePageDetails,deletePageDetails.SelectedPageNo - 1, token);
            
            return true;
        }
    }
    catch (Exception ex)
    {
        this.logger.LogError(ex, "Error deleting page");
        return false;
    }
}

private async Task DeleteThumbnail(DeletePageDetails deletePageDetails, BlobContainerClient container, int pageIndex, string parentId, CancellationToken token)
{
    try
    {
      var selectedpage=pageIndex-1;
        string blobPath = string.IsNullOrEmpty(parentId)
            ? $"{DbConstants.Thumbnail}-{selectedpage}.png"
            : $"{deletePageDetails.DocumentId}/{DbConstants.Thumbnail}-{selectedpage}.png";

        this.logger.LogInformation("Attempting to delete thumbnail: {BlobPath} from container: {ContainerName}", blobPath, container.Name);

        var blob = container.GetBlobClient(blobPath);

        await container.DeleteBlobIfExistsAsync(blob.Name, cancellationToken: token).ConfigureAwait(false);

        Console.WriteLine("Thumbnail Deleted");
    }
    catch (Exception ex)
    {
        this.logger.LogError(ex, "Error deleting Thumbnail");
        // throw; // Uncomment if you want to surface the exception for debugging
    }
}

private async Task DeleteAllPageCaches(BlobContainerClient container,DeletePageDetails deletePage ,int pageIndex, CancellationToken token)
{
    try
    {
        var parentId=String.Empty;
        var blobDirectoryName=string.Empty;
        if (string.IsNullOrEmpty(parentId))
        {
            blobDirectoryName = $"{deletePage.DocumentId}/";
        }
        // var scaleFactor=1;  
        // var blobName = $"{blobDirectoryName}{DbConstants.Page}-{pageIndex}-{scaleFactor}-webp";
        // //8690605c-bcf8-4a3d-88ed-5e644424bb98/page-0-1-webp
        // var pageblob = container.GetBlobsAsync(prefix:$"{blobName}");
        // await foreach (var blob1 in pageblob)
        // {
        //   // var page1=await container.DeleteIfExistsAsync(blob1.Name,conditions=null,cancellationToken: token).ConfigureAwait(false);
        //  var page=await container.DeleteBlobIfExistsAsync(blob1.Name, conditions: null, cancellationToken: token).ConfigureAwait(false);

        // }
        var scaleFactor = 1;

        if (string.IsNullOrEmpty(parentId))
        {
            blobDirectoryName = $"{deletePage.DocumentId}/";
        }

        var blobName = $"{blobDirectoryName}{DbConstants.Page}-{pageIndex}-{scaleFactor}-webp";
        
        var prefix = $"{blobDirectoryName}{DbConstants.Page}-{pageIndex}-";

// Now use the updated prefix
        //  var pageBlobs = container.GetBlobsAsync(prefix: prefix);
        //  await foreach (var blobItem in pageBlobs)
        //  {
        //      await container.DeleteBlobIfExistsAsync(blobItem.Name, cancellationToken: token)
        //          .ConfigureAwait(false);
        //  }

        // var page=await container.DeleteIfExistsAsync(pageblob.n).ConfigureAwait(false);
        


        var pageBlobs = container.GetBlobsAsync(prefix: $"{DbConstants.Page}-{pageIndex}-");
        await foreach (var blobItem in pageBlobs)
        {
            await container.DeleteBlobIfExistsAsync(blobItem.Name, cancellationToken: token)
                .ConfigureAwait(false);
        }

        // // Delete WebP versions
        // var webpBlobs = container.GetBlobsAsync(prefix: $"{DbConstants.Page}-{pageIndex}-", traits: BlobTraits.None, states: BlobStates.None, cancellationToken: token);
        // await foreach (var blobItem in webpBlobs)
        // {
        //     if (blobItem.Name.EndsWith("-webp"))
        //     {
        //         await container.DeleteBlobIfExistsAsync(blobItem.Name, cancellationToken: token)
        //             .ConfigureAwait(false);
        //     }
        // }
    }
    catch (Exception ex)
    {
        this.logger.LogError(ex, "Error deleting page caches");
        throw;
    }
}
}

